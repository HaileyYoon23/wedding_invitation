import { Synced } from "../Synced.svelte";
import { dataAttr } from "../utils/attribute";
import { addEventListener } from "../utils/event";
import { extract } from "../utils/extract";
import { createBuilderMetadata } from "../utils/identifiers";
import { isFunction, isHtmlElement } from "../utils/is";
import { deepMerge } from "../utils/merge";
import { safelyHidePopover, safelyShowPopover } from "../utils/popover";
import { useFloating, } from "../utils/use-floating.svelte";
import { nanoid } from "nanoid";
import { useEventListener } from "runed";
const { dataAttrs, dataSelectors } = createBuilderMetadata("popover", [
    "trigger",
    "content",
    "arrow",
]);
export const isCloseOnOutsideClickCheck = (value) => isFunction(value) && value.length === 1;
export class BasePopover {
    ids = $state({ invoker: nanoid(), popover: nanoid() });
    /* Props */
    #props;
    forceVisible = $derived(extract(this.#props.forceVisible, false));
    closeOnEscape = $derived(extract(this.#props.closeOnEscape, true));
    sameWidth = $derived(extract(this.#props.sameWidth, false));
    closeOnOutsideClick = $derived(extract(this.#props.closeOnOutsideClick, true));
    floatingConfig = $derived.by(() => {
        const config = extract(this.#props.floatingConfig, {});
        const sameWidth = extract(this.#props.sameWidth);
        const merged = deepMerge(config, sameWidth !== undefined ? { sameWidth } : {});
        return merged;
    });
    /* State */
    #open;
    constructor(props = {}) {
        this.#open = new Synced({
            value: props.open,
            onChange: props.onOpenChange,
            defaultValue: false,
        });
        this.#props = props;
    }
    get open() {
        return this.#open.current;
    }
    set open(value) {
        this.#open.current = value;
    }
    #shouldClose(el) {
        if (this.closeOnOutsideClick === false)
            return false;
        if (isFunction(this.closeOnOutsideClick)) {
            return isCloseOnOutsideClickCheck(this.closeOnOutsideClick)
                ? this.closeOnOutsideClick(el) // Pass target if it's the correct type
                : this.closeOnOutsideClick(); // Otherwise, call without arguments
        }
        return true;
    }
    get sharedProps() {
        return {
            onfocusout: async () => {
                await new Promise((r) => setTimeout(r));
                const contentEl = document.getElementById(this.ids.popover);
                const triggerEl = document.getElementById(this.ids.invoker);
                const activeEl = document.activeElement;
                if (!activeEl ||
                    contentEl?.contains(activeEl) ||
                    triggerEl?.contains(activeEl) ||
                    !this.#shouldClose(activeEl) // Hack, we should probably have a focusOut prop
                ) {
                    return;
                }
                this.open = false;
            },
        };
    }
    /** The trigger that toggles the value. */
    getInvoker() {
        return {
            id: this.ids.invoker,
            popovertarget: this.ids.popover,
            onclick: (e) => {
                e.preventDefault();
                this.open = !this.open;
            },
            ...this.sharedProps,
        };
    }
    getPopover() {
        // Show and hide popover based on open state
        $effect(() => {
            const el = document.getElementById(this.ids.popover);
            if (!isHtmlElement(el)) {
                return;
            }
            if (this.open || this.forceVisible) {
                // Check if there's a parent popover. If so, only open if the parent's open.
                // This is to guarantee correct layering.
                const parent = isHtmlElement(el.parentNode)
                    ? el.parentNode.closest(dataSelectors.content)
                    : undefined;
                if (!isHtmlElement(parent)) {
                    safelyShowPopover(el);
                    return;
                }
                if (parent.dataset.open !== undefined)
                    safelyShowPopover(el);
                return addEventListener(parent, "toggle", async (e) => {
                    await new Promise((r) => setTimeout(r));
                    const isOpen = e.newState === "open";
                    if (isOpen) {
                        safelyShowPopover(el);
                    }
                    else {
                        safelyHidePopover(el);
                    }
                });
            }
            else {
                safelyHidePopover(el);
            }
        });
        $effect(() => {
            const contentEl = document.getElementById(this.ids.popover);
            const triggerEl = document.getElementById(this.ids.invoker);
            if (!isHtmlElement(contentEl) || !isHtmlElement(triggerEl) || !this.open) {
                return;
            }
            useFloating({
                node: () => triggerEl,
                floating: () => contentEl,
                config: () => this.floatingConfig,
            });
        });
        useEventListener(() => document, "keydown", (e) => {
            if (!this.closeOnEscape)
                return;
            const el = document.getElementById(this.ids.popover);
            if (e.key !== "Escape" || !this.open || !isHtmlElement(el))
                return;
            e.preventDefault();
            const openPopovers = [...el.querySelectorAll("[popover]")].filter((child) => {
                if (!isHtmlElement(child))
                    return false;
                // If child is a Melt popover, check if it's open
                if (child.matches(dataSelectors.content))
                    return child.dataset.open !== undefined;
                return child.matches(":popover-open");
            });
            if (openPopovers.length)
                return;
            // Set timeout to give time to all event listeners to run
            setTimeout(() => (this.open = false));
        });
        useEventListener(() => document, "click", (e) => {
            if (!this.open)
                return; // Exit early if not open
            const contentEl = document.getElementById(this.ids.popover);
            const triggerEl = document.getElementById(this.ids.invoker);
            if (!contentEl || !triggerEl)
                return; // Exit if elements are missing
            const target = e.target;
            const isInsideContent = contentEl.contains(target);
            const isInsideTrigger = triggerEl.contains(target);
            if (isInsideContent || isInsideTrigger)
                return; // Exit if clicked inside
            if (this.#shouldClose(target))
                this.open = false;
        });
        return {
            id: this.ids.popover,
            popover: "manual",
            ontoggle: (e) => {
                const newOpen = e.newState === "open";
                if (this.open !== newOpen && newOpen === false) {
                    this.open = newOpen;
                }
            },
            // Needed so it receives focus on click, but not on tab, because of focus out
            tabindex: -1,
            inert: !this.open,
            "data-open": dataAttr(this.open),
            ...this.sharedProps,
        };
    }
    get arrow() {
        return {
            [dataAttrs.arrow]: "",
            "data-arrow": "",
            "aria-hidden": true,
            "data-open": dataAttr(this.open),
        };
    }
}
export class Popover extends BasePopover {
    constructor(props = {}) {
        super({ ...props });
        this.ids = { ...this.ids, trigger: this.ids.invoker, content: this.ids.popover };
    }
    /** The trigger that toggles the value. */
    get trigger() {
        return Object.assign(this.getInvoker(), {
            [dataAttrs.trigger]: "",
        });
    }
    get content() {
        return Object.assign(this.getPopover(), {
            [dataAttrs.content]: "",
        });
    }
}
