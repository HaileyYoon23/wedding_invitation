import type { MaybeGetter } from "../types";
import { type ComputePositionConfig, type VirtualElement, type ShiftOptions, type FlipOptions, type ArrowOptions, type OffsetOptions, type ComputePositionReturn } from "@floating-ui/dom";
export type FloatingApply = (el?: HTMLElement) => void;
export type ArrowApply = (el?: HTMLElement) => void;
export type OnComputeArgs = ComputePositionReturn & {
    floatingApply: FloatingApply;
    arrowApply: ArrowApply;
};
export type OnCompute = (args: OnComputeArgs) => void;
/**
 * Config for UseFloating. You may pass in options to the underlying Floating UI
 * `computePosition`, or to the middleware's Melt calls initially.
 */
export type UseFloatingConfig = {
    computePosition?: Partial<ComputePositionConfig>;
    shift?: ShiftOptions;
    flip?: FlipOptions;
    arrow?: ArrowOptions;
    offset?: OffsetOptions;
    sameWidth?: boolean;
    /**
     * Use a custom function when `computePosition` is returned.
     *
     * This will override default behaviour! If you want to add
     * functionality while keeping the original intact, just call
     * `floatingApply` and `arrowApply` respectively.
     */
    onCompute?: OnCompute;
};
/** All the parameters UseFloating returns */
export type UseFloatingArgs = {
    node: MaybeGetter<HTMLElement | VirtualElement>;
    floating: MaybeGetter<HTMLElement>;
    config?: MaybeGetter<UseFloatingConfig | undefined>;
};
export declare function useFloating(args: UseFloatingArgs): {
    readonly data: ComputePositionReturn | undefined;
};
