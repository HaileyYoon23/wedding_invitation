import {
  SvelteMap,
  SvelteSet
} from "./chunk-A6YLG3MD.js";
import "./chunk-7USGHRJB.js";
import {
  createSubscriber
} from "./chunk-MZXTZC76.js";
import "./chunk-5GBR7KEJ.js";
import "./chunk-3HSYYFCG.js";
import "./chunk-3ZAVAQ66.js";
import {
  ADD_OWNER,
  add_owner_to_class,
  effect_root,
  effect_tracking,
  equals,
  get,
  on,
  proxy,
  set,
  snapshot,
  state,
  strict_equals,
  tick,
  untrack,
  user_derived,
  user_effect,
  user_pre_effect
} from "./chunk-WIORT5JL.js";
import "./chunk-KC3ATM5O.js";
import {
  true_default
} from "./chunk-3LUZOQLA.js";
import "./chunk-BHDPSPUI.js";
import {
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __privateWrapper,
  __publicField
} from "./chunk-KWPVD4H7.js";

// node_modules/.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/is.js
function isHtmlElement(element) {
  return element instanceof HTMLElement;
}
function isNode(element) {
  return element instanceof Node;
}
function isFunction(value) {
  return typeof value === "function";
}
function isGetter(value) {
  return isFunction(value) && value.length === 0;
}
function isSvelteSet(value) {
  return value instanceof SvelteSet;
}
function isIterable(value) {
  return value !== null && typeof value === "object" && Symbol.iterator in value;
}
function isHtmlInputElement(element) {
  return element instanceof HTMLInputElement;
}
function isString(value) {
  return typeof value === "string";
}
function isTouch(event) {
  return event.pointerType === "touch";
}

// node_modules/.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/extract.js
function extract(value, defaultValue) {
  if (isGetter(value)) {
    const getter = value;
    const gotten = getter();
    if (gotten === void 0)
      return defaultValue;
    return gotten;
  }
  if (value === void 0)
    return defaultValue;
  return value;
}

// node_modules/.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/iterator.js
function last(values) {
  let result;
  for (const value of values) {
    result = value;
  }
  return result;
}
function first(values) {
  let result;
  for (const value of values) {
    result = value;
    break;
  }
  return result;
}
function forEach(values, callback) {
  for (const value of values) {
    callback(value);
  }
}

// node_modules/.pnpm/runed@0.23.4_svelte@5.25.6/node_modules/runed/dist/internal/configurable-globals.js
var defaultWindow = true_default && typeof window !== "undefined" ? window : void 0;
var defaultDocument = true_default && typeof window !== "undefined" ? window.document : void 0;
var defaultNavigator = true_default && typeof window !== "undefined" ? window.navigator : void 0;
var defaultLocation = true_default && typeof window !== "undefined" ? window.location : void 0;

// node_modules/.pnpm/runed@0.23.4_svelte@5.25.6/node_modules/runed/dist/internal/utils/dom.js
function getActiveElement(document2) {
  let activeElement2 = document2.activeElement;
  while (activeElement2 == null ? void 0 : activeElement2.shadowRoot) {
    const node = activeElement2.shadowRoot.activeElement;
    if (node === activeElement2)
      break;
    else
      activeElement2 = node;
  }
  return activeElement2;
}

// node_modules/.pnpm/runed@0.23.4_svelte@5.25.6/node_modules/runed/dist/utilities/active-element/active-element.svelte.js
var _document, _subscribe;
var ActiveElement = class {
  constructor(options = {}) {
    __privateAdd(this, _document);
    __privateAdd(this, _subscribe);
    const {
      window: window2 = defaultWindow,
      document: document2 = window2 == null ? void 0 : window2.document
    } = options;
    if (strict_equals(window2, void 0)) return;
    __privateSet(this, _document, document2);
    __privateSet(this, _subscribe, createSubscriber((update) => {
      const cleanupFocusIn = on(window2, "focusin", update);
      const cleanupFocusOut = on(window2, "focusout", update);
      return () => {
        cleanupFocusIn();
        cleanupFocusOut();
      };
    }));
  }
  get current() {
    var _a;
    (_a = __privateGet(this, _subscribe)) == null ? void 0 : _a.call(this);
    if (!__privateGet(this, _document)) return null;
    return getActiveElement(__privateGet(this, _document));
  }
};
_document = new WeakMap();
_subscribe = new WeakMap();
var activeElement = new ActiveElement();

// node_modules/.pnpm/runed@0.23.4_svelte@5.25.6/node_modules/runed/dist/internal/utils/is.js
function isFunction2(value) {
  return typeof value === "function";
}

// node_modules/.pnpm/runed@0.23.4_svelte@5.25.6/node_modules/runed/dist/utilities/extract/extract.svelte.js
function extract2(value, defaultValue) {
  if (isFunction2(value)) {
    const getter = value;
    return getter() ?? defaultValue ?? getter();
  }
  return value ?? defaultValue ?? value;
}

// node_modules/.pnpm/runed@0.23.4_svelte@5.25.6/node_modules/runed/dist/utilities/use-debounce/use-debounce.svelte.js
function useDebounce(callback, wait = 250) {
  let context = state(null);
  function debounced(...args) {
    if (get(context)) {
      if (get(context).timeout) {
        clearTimeout(get(context).timeout);
      }
    } else {
      let resolve;
      let reject;
      const promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
      });
      set(
        context,
        {
          timeout: null,
          runner: null,
          promise,
          resolve,
          reject
        },
        true
      );
    }
    get(context).runner = async () => {
      if (!get(context)) return;
      const ctx = get(context);
      set(context, null);
      try {
        ctx.resolve(await callback.apply(this, args));
      } catch (error) {
        ctx.reject(error);
      }
    };
    get(context).timeout = setTimeout(get(context).runner, strict_equals(typeof wait, "function") ? wait() : wait);
    return get(context).promise;
  }
  debounced.cancel = async () => {
    if (!get(context) || strict_equals(get(context).timeout, null)) {
      await new Promise((resolve) => setTimeout(resolve, 0));
      if (!get(context) || strict_equals(get(context).timeout, null)) return;
    }
    clearTimeout(get(context).timeout);
    get(context).reject("Cancelled");
    set(context, null);
  };
  debounced.runScheduledNow = async () => {
    var _a, _b;
    if (!get(context) || !get(context).timeout) {
      await new Promise((resolve) => setTimeout(resolve, 0));
      if (!get(context) || !get(context).timeout) return;
    }
    clearTimeout(get(context).timeout);
    get(context).timeout = null;
    await ((_b = (_a = get(context)).runner) == null ? void 0 : _b.call(_a));
  };
  Object.defineProperty(debounced, "pending", {
    enumerable: true,
    get() {
      var _a;
      return !!((_a = get(context)) == null ? void 0 : _a.timeout);
    }
  });
  return debounced;
}

// node_modules/.pnpm/runed@0.23.4_svelte@5.25.6/node_modules/runed/dist/utilities/watch/watch.svelte.js
function runEffect(flush, effect) {
  switch (flush) {
    case "post":
      user_effect(effect);
      break;
    case "pre":
      user_pre_effect(effect);
      break;
  }
}
function runWatcher(sources, flush, effect, options = {}) {
  const { lazy = false } = options;
  let active = !lazy;
  let previousValues = Array.isArray(sources) ? [] : void 0;
  runEffect(flush, () => {
    const values = Array.isArray(sources) ? sources.map((source) => source()) : sources();
    if (!active) {
      active = true;
      previousValues = values;
      return;
    }
    const cleanup = untrack(() => effect(values, previousValues));
    previousValues = values;
    return cleanup;
  });
}
function runWatcherOnce(sources, flush, effect) {
  const cleanupRoot = effect_root(() => {
    let stop = false;
    runWatcher(
      sources,
      flush,
      (values, previousValues) => {
        if (stop) {
          cleanupRoot();
          return;
        }
        const cleanup = effect(values, previousValues);
        stop = true;
        return cleanup;
      },
      // Running the effect immediately just once makes no sense at all.
      // That's just `onMount` with extra steps.
      { lazy: true }
    );
  });
  user_effect(() => {
    return cleanupRoot;
  });
}
function watch(sources, effect, options) {
  runWatcher(sources, "post", effect, options);
}
function watchPre(sources, effect, options) {
  runWatcher(sources, "pre", effect, options);
}
watch.pre = watchPre;
function watchOnce(source, effect) {
  runWatcherOnce(source, "post", effect);
}
function watchOncePre(source, effect) {
  runWatcherOnce(source, "pre", effect);
}
watchOnce.pre = watchOncePre;

// node_modules/.pnpm/runed@0.23.4_svelte@5.25.6/node_modules/runed/dist/internal/utils/get.js
function get2(value) {
  if (isFunction2(value)) {
    return value();
  }
  return value;
}

// node_modules/.pnpm/runed@0.23.4_svelte@5.25.6/node_modules/runed/dist/utilities/use-event-listener/use-event-listener.svelte.js
function useEventListener(_target, _events, handler, options) {
  user_effect(() => {
    const target = extract2(_target);
    const events = extract2(_events);
    if (strict_equals(target, void 0) || strict_equals(target, null)) return;
    if (Array.isArray(events)) {
      for (const event of events) {
        user_effect(() => on(target, event, handler, options));
      }
    } else {
      return on(target, events, handler, options);
    }
  });
}

// node_modules/.pnpm/runed@0.23.4_svelte@5.25.6/node_modules/runed/dist/utilities/state-history/state-history.svelte.js
var _redoStack, _ignoreUpdate, _set, _log, _canUndo, _canRedo;
var StateHistory = class {
  constructor(value, set2, options) {
    __privateAdd(this, _redoStack, state(proxy([])));
    __privateAdd(this, _ignoreUpdate, false);
    __privateAdd(this, _set);
    __privateAdd(this, _log, state(proxy([])));
    __privateAdd(this, _canUndo, user_derived(() => this.log.length > 1));
    __privateAdd(this, _canRedo, user_derived(() => get(__privateGet(this, _redoStack)).length > 0));
    set(__privateGet(this, _redoStack), [], true);
    __privateSet(this, _set, set2);
    this.undo = this.undo.bind(this);
    this.redo = this.redo.bind(this);
    const addEvent = (event) => {
      this.log.push(event);
      const capacity$ = get2(options == null ? void 0 : options.capacity);
      if (capacity$ && this.log.length > capacity$) {
        this.log = this.log.slice(-capacity$);
      }
    };
    watch(() => get2(value), (v) => {
      if (__privateGet(this, _ignoreUpdate)) {
        __privateSet(this, _ignoreUpdate, false);
        return;
      }
      addEvent({
        snapshot: v,
        timestamp: (/* @__PURE__ */ new Date()).getTime()
      });
      set(__privateGet(this, _redoStack), [], true);
    });
    watch(() => get2(options == null ? void 0 : options.capacity), (c) => {
      if (!c) return;
      this.log = this.log.slice(-c);
    });
  }
  get log() {
    return get(__privateGet(this, _log));
  }
  set log(value) {
    set(__privateGet(this, _log), value, true);
  }
  get canUndo() {
    return get(__privateGet(this, _canUndo));
  }
  set canUndo(value) {
    set(__privateGet(this, _canUndo), value);
  }
  get canRedo() {
    return get(__privateGet(this, _canRedo));
  }
  set canRedo(value) {
    set(__privateGet(this, _canRedo), value);
  }
  undo() {
    const [prev, curr] = this.log.slice(-2);
    if (!curr || !prev) return;
    __privateSet(this, _ignoreUpdate, true);
    get(__privateGet(this, _redoStack)).push(curr);
    this.log.pop();
    __privateGet(this, _set).call(this, prev.snapshot);
  }
  redo() {
    const nextEvent = get(__privateGet(this, _redoStack)).pop();
    if (!nextEvent) return;
    __privateSet(this, _ignoreUpdate, true);
    this.log.push(nextEvent);
    __privateGet(this, _set).call(this, nextEvent.snapshot);
  }
  [ADD_OWNER](owner) {
    add_owner_to_class(this, owner, [
      () => get(__privateGet(this, _log)),
      () => get(__privateGet(this, _canUndo)),
      () => get(__privateGet(this, _canRedo))
    ]);
  }
};
_redoStack = new WeakMap();
_ignoreUpdate = new WeakMap();
_set = new WeakMap();
_log = new WeakMap();
_canUndo = new WeakMap();
_canRedo = new WeakMap();

// node_modules/.pnpm/runed@0.23.4_svelte@5.25.6/node_modules/runed/dist/utilities/is-focus-within/is-focus-within.svelte.js
var _node, _activeElement, _current;
var IsFocusWithin = class {
  constructor(node, options = {}) {
    __privateAdd(this, _node);
    __privateAdd(this, _activeElement);
    __privateAdd(this, _current, user_derived(() => {
      const node = extract2(__privateGet(this, _node));
      if (equals(node, null)) return false;
      return node.contains(__privateGet(this, _activeElement).current);
    }));
    __privateSet(this, _node, node);
    __privateSet(this, _activeElement, new ActiveElement(options));
  }
  get current() {
    return get(__privateGet(this, _current));
  }
  set current(value) {
    set(__privateGet(this, _current), value);
  }
  [ADD_OWNER](owner) {
    add_owner_to_class(this, owner, [() => get(__privateGet(this, _current))]);
  }
};
_node = new WeakMap();
_activeElement = new WeakMap();
_current = new WeakMap();

// node_modules/.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/selection-state.svelte.js
function toSet(v) {
  if (strict_equals(v, void 0)) return new SvelteSet();
  if (isSvelteSet(v)) return v;
  if (!isIterable(v)) return new SvelteSet([v]);
  return new SvelteSet(v);
}
function toSingle(v) {
  if (!isIterable(v) || strict_equals(v, void 0)) return v;
  return last(v);
}
var _props, _internal_set, _isControlled, _isMultiple;
var SelectionState = class {
  constructor(props) {
    __privateAdd(this, _props);
    __privateAdd(this, _internal_set, new SvelteSet());
    __privateAdd(this, _isControlled, user_derived(() => isSvelteSet(__privateGet(this, _props).value) || isFunction(__privateGet(this, _props).value)));
    __privateAdd(this, _isMultiple, user_derived(() => extract(__privateGet(this, _props).multiple, false)));
    __privateSet(this, _props, props);
    if (this.isControlled) return;
    if (!isIterable(props.value) && strict_equals(props.value, void 0, false)) {
      __privateGet(this, _internal_set).add(props.value);
    } else if (isIterable(props.value)) {
      forEach(props.value, (v) => __privateGet(this, _internal_set).add(v));
    }
    watch(
      () => this.isMultiple,
      (isMultiple) => {
        if (isMultiple) return;
        const curr = this.current;
        __privateGet(this, _internal_set).clear();
        if (strict_equals(curr, void 0)) return;
        __privateGet(this, _internal_set).add(curr);
      },
      { lazy: true }
    );
  }
  get isControlled() {
    return get(__privateGet(this, _isControlled));
  }
  set isControlled(value) {
    set(__privateGet(this, _isControlled), value);
  }
  get isMultiple() {
    return get(__privateGet(this, _isMultiple));
  }
  set isMultiple(value) {
    set(__privateGet(this, _isMultiple), value);
  }
  /**
   * Gets the current selection value(s)
   * @returns For multiple selection, returns a SvelteSet of values. For single selection, returns a single value or undefined.
   */
  get current() {
    let value;
    if (isFunction(__privateGet(this, _props).value)) {
      value = __privateGet(this, _props).value();
    } else if (isSvelteSet(__privateGet(this, _props).value)) {
      value = __privateGet(this, _props).value;
    } else {
      value = __privateGet(this, _internal_set);
    }
    if (this.isMultiple) {
      return toSet(value);
    }
    return toSingle(value);
  }
  /**
   * Sets the current selection value(s)
   * @param value - The new selection value(s)
   */
  set current(value) {
    this.onChange(value);
    if (this.isControlled) return;
    __privateGet(this, _internal_set).clear();
    if (isSvelteSet(value)) {
      value.forEach((v) => __privateGet(this, _internal_set).add(v));
    } else if (strict_equals(value, void 0, false)) {
      __privateGet(this, _internal_set).add(value);
    }
  }
  /**
   * Manipulates the selection set through a callback
   * @param cb - Callback function that receives the selection set for manipulation
   * @internal
   */
  manipulate(cb) {
    const set2 = this.isControlled ? toSet(this.current) : __privateGet(this, _internal_set);
    cb(set2);
    const newValue = this.isMultiple ? set2 : toSingle(set2);
    this.onChange(newValue);
  }
  /**
   * Triggers the onChange callback with the current selection
   * @param value - The current selection value(s)
   * @internal
   */
  onChange(value) {
    if (!__privateGet(this, _props).onChange) return;
    __privateGet(this, _props).onChange(value);
  }
  /**
   * Checks if an item is currently selected
   * @param item - The item to check
   * @returns True if the item is selected, false otherwise
   */
  has(item) {
    return toSet(this.current).has(item);
  }
  /**
   * Adds an item to the selection
   * For single selection, this replaces the current selection
   * For multiple selection, this adds to the current selection
   * @param value - The item to add
   */
  add(value) {
    this.manipulate((set2) => {
      if (!this.isMultiple) {
        set2.clear();
      }
      set2.add(value);
    });
  }
  /**
   * Adds multiple items to the selection
   * For single selection, only the first item is selected
   * For multiple selection, all items are added to the selection
   * @param items - The items to add
   */
  addAll(items) {
    this.manipulate((set2) => {
      if (!this.isMultiple) {
        set2.clear();
        set2.add(first(items));
      } else {
        forEach(items, (i) => set2.add(i));
      }
    });
  }
  /**
   * Removes an item from the selection
   * @param value - The item to remove
   */
  delete(value) {
    this.manipulate((set2) => {
      set2.delete(value);
    });
  }
  /**
   * Removes multiple items from the selection
   * @param items - The items to remove
   */
  deleteAll(items) {
    this.manipulate((set2) => forEach(items, set2.delete));
  }
  /**
   * Clears all selections
   */
  clear() {
    this.manipulate((set2) => set2.clear());
  }
  /**
   * Gets the number of selected items
   * @returns The number of selected items
   */
  size() {
    return toSet(this.current).size;
  }
  /**
   * Toggles the selection state of an item
   * If the item is selected, it will be deselected
   * If the item is not selected, it will be selected
   * @param item - The item to toggle
   */
  toggle(item) {
    this.manipulate((set2) => {
      if (set2.has(item)) {
        set2.delete(item);
      } else {
        if (!this.isMultiple) set2.clear();
        set2.add(item);
      }
    });
  }
  /**
   * Converts the current selection to a SvelteSet
   * @returns A SvelteSet containing the current selection
   */
  toSet() {
    return toSet(this.current);
  }
  /**
   * Converts the current selection to an array
   * @returns An array containing the current selection
   */
  toArray() {
    return Array.from(this.toSet());
  }
  [ADD_OWNER](owner) {
    add_owner_to_class(this, owner, [
      () => get(__privateGet(this, _isControlled)),
      () => get(__privateGet(this, _isMultiple))
    ]);
  }
};
_props = new WeakMap();
_internal_set = new WeakMap();
_isControlled = new WeakMap();
_isMultiple = new WeakMap();

// node_modules/.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/keyboard.js
var kbd = {
  ALT: "Alt",
  ARROW_DOWN: "ArrowDown",
  ARROW_LEFT: "ArrowLeft",
  ARROW_RIGHT: "ArrowRight",
  ARROW_UP: "ArrowUp",
  BACKSPACE: "Backspace",
  CAPS_LOCK: "CapsLock",
  CONTROL: "Control",
  DELETE: "Delete",
  END: "End",
  ENTER: "Enter",
  ESCAPE: "Escape",
  F1: "F1",
  F10: "F10",
  F11: "F11",
  F12: "F12",
  F2: "F2",
  F3: "F3",
  F4: "F4",
  F5: "F5",
  F6: "F6",
  F7: "F7",
  F8: "F8",
  F9: "F9",
  HOME: "Home",
  META: "Meta",
  PAGE_DOWN: "PageDown",
  PAGE_UP: "PageUp",
  SHIFT: "Shift",
  SPACE: " ",
  TAB: "Tab",
  CTRL: "Control",
  ASTERISK: "*",
  A: "a",
  P: "p"
};
var FIRST_KEYS = [kbd.ARROW_DOWN, kbd.PAGE_UP, kbd.HOME];
var LAST_KEYS = [kbd.ARROW_UP, kbd.PAGE_DOWN, kbd.END];
var FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];
var SELECTION_KEYS = [kbd.ENTER, kbd.SPACE];
var getNextKey = (dir = "ltr", orientation = "horizontal") => {
  return {
    horizontal: dir === "rtl" ? kbd.ARROW_LEFT : kbd.ARROW_RIGHT,
    vertical: kbd.ARROW_DOWN
  }[orientation];
};
var getPrevKey = (dir = "ltr", orientation = "horizontal") => {
  return {
    horizontal: dir === "rtl" ? kbd.ARROW_RIGHT : kbd.ARROW_LEFT,
    vertical: kbd.ARROW_UP
  }[orientation];
};
var getDirectionalKeys = (dir = "ltr", orientation = "horizontal") => {
  return {
    nextKey: getNextKey(dir, orientation),
    prevKey: getPrevKey(dir, orientation)
  };
};

// node_modules/.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/attribute.js
function dataAttr(value) {
  return value === true ? "" : value === false ? void 0 : value;
}
function disabledAttr(value) {
  return value === true ? true : void 0;
}
function styleAttr(value) {
  return Object.entries(value).map(([key, value2]) => `${key}: ${value2};`).join(" ");
}

// node_modules/.pnpm/nanoid@5.1.5/node_modules/nanoid/url-alphabet/index.js
var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";

// node_modules/.pnpm/nanoid@5.1.5/node_modules/nanoid/index.browser.js
var nanoid = (size3 = 21) => {
  let id = "";
  let bytes = crypto.getRandomValues(new Uint8Array(size3 |= 0));
  while (size3--) {
    id += urlAlphabet[bytes[size3] & 63];
  }
  return id;
};

// node_modules/.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/object.js
function keys(obj) {
  return Object.keys(obj);
}
function pick(obj, ...keys2) {
  const result = {};
  for (const key of keys2) {
    result[key] = obj[key];
  }
  return result;
}

// node_modules/.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/identifiers.js
function createDataIds(name, parts) {
  return parts.reduce((acc, part) => {
    acc[part] = `data-melt-${name}-${part}`;
    return acc;
  }, {});
}
function createIds(identifiers6) {
  const id = nanoid();
  return Object.keys(identifiers6).reduce((acc, key) => {
    acc[key] = `${key}-${id}`;
    return acc;
  }, {});
}
function createBuilderMetadata(name, parts) {
  const dataAttrs9 = createDataIds(name, parts);
  const dataSelectors6 = keys(dataAttrs9).reduce((acc, key) => {
    acc[key] = `[${dataAttrs9[key]}]`;
    return acc;
  }, {});
  return {
    dataAttrs: dataAttrs9,
    dataSelectors: dataSelectors6,
    createIds: () => createIds(dataAttrs9)
  };
}

// node_modules/.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/builders/Accordion.svelte.js
var { dataAttrs, dataSelectors, createIds: createIds2 } = createBuilderMetadata("accordion", [
  "root",
  "item",
  "trigger",
  "heading",
  "content"
]);
var _props2, _multiple, _disabled, _value, _ids;
var Accordion = class {
  constructor(props = {}) {
    // Props
    __privateAdd(this, _props2);
    __privateAdd(this, _multiple, user_derived(() => extract(__privateGet(this, _props2).multiple, false)));
    __privateAdd(this, _disabled, user_derived(() => extract(__privateGet(this, _props2).disabled, false)));
    // State
    __privateAdd(this, _value);
    __privateAdd(this, _ids, createIds2());
    __privateSet(this, _props2, props);
    __privateSet(this, _value, new SelectionState({
      value: props.value,
      onChange: props.onValueChange,
      multiple: props.multiple
    }));
  }
  get multiple() {
    return get(__privateGet(this, _multiple));
  }
  set multiple(value) {
    set(__privateGet(this, _multiple), value);
  }
  get disabled() {
    return get(__privateGet(this, _disabled));
  }
  set disabled(value) {
    set(__privateGet(this, _disabled), value);
  }
  get value() {
    return __privateGet(this, _value).current;
  }
  set value(value) {
    __privateGet(this, _value).current = value;
  }
  /**
   * Spread attributes for the accordion root element.
   */
  get root() {
    return { [dataAttrs.root]: "", id: __privateGet(this, _ids).root };
  }
  /**
   * Returns an Item class with the necessary
   * spread attributes for an accordion item.
   * @param item
   */
  getItem(item) {
    return new Item({
      accordion: this,
      item,
      rootId: __privateGet(this, _ids).root
    });
  }
  /**
   * Checks if an item is currently expanded.
   * @param id - ID of the item to check.
   */
  isExpanded(id) {
    return __privateGet(this, _value).has(id);
  }
  /**
   * Expands a specific item.
   * @param id - ID of the item to expand.
   */
  expand(id) {
    __privateGet(this, _value).add(id);
  }
  /**
   * Collapses a specific item.
   * @param id - ID of the item to collapse.
   */
  collapse(id) {
    __privateGet(this, _value).delete(id);
  }
  /**
   * Toggles the expanded state of an item.
   * @param id - ID of the item to toggle.
   */
  toggleExpanded(id) {
    if (__privateGet(this, _value).has(id)) {
      this.collapse(id);
    } else {
      if (this.multiple) {
        this.expand(id);
      } else {
        __privateGet(this, _value).clear();
        this.expand(id);
      }
    }
  }
  [ADD_OWNER](owner) {
    add_owner_to_class(this, owner, [
      () => get(__privateGet(this, _multiple)),
      () => get(__privateGet(this, _disabled))
    ]);
  }
};
_props2 = new WeakMap();
_multiple = new WeakMap();
_disabled = new WeakMap();
_value = new WeakMap();
_ids = new WeakMap();
var _props3, _item, _accordion, _rootId, _isDisabled, _isExpanded;
var Item = class {
  constructor(props) {
    __privateAdd(this, _props3);
    __privateAdd(this, _item, user_derived(() => __privateGet(this, _props3).item));
    __privateAdd(this, _accordion, user_derived(() => __privateGet(this, _props3).accordion));
    __privateAdd(this, _rootId, user_derived(() => __privateGet(this, _props3).rootId));
    __privateAdd(this, _isDisabled, user_derived(() => get(__privateGet(this, _accordion)).disabled || this.item.disabled));
    __privateAdd(this, _isExpanded, user_derived(() => get(__privateGet(this, _accordion)).isExpanded(this.item.id)));
    /** Expands this item. */
    __publicField(this, "expand", () => get(__privateGet(this, _accordion)).expand(this.item.id));
    /** Collapses this item. */
    __publicField(this, "collapse", () => get(__privateGet(this, _accordion)).collapse(this.item.id));
    /** Toggles the expanded state of this item. */
    __publicField(this, "toggleExpanded", () => get(__privateGet(this, _accordion)).toggleExpanded(this.item.id));
    __privateSet(this, _props3, props);
  }
  get item() {
    return get(__privateGet(this, _item));
  }
  set item(value) {
    set(__privateGet(this, _item), value);
  }
  get isDisabled() {
    return get(__privateGet(this, _isDisabled));
  }
  set isDisabled(value) {
    set(__privateGet(this, _isDisabled), value);
  }
  get isExpanded() {
    return get(__privateGet(this, _isExpanded));
  }
  set isExpanded(value) {
    set(__privateGet(this, _isExpanded), value);
  }
  /**
   * Attributes for an accordion heading element.
   */
  get heading() {
    return {
      [dataAttrs.heading]: "",
      role: "heading",
      "aria-level": this.item.headingLevel,
      "data-heading-level": this.item.headingLevel
    };
  }
  /**
   * Attributes for an accordion item trigger.
   */
  get trigger() {
    return {
      [dataAttrs.trigger]: "",
      disabled: disabledAttr(this.isDisabled),
      "aria-disabled": this.isDisabled,
      "aria-expanded": this.isExpanded,
      "data-disabled": dataAttr(this.isDisabled),
      "data-value": this.item.id,
      "data-state": this.isExpanded ? "open" : "closed",
      onclick: () => this.toggleExpanded(),
      onkeydown: (e) => {
        var _a, _b, _c, _d;
        const key = e.key;
        if (![
          kbd.ARROW_DOWN,
          kbd.ARROW_UP,
          kbd.HOME,
          kbd.END
        ].includes(key)) {
          return;
        }
        e.preventDefault();
        if (strict_equals(key, kbd.SPACE) || strict_equals(key, kbd.ENTER)) {
          if (this.isDisabled) return;
          this.toggleExpanded();
        }
        const el = e.target;
        const rootEl = document.getElementById(get(__privateGet(this, _rootId)));
        if (!rootEl || !isHtmlElement(el)) return;
        const items = Array.from(rootEl.querySelectorAll(dataSelectors.trigger));
        const candidateItems = items.filter((item) => {
          if (!isHtmlElement(item)) return false;
          return !("disabled" in item.dataset);
        });
        if (!candidateItems.length) return;
        const elIdx = candidateItems.indexOf(el);
        if (strict_equals(e.key, kbd.ARROW_DOWN)) {
          (_a = candidateItems[(elIdx + 1) % candidateItems.length]) == null ? void 0 : _a.focus();
        }
        if (strict_equals(e.key, kbd.ARROW_UP)) {
          (_b = candidateItems[(elIdx - 1 + candidateItems.length) % candidateItems.length]) == null ? void 0 : _b.focus();
        }
        if (strict_equals(e.key, kbd.HOME)) {
          (_c = candidateItems[0]) == null ? void 0 : _c.focus();
        }
        if (strict_equals(e.key, kbd.END)) {
          (_d = candidateItems[candidateItems.length - 1]) == null ? void 0 : _d.focus();
        }
      }
    };
  }
  /**
   * Attributes for an accordion content element.
   */
  get content() {
    return {
      [dataAttrs.content]: "",
      "data-state": this.isExpanded ? "open" : "closed",
      "data-disabled": disabledAttr(this.isDisabled),
      "data-value": this.item.id
    };
  }
  [ADD_OWNER](owner) {
    add_owner_to_class(this, owner, [
      () => get(__privateGet(this, _item)),
      () => get(__privateGet(this, _isDisabled)),
      () => get(__privateGet(this, _isExpanded))
    ]);
  }
};
_props3 = new WeakMap();
_item = new WeakMap();
_accordion = new WeakMap();
_rootId = new WeakMap();
_isDisabled = new WeakMap();
_isExpanded = new WeakMap();

// node_modules/.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/browser.js
function inBrowser() {
  return typeof window !== "undefined";
}

// node_modules/.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/builders/Avatar.svelte.js
var identifiers = createDataIds("avatar", ["image", "fallback"]);
var _props4, _src, _delayMs, _loadingStatus;
var Avatar = class {
  constructor(props = {}) {
    /* Props */
    __privateAdd(this, _props4);
    __privateAdd(this, _src, user_derived(() => extract(__privateGet(this, _props4).src, "")));
    __privateAdd(this, _delayMs, user_derived(() => extract(__privateGet(this, _props4).delayMs, 0)));
    __privateAdd(this, _loadingStatus, state("loading"));
    user_effect(() => {
      var _a, _b;
      (_b = (_a = __privateGet(this, _props4)).onLoadingStatusChange) == null ? void 0 : _b.call(_a, get(__privateGet(this, _loadingStatus)));
    });
    watch(() => this.src, () => {
      set(__privateGet(this, _loadingStatus), "loading");
    });
    __privateSet(this, _props4, props);
  }
  get src() {
    return get(__privateGet(this, _src));
  }
  set src(value) {
    set(__privateGet(this, _src), value);
  }
  get delayMs() {
    return get(__privateGet(this, _delayMs));
  }
  set delayMs(value) {
    set(__privateGet(this, _delayMs), value);
  }
  get loadingStatus() {
    return get(__privateGet(this, _loadingStatus));
  }
  get image() {
    return {
      [identifiers.image]: "",
      src: this.src,
      style: styleAttr({
        display: strict_equals(get(__privateGet(this, _loadingStatus)), "loaded") ? "block" : "none"
      }),
      onload: () => {
        if (!inBrowser()) return;
        const timerId = window.setTimeout(
          () => {
            set(__privateGet(this, _loadingStatus), "loaded");
          },
          this.delayMs
        );
        return () => window.clearTimeout(timerId);
      },
      onerror: () => {
        set(__privateGet(this, _loadingStatus), "error");
      }
    };
  }
  get fallback() {
    return {
      [identifiers.fallback]: "",
      style: strict_equals(get(__privateGet(this, _loadingStatus)), "loaded") ? styleAttr({ display: "none" }) : void 0,
      hidden: strict_equals(get(__privateGet(this, _loadingStatus)), "loaded") ? true : void 0
    };
  }
  [ADD_OWNER](owner) {
    add_owner_to_class(this, owner, [
      () => get(__privateGet(this, _src)),
      () => get(__privateGet(this, _delayMs))
    ]);
  }
};
_props4 = new WeakMap();
_src = new WeakMap();
_delayMs = new WeakMap();
_loadingStatus = new WeakMap();

// node_modules/.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/Synced.svelte.js
var _internalValue, _valueArg, _onChange, _defaultValue;
var Synced = class {
  constructor({ value, onChange, ...args }) {
    __privateAdd(this, _internalValue, state());
    __privateAdd(this, _valueArg);
    __privateAdd(this, _onChange);
    __privateAdd(this, _defaultValue);
    __privateSet(this, _valueArg, value);
    __privateSet(this, _onChange, onChange);
    __privateSet(this, _defaultValue, "defaultValue" in args ? args == null ? void 0 : args.defaultValue : void 0);
    set(__privateGet(this, _internalValue), extract(value, __privateGet(this, _defaultValue)), true);
  }
  get current() {
    return isFunction(__privateGet(this, _valueArg)) ? __privateGet(this, _valueArg).call(this) ?? __privateGet(this, _defaultValue) ?? get(__privateGet(this, _internalValue)) : get(__privateGet(this, _internalValue));
  }
  set current(value) {
    var _a, _b;
    if (strict_equals(this.current, value)) return;
    if (isFunction(__privateGet(this, _valueArg))) {
      (_a = __privateGet(this, _onChange)) == null ? void 0 : _a.call(this, value);
      return;
    }
    set(__privateGet(this, _internalValue), value, true);
    (_b = __privateGet(this, _onChange)) == null ? void 0 : _b.call(this, value);
  }
};
_internalValue = new WeakMap();
_valueArg = new WeakMap();
_onChange = new WeakMap();
_defaultValue = new WeakMap();

// node_modules/.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/builders/Collapsible.svelte.js
var { dataAttrs: dataAttrs2, createIds: createIds3 } = createBuilderMetadata("collapsible", ["trigger", "content"]);
var _props5, _disabled2, _open, _ids2, _Collapsible_instances, sharedAttrs_get;
var Collapsible = class {
  constructor(props = {}) {
    __privateAdd(this, _Collapsible_instances);
    // Props
    __privateAdd(this, _props5);
    __privateAdd(this, _disabled2, user_derived(() => extract(__privateGet(this, _props5).disabled, false)));
    // State
    __privateAdd(this, _open);
    __privateAdd(this, _ids2, createIds3());
    __privateSet(this, _props5, props);
    __privateSet(this, _open, new Synced({
      value: props.open,
      onChange: props.onOpenChange,
      defaultValue: false
    }));
  }
  get disabled() {
    return get(__privateGet(this, _disabled2));
  }
  set disabled(value) {
    set(__privateGet(this, _disabled2), value);
  }
  /**
   * The open state of the collapsible.
   */
  get open() {
    return __privateGet(this, _open).current;
  }
  set open(open) {
    __privateGet(this, _open).current = open;
  }
  /**
   * The spread attributes for the trigger button.
   */
  get trigger() {
    return {
      [dataAttrs2.trigger]: "",
      id: __privateGet(this, _ids2).trigger,
      "aria-expanded": this.open,
      "aria-controls": __privateGet(this, _ids2).content,
      ...__privateGet(this, _Collapsible_instances, sharedAttrs_get),
      disabled: this.disabled,
      onclick: () => {
        if (this.disabled) return;
        __privateGet(this, _open).current = !__privateGet(this, _open).current;
      }
    };
  }
  /**
   * The spread attributes for the content element.
   */
  get content() {
    return {
      [dataAttrs2.content]: "",
      id: __privateGet(this, _ids2).content,
      ...__privateGet(this, _Collapsible_instances, sharedAttrs_get)
    };
  }
  [ADD_OWNER](owner) {
    add_owner_to_class(this, owner, [() => get(__privateGet(this, _disabled2))]);
  }
};
_props5 = new WeakMap();
_disabled2 = new WeakMap();
_open = new WeakMap();
_ids2 = new WeakMap();
_Collapsible_instances = new WeakSet();
sharedAttrs_get = function() {
  return {
    "data-state": this.open ? "open" : "closed",
    "data-disabled": dataAttr(this.disabled)
  };
};

// node_modules/.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/typeahead.svelte.js
var letterRegex = /^[a-zA-Z]$/;
function createTypeahead(args) {
  let value = state("");
  const timeout = user_derived(() => extract(args.timeout, 500));
  const debounceClear = useDebounce(
    () => {
      set(value, "");
    },
    () => get(timeout)
  );
  function typeahead(letter) {
    if (!letterRegex.test(letter)) return;
    debounceClear();
    set(value, get(value) + letter.toLowerCase());
    const isStartingTypeahead = strict_equals(get(value).length, 1);
    const items = args.getItems();
    const index = items.findIndex((item) => item.current);
    const itemsForTypeahead = items.filter((item) => {
      const searchValue = item.typeahead ?? item.value;
      return searchValue.toLowerCase().startsWith(get(value));
    }).map((item) => ({ item, index: items.indexOf(item) }));
    if (!itemsForTypeahead.length) return;
    const next = itemsForTypeahead.find((item) => {
      if (isStartingTypeahead) return item.index > index;
      return item.index >= index;
    }) ?? itemsForTypeahead[0];
    return next == null ? void 0 : next.item;
  }
  return typeahead;
}

// node_modules/.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/event.js
function addEventListener(target, event, handler, options) {
  const events = Array.isArray(event) ? event : [event];
  for (const event2 of events) {
    target.addEventListener(event2, handler, options);
  }
  return () => {
    for (const event2 of events) {
      target.removeEventListener(event2, handler, options);
    }
  };
}

// node_modules/.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/merge.js
function isPlainObject(value) {
  return value !== null && typeof value === "object" && Object.getPrototypeOf(value) === Object.prototype;
}
function deepMerge(target, source) {
  const result = { ...target };
  for (const key in source) {
    if (Object.prototype.hasOwnProperty.call(source, key)) {
      const sourceValue = source[key];
      const targetValue = result[key];
      if (Array.isArray(sourceValue)) {
        result[key] = Array.isArray(targetValue) ? [...targetValue, ...sourceValue] : [...sourceValue];
        continue;
      }
      if (isPlainObject(sourceValue)) {
        result[key] = Object.prototype.hasOwnProperty.call(result, key) && isPlainObject(result[key]) ? deepMerge(result[key], sourceValue) : deepMerge({}, sourceValue);
        continue;
      }
      result[key] = sourceValue;
    }
  }
  return result;
}

// node_modules/.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/popover.js
function safelyHidePopover(el) {
  try {
    el.hidePopover();
  } catch {
  }
}
function safelyShowPopover(el) {
  try {
    el.showPopover();
  } catch {
  }
}

// node_modules/.pnpm/@floating-ui+utils@0.2.9/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}

// node_modules/.pnpm/@floating-ui+core@1.6.9/node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state2, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state2;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state2);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state2) {
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state2;
    const {
      element,
      padding = 0
    } = evaluate(options, state2) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset3 = clamp(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset3 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset3,
        centerOffset: center - offset3 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state2) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state2;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state2);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state2, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
async function convertValueToCoords(state2, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state2;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state2);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state2) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state2;
      const diffCoords = await convertValueToCoords(state2, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state2) {
      const {
        x,
        y,
        placement
      } = state2;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state2);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state2, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state2,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state2) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state2;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state2);
      const overflow = await detectOverflow(state2, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state2.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state2.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state2.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state2,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// node_modules/.pnpm/@floating-ui+utils@0.2.9/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode2(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode2(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode2(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement2(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement2(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement2(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// node_modules/.pnpm/@floating-ui+dom@1.6.13/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement2(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
var noOffsets = createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement2(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement2(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  ));
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement2(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement2(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement2(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement2(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement2(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement: isElement2,
  isRTL
};
function rectsAreEqual(a, b) {
  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var shift2 = shift;
var flip2 = flip;
var size2 = size;
var arrow2 = arrow;
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/use-floating.svelte.js
var ARROW_TRANSFORM = {
  bottom: "rotate(45deg)",
  left: "rotate(135deg)",
  top: "rotate(225deg)",
  right: "rotate(315deg)"
};
function useFloating(args) {
  const nodeEl = user_derived(() => extract(args.node));
  const floatingEl = user_derived(() => extract(args.floating));
  const config = user_derived(() => extract(args.config, {}));
  let data = state(void 0);
  const compute = () => {
    const arrowEl = get(floatingEl).querySelector("[data-arrow]");
    const arrowOffset = isHtmlElement(arrowEl) ? arrowEl.offsetHeight / 2 : 0;
    const arrowMiddleware = isHtmlElement(arrowEl) ? arrow2({ element: arrowEl, ...get(config).arrow }) : void 0;
    const baseOptions = {
      middleware: [
        shift2(get(config).shift),
        flip2(get(config).flip),
        arrowMiddleware,
        offset2(strict_equals(typeof get(config).offset, "number") ? get(config).offset : {
          mainAxis: 8 + arrowOffset,
          ...get(config).offset
        }),
        get(config).sameWidth ? size2({
          apply({ rects, elements }) {
            var _a;
            Object.assign(((_a = elements.floating) == null ? void 0 : _a.style) ?? {}, {
              width: `${rects.reference.width}px`,
              minWidth: `${rects.reference.width}px`
            });
          }
        }) : void 0
      ]
    };
    computePosition2(get(nodeEl), get(floatingEl), deepMerge(baseOptions, get(config).computePosition ?? {})).then((returned) => {
      set(data, returned, true);
      const { x, y, placement, middlewareData, strategy } = returned;
      const floatingApply = (el = get(floatingEl)) => {
        const transformOriginMap = {
          top: "bottom center",
          "top-start": "bottom left",
          "top-end": "bottom right",
          bottom: "top center",
          "bottom-start": "top left",
          "bottom-end": "top right",
          left: "center center",
          "left-start": "top left",
          "left-end": "bottom left",
          right: "center center",
          "right-start": "top right",
          "right-end": "bottom right"
        };
        Object.assign(el.style, {
          position: strategy,
          left: `${x}px`,
          top: `${y}px`
        });
        const [side, align = "center"] = placement.split("-");
        el.style.transformOrigin = transformOriginMap[placement];
        el.dataset.side = side;
        el.dataset.align = align;
      };
      const arrowApply = (el = void 0) => {
        const actualEl = el ?? arrowEl;
        if (!isHtmlElement(actualEl) || !middlewareData.arrow) return;
        const { x: x2, y: y2 } = middlewareData.arrow;
        const dir = placement.split("-")[0];
        Object.assign(actualEl.style, {
          position: "absolute",
          left: x2 ? `${x2}px` : "",
          top: y2 ? `${y2}px` : "",
          [dir]: `calc(100% - ${arrowOffset}px)`,
          transform: ARROW_TRANSFORM[dir],
          backgroundColor: "inherit",
          zIndex: "inherit"
        });
        actualEl.dataset.side = dir;
      };
      if (isFunction(get(config).onCompute)) {
        get(config).onCompute({ ...returned, arrowApply, floatingApply });
      } else {
        floatingApply();
        arrowApply();
      }
    });
  };
  user_effect(() => {
    return autoUpdate(get(nodeEl), get(floatingEl), compute);
  });
  return {
    get data() {
      return get(data);
    }
  };
}

// node_modules/.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/builders/Popover.svelte.js
var { dataAttrs: dataAttrs3, dataSelectors: dataSelectors2 } = createBuilderMetadata("popover", ["trigger", "content", "arrow"]);
var isCloseOnOutsideClickCheck = (value) => isFunction(value) && strict_equals(value.length, 1);
var _ids3, _props6, _forceVisible, _closeOnEscape, _sameWidth, _closeOnOutsideClick, _floatingConfig, _open2, _BasePopover_instances, shouldClose_fn;
var BasePopover = class {
  constructor(props = {}) {
    __privateAdd(this, _BasePopover_instances);
    __privateAdd(this, _ids3, state(proxy({ invoker: nanoid(), popover: nanoid() })));
    /* Props */
    __privateAdd(this, _props6);
    __privateAdd(this, _forceVisible, user_derived(() => extract(__privateGet(this, _props6).forceVisible, false)));
    __privateAdd(this, _closeOnEscape, user_derived(() => extract(__privateGet(this, _props6).closeOnEscape, true)));
    __privateAdd(this, _sameWidth, user_derived(() => extract(__privateGet(this, _props6).sameWidth, false)));
    __privateAdd(this, _closeOnOutsideClick, user_derived(() => extract(__privateGet(this, _props6).closeOnOutsideClick, true)));
    __privateAdd(this, _floatingConfig, user_derived(() => {
      const config = extract(__privateGet(this, _props6).floatingConfig, {});
      const sameWidth = extract(__privateGet(this, _props6).sameWidth);
      const merged = deepMerge(config, strict_equals(sameWidth, void 0, false) ? { sameWidth } : {});
      return merged;
    }));
    /* State */
    __privateAdd(this, _open2);
    __privateSet(this, _open2, new Synced({
      value: props.open,
      onChange: props.onOpenChange,
      defaultValue: false
    }));
    __privateSet(this, _props6, props);
  }
  get ids() {
    return get(__privateGet(this, _ids3));
  }
  set ids(value) {
    set(__privateGet(this, _ids3), value, true);
  }
  get forceVisible() {
    return get(__privateGet(this, _forceVisible));
  }
  set forceVisible(value) {
    set(__privateGet(this, _forceVisible), value);
  }
  get closeOnEscape() {
    return get(__privateGet(this, _closeOnEscape));
  }
  set closeOnEscape(value) {
    set(__privateGet(this, _closeOnEscape), value);
  }
  get sameWidth() {
    return get(__privateGet(this, _sameWidth));
  }
  set sameWidth(value) {
    set(__privateGet(this, _sameWidth), value);
  }
  get closeOnOutsideClick() {
    return get(__privateGet(this, _closeOnOutsideClick));
  }
  set closeOnOutsideClick(value) {
    set(__privateGet(this, _closeOnOutsideClick), value);
  }
  get floatingConfig() {
    return get(__privateGet(this, _floatingConfig));
  }
  set floatingConfig(value) {
    set(__privateGet(this, _floatingConfig), value);
  }
  get open() {
    return __privateGet(this, _open2).current;
  }
  set open(value) {
    __privateGet(this, _open2).current = value;
  }
  get sharedProps() {
    return {
      onfocusout: async () => {
        await new Promise((r) => setTimeout(r));
        const contentEl = document.getElementById(this.ids.popover);
        const triggerEl = document.getElementById(this.ids.invoker);
        const activeEl = document.activeElement;
        if (!activeEl || (contentEl == null ? void 0 : contentEl.contains(activeEl)) || (triggerEl == null ? void 0 : triggerEl.contains(activeEl)) || !__privateMethod(this, _BasePopover_instances, shouldClose_fn).call(this, activeEl)) {
          return;
        }
        this.open = false;
      }
    };
  }
  /** The trigger that toggles the value. */
  getInvoker() {
    return {
      id: this.ids.invoker,
      popovertarget: this.ids.popover,
      onclick: (e) => {
        e.preventDefault();
        this.open = !this.open;
      },
      ...this.sharedProps
    };
  }
  getPopover() {
    user_effect(() => {
      const el = document.getElementById(this.ids.popover);
      if (!isHtmlElement(el)) {
        return;
      }
      if (this.open || this.forceVisible) {
        const parent = isHtmlElement(el.parentNode) ? el.parentNode.closest(dataSelectors2.content) : void 0;
        if (!isHtmlElement(parent)) {
          safelyShowPopover(el);
          return;
        }
        if (strict_equals(parent.dataset.open, void 0, false)) safelyShowPopover(el);
        return addEventListener(parent, "toggle", async (e) => {
          await new Promise((r) => setTimeout(r));
          const isOpen = strict_equals(e.newState, "open");
          if (isOpen) {
            safelyShowPopover(el);
          } else {
            safelyHidePopover(el);
          }
        });
      } else {
        safelyHidePopover(el);
      }
    });
    user_effect(() => {
      const contentEl = document.getElementById(this.ids.popover);
      const triggerEl = document.getElementById(this.ids.invoker);
      if (!isHtmlElement(contentEl) || !isHtmlElement(triggerEl) || !this.open) {
        return;
      }
      useFloating({
        node: () => triggerEl,
        floating: () => contentEl,
        config: () => this.floatingConfig
      });
    });
    useEventListener(() => document, "keydown", (e) => {
      if (!this.closeOnEscape) return;
      const el = document.getElementById(this.ids.popover);
      if (strict_equals(e.key, "Escape", false) || !this.open || !isHtmlElement(el)) return;
      e.preventDefault();
      const openPopovers = [...el.querySelectorAll("[popover]")].filter((child) => {
        if (!isHtmlElement(child)) return false;
        if (child.matches(dataSelectors2.content)) return strict_equals(child.dataset.open, void 0, false);
        return child.matches(":popover-open");
      });
      if (openPopovers.length) return;
      setTimeout(() => this.open = false);
    });
    useEventListener(() => document, "click", (e) => {
      if (!this.open) return;
      const contentEl = document.getElementById(this.ids.popover);
      const triggerEl = document.getElementById(this.ids.invoker);
      if (!contentEl || !triggerEl) return;
      const target = e.target;
      const isInsideContent = contentEl.contains(target);
      const isInsideTrigger = triggerEl.contains(target);
      if (isInsideContent || isInsideTrigger) return;
      if (__privateMethod(this, _BasePopover_instances, shouldClose_fn).call(this, target)) this.open = false;
    });
    return {
      id: this.ids.popover,
      popover: "manual",
      ontoggle: (e) => {
        const newOpen = strict_equals(e.newState, "open");
        if (strict_equals(this.open, newOpen, false) && strict_equals(newOpen, false)) {
          this.open = newOpen;
        }
      },
      // Needed so it receives focus on click, but not on tab, because of focus out
      tabindex: -1,
      inert: !this.open,
      "data-open": dataAttr(this.open),
      ...this.sharedProps
    };
  }
  get arrow() {
    return {
      [dataAttrs3.arrow]: "",
      "data-arrow": "",
      "aria-hidden": true,
      "data-open": dataAttr(this.open)
    };
  }
  [ADD_OWNER](owner) {
    add_owner_to_class(this, owner, [
      () => get(__privateGet(this, _ids3)),
      () => get(__privateGet(this, _forceVisible)),
      () => get(__privateGet(this, _closeOnEscape)),
      () => get(__privateGet(this, _sameWidth)),
      () => get(__privateGet(this, _closeOnOutsideClick)),
      () => get(__privateGet(this, _floatingConfig))
    ]);
  }
};
_ids3 = new WeakMap();
_props6 = new WeakMap();
_forceVisible = new WeakMap();
_closeOnEscape = new WeakMap();
_sameWidth = new WeakMap();
_closeOnOutsideClick = new WeakMap();
_floatingConfig = new WeakMap();
_open2 = new WeakMap();
_BasePopover_instances = new WeakSet();
shouldClose_fn = function(el) {
  if (strict_equals(this.closeOnOutsideClick, false)) return false;
  if (isFunction(this.closeOnOutsideClick)) {
    return isCloseOnOutsideClickCheck(this.closeOnOutsideClick) ? this.closeOnOutsideClick(el) : this.closeOnOutsideClick();
  }
  return true;
};
var Popover = class extends BasePopover {
  constructor(props = {}) {
    super({ ...props });
    this.ids = {
      ...this.ids,
      trigger: this.ids.invoker,
      content: this.ids.popover
    };
  }
  /** The trigger that toggles the value. */
  get trigger() {
    return Object.assign(this.getInvoker(), { [dataAttrs3.trigger]: "" });
  }
  get content() {
    return Object.assign(this.getPopover(), { [dataAttrs3.content]: "" });
  }
};

// node_modules/.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/array.js
function findNext(array, condition) {
  const index = array.findIndex(condition);
  if (index === -1) {
    return void 0;
  }
  const nextIndex = (index + 1) % array.length;
  return array[nextIndex];
}
function findPrev(array, condition) {
  const index = array.findIndex(condition);
  if (index === -1) {
    return void 0;
  }
  const prevIndex = (index - 1 + array.length) % array.length;
  return array[prevIndex];
}

// node_modules/.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/effect.svelte.js
function safeEffect(cb) {
  try {
    user_effect(cb);
  } catch {
    cb();
  }
}

// node_modules/.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/builders/Combobox.svelte.js
var { dataAttrs: dataAttrs4, dataSelectors: dataSelectors3, createIds: createIds4 } = createBuilderMetadata("combobox", ["input", "trigger", "content", "option"]);
var _props7, _multiple2, _scrollAlignment, _value2, _inputValue, _highlighted, _touched;
var Combobox = class extends BasePopover {
  constructor(props = {}) {
    super({
      sameWidth: true,
      ...props,
      closeOnOutsideClick: (el) => {
        const triggerEl = document.getElementById(this.ids.trigger);
        if (triggerEl && isNode(el) && triggerEl.contains(el)) return false;
        return true;
      },
      closeOnEscape: () => this.open,
      onOpenChange: async (open) => {
        var _a;
        this.touched = false;
        (_a = props.onOpenChange) == null ? void 0 : _a.call(props, open);
        await tick();
        if (!open) {
          this.highlighted = null;
          if (!this.multiple) {
            this.inputValue = this.valueAsString ?? "";
          }
          return;
        }
        tick().then(() => {
          if (this.highlighted) return;
          const lastSelected = __privateGet(this, _value2).toArray().at(-1);
          if (lastSelected) this.highlight(lastSelected);
          else this.highlightFirst();
        });
      }
    });
    /* Props */
    __privateAdd(this, _props7);
    __privateAdd(this, _multiple2, user_derived(() => extract(__privateGet(this, _props7).multiple, false)));
    __privateAdd(this, _scrollAlignment, user_derived(() => extract(__privateGet(this, _props7).scrollAlignment, "nearest")));
    /* State */
    __privateAdd(this, _value2);
    __privateAdd(this, _inputValue, state(""));
    __privateAdd(this, _highlighted);
    __privateAdd(this, _touched, state(false));
    __publicField(this, "onSelectMap", /* @__PURE__ */ new Map());
    __publicField(this, "isSelected", (value) => {
      return __privateGet(this, _value2).has(value);
    });
    __privateSet(this, _props7, props);
    __privateSet(this, _value2, new SelectionState({
      value: props.value,
      onChange: props.onValueChange,
      multiple: props.multiple
    }));
    __privateSet(this, _highlighted, new Synced({
      value: props.highlighted,
      onChange: props.onHighlightChange,
      defaultValue: null
    }));
    const oldIds = this.ids;
    const newIds = createIds4();
    this.ids = {
      ...oldIds,
      input: oldIds.invoker,
      content: oldIds.popover,
      trigger: newIds.trigger
    };
  }
  get multiple() {
    return get(__privateGet(this, _multiple2));
  }
  set multiple(value) {
    set(__privateGet(this, _multiple2), value);
  }
  get scrollAlignment() {
    return get(__privateGet(this, _scrollAlignment));
  }
  set scrollAlignment(value) {
    set(__privateGet(this, _scrollAlignment), value);
  }
  get inputValue() {
    return get(__privateGet(this, _inputValue));
  }
  set inputValue(value) {
    set(__privateGet(this, _inputValue), value, true);
  }
  get touched() {
    return get(__privateGet(this, _touched));
  }
  set touched(value) {
    set(__privateGet(this, _touched), value, true);
  }
  get value() {
    return __privateGet(this, _value2).current;
  }
  set value(value) {
    __privateGet(this, _value2).current = value;
  }
  get highlighted() {
    return __privateGet(this, _highlighted).current;
  }
  set highlighted(v) {
    __privateGet(this, _highlighted).current = v;
  }
  get valueAsString() {
    return __privateGet(this, _value2).toArray().join(", ");
  }
  select(value) {
    const onSelect = this.onSelectMap.get(value);
    if (!this.isSelected(value) && onSelect) {
      onSelect();
      return;
    }
    __privateGet(this, _value2).toggle(value);
    if (this.multiple) {
      this.inputValue = "";
      return;
    }
    this.inputValue = this.valueAsString;
    this.open = false;
  }
  get input() {
    return {
      ...super.getInvoker(),
      [dataAttrs4.input]: "",
      id: this.ids.input,
      role: "combobox",
      "aria-expanded": this.open,
      "aria-controls": this.ids.content,
      "aria-owns": this.ids.content,
      onclick: void 0,
      value: this.inputValue,
      oninput: (e) => {
        const input = e.currentTarget;
        if (!isHtmlInputElement(input)) return;
        this.open = true;
        this.inputValue = input.value;
        tick().then(() => this.highlightFirst());
        this.touched = true;
      },
      onkeydown: (e) => {
        if (this.open) {
          const kbdSubset = pick(kbd, "ARROW_DOWN", "ARROW_UP", "ESCAPE", "ENTER");
          if (Object.values(kbdSubset).includes(e.key)) e.preventDefault();
          switch (e.key) {
            case kbdSubset.ARROW_DOWN: {
              this.highlightNext();
              break;
            }
            case kbdSubset.ARROW_UP: {
              this.highlightPrev();
              break;
            }
            case kbdSubset.ESCAPE: {
              this.open = false;
              break;
            }
            case kbdSubset.ENTER: {
              if (strict_equals(this.highlighted, null)) return;
              this.select(this.highlighted);
              break;
            }
          }
        } else {
          const kbdSubset = pick(kbd, "ARROW_DOWN", "ARROW_UP", "ESCAPE");
          if (Object.values(kbdSubset).includes(e.key)) e.preventDefault();
          else if (letterRegex.test(e.key)) this.open = true;
          switch (e.key) {
            case kbdSubset.ARROW_DOWN: {
              if (this.open) {
                return this.highlightNext();
              }
              this.open = true;
              tick().then(() => {
                if (!this.value) this.highlightFirst();
              });
              break;
            }
            case kbdSubset.ARROW_UP: {
              if (this.open) {
                return this.highlightNext();
              }
              this.open = true;
              tick().then(() => {
                if (!this.value) this.highlightLast();
              });
              break;
            }
            case kbdSubset.ESCAPE: {
              __privateGet(this, _value2).clear();
              this.inputValue = "";
              break;
            }
          }
        }
      }
    };
  }
  get trigger() {
    return {
      [dataAttrs4.trigger]: "",
      id: this.ids.trigger,
      onclick: () => {
        var _a;
        this.open = !this.open;
        (_a = document.getElementById(this.ids.input)) == null ? void 0 : _a.focus();
      },
      ...super.sharedProps
    };
  }
  get content() {
    return Object.assign(super.getPopover(), {
      [dataAttrs4.content]: "",
      role: "listbox",
      "aria-expanded": this.open,
      "aria-activedescendant": this.highlighted ? this.getOptionId(this.highlighted) : void 0
    });
  }
  scrollIntoView(value) {
    if (strict_equals(this.scrollAlignment, null)) return;
    const v = value ?? this.highlighted;
    if (!v) return;
    const id = this.getOptionId(v);
    const el = document.getElementById(id);
    if (el) el.scrollIntoView({ block: this.scrollAlignment });
  }
  getOptionId(value) {
    return `${this.ids.content}-option-${dataAttr(value)}`;
  }
  /**
   * Gets the attributes for the option element.
   * @param value The value of the option.
   * @param onSelect An optional callback to call when the option is selected, overriding the default behavior.
   * @returns The attributes for the option element.
   */
  getOption(value, onSelect) {
    safeEffect(() => {
      if (onSelect) this.onSelectMap.set(value, onSelect);
      return () => {
        this.onSelectMap.delete(value);
      };
    });
    return {
      id: this.getOptionId(value),
      [dataAttrs4.option]: "",
      "data-value": dataAttr(value),
      "aria-hidden": this.open ? void 0 : true,
      "aria-selected": __privateGet(this, _value2).has(value),
      "data-highlighted": dataAttr(strict_equals(this.highlighted, value)),
      role: "option",
      onmouseover: () => {
        this.highlighted = value;
      },
      onclick: () => {
        this.select(value);
      }
    };
  }
  getOptionsEls() {
    const contentEl = document.getElementById(this.ids.content);
    if (!contentEl) return [];
    return [
      ...contentEl.querySelectorAll(dataSelectors3.option)
    ].filter(isHtmlElement);
  }
  getOptions() {
    const els = this.getOptionsEls();
    return els.map((el) => el.dataset.value);
  }
  highlight(value) {
    this.highlighted = value;
    this.scrollIntoView(value);
  }
  highlightNext() {
    const options = this.getOptions();
    const next = findNext(options, (v) => strict_equals(v, this.highlighted));
    if (strict_equals(next, void 0, false)) this.highlight(next);
  }
  highlightPrev() {
    const options = this.getOptions();
    const prev = findPrev(options, (v) => strict_equals(v, this.highlighted));
    if (strict_equals(prev, void 0, false)) this.highlight(prev);
  }
  highlightFirst() {
    const first2 = this.getOptions()[0];
    if (first2) this.highlight(first2);
  }
  highlightLast() {
    const last2 = this.getOptions().at(-1);
    if (last2) this.highlight(last2);
  }
  [ADD_OWNER](owner) {
    add_owner_to_class(this, owner, [
      () => get(__privateGet(this, _multiple2)),
      () => get(__privateGet(this, _scrollAlignment)),
      () => get(__privateGet(this, _inputValue)),
      () => get(__privateGet(this, _touched))
    ]);
  }
};
_props7 = new WeakMap();
_multiple2 = new WeakMap();
_scrollAlignment = new WeakMap();
_value2 = new WeakMap();
_inputValue = new WeakMap();
_highlighted = new WeakMap();
_touched = new WeakMap();

// node_modules/.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/file.js
function blobToArrayBuffer(blob, chunk) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    const s = chunk ? Math.min(chunk, blob.size) : blob.size;
    const b = blob.slice(0, s);
    reader.onload = () => resolve(reader.result);
    reader.onerror = reject;
    reader.readAsArrayBuffer(b);
  });
}
function compareBuffers(buf1, buf2) {
  if (buf1 === buf2)
    return true;
  if (buf1.byteLength !== buf2.byteLength)
    return false;
  const d1 = new DataView(buf1), d2 = new DataView(buf2);
  let i = buf1.byteLength;
  while (i--) {
    if (d1.getUint8(i) !== d2.getUint8(i))
      return false;
  }
  return true;
}
async function areFilesEqual(file1, file2, chunkSize = 1024 * 1024) {
  if (file1.size !== file2.size) {
    return false;
  }
  let offset3 = 0;
  while (offset3 < file1.size) {
    const s = Math.min(chunkSize, file1.size - offset3);
    const b1 = file1.slice(offset3, offset3 + s);
    const b2 = file2.slice(offset3, offset3 + s);
    const chunk1 = await blobToArrayBuffer(b1, chunkSize);
    const chunk2 = await blobToArrayBuffer(b2, chunkSize);
    if (!compareBuffers(chunk1, chunk2)) {
      return false;
    }
    offset3 += chunkSize;
  }
  return true;
}

// node_modules/.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/builders/FileUpload.svelte.js
var { dataAttrs: dataAttrs5, createIds: createIds5 } = createBuilderMetadata("fileupload", ["dropzone", "input"]);
var _props8, _multiple3, _accept, _maxSize, _disabled3, _avoidDuplicates, _isDragging, _ids4, _selected, _handleFiles;
var FileUpload = class {
  constructor(props = {}) {
    __privateAdd(this, _props8);
    __privateAdd(this, _multiple3, user_derived(() => extract(__privateGet(this, _props8).multiple, false)));
    __privateAdd(this, _accept, user_derived(() => extract(__privateGet(this, _props8).accept, void 0)));
    __privateAdd(this, _maxSize, user_derived(() => extract(__privateGet(this, _props8).maxSize, void 0)));
    __privateAdd(this, _disabled3, user_derived(() => extract(__privateGet(this, _props8).disabled, false)));
    __privateAdd(this, _avoidDuplicates, user_derived(() => extract(__privateGet(this, _props8).avoidDuplicates, false)));
    __privateAdd(this, _isDragging, state(false));
    __privateAdd(this, _ids4, createIds5());
    __privateAdd(this, _selected);
    __privateAdd(this, _handleFiles, async (files) => {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      if (!files) return;
      const fileArray = Array.from(files);
      const validFiles = [];
      for (const file of fileArray) {
        if (this.avoidDuplicates && await this.has(file)) continue;
        if (this.accept) {
          const acceptTypes = this.accept.split(",").map((t) => t.trim());
          const isValidType = acceptTypes.some((type) => {
            if (type.startsWith(".")) {
              return file.name.toLowerCase().endsWith(type.toLowerCase());
            } else if (type.endsWith("/*")) {
              const group = type.split("/")[0];
              return file.type.startsWith(`${group}/`);
            } else {
              return strict_equals(file.type, type);
            }
          });
          if (!isValidType) {
            (_b = (_a = __privateGet(this, _props8)).onError) == null ? void 0 : _b.call(_a, {
              type: "type",
              file,
              message: `File type ${file.type} is not accepted`
            });
            continue;
          }
        }
        if (this.maxSize && file.size > this.maxSize) {
          (_d = (_c = __privateGet(this, _props8)).onError) == null ? void 0 : _d.call(_c, {
            type: "size",
            file,
            message: `File size ${file.size} exceeds maximum size of ${this.maxSize}`
          });
          continue;
        }
        if (__privateGet(this, _props8).validate && !__privateGet(this, _props8).validate(file)) {
          (_f = (_e = __privateGet(this, _props8)).onError) == null ? void 0 : _f.call(_e, {
            type: "validation",
            file,
            message: `File failed custom validation`
          });
          continue;
        }
        validFiles.push(file);
        (_h = (_g = __privateGet(this, _props8)).onAccept) == null ? void 0 : _h.call(_g, file);
      }
      if (!validFiles.length) return;
      if (this.multiple) {
        __privateGet(this, _selected).addAll(validFiles);
      } else {
        const firstFile = validFiles[0];
        if (firstFile) __privateGet(this, _selected).add(firstFile);
      }
    });
    __privateSet(this, _props8, props);
    __privateSet(this, _selected, new SelectionState({
      value: props.selected,
      onChange: props.onSelectedChange,
      multiple: props.multiple
    }));
  }
  get multiple() {
    return get(__privateGet(this, _multiple3));
  }
  set multiple(value) {
    set(__privateGet(this, _multiple3), value);
  }
  get accept() {
    return get(__privateGet(this, _accept));
  }
  set accept(value) {
    set(__privateGet(this, _accept), value);
  }
  get maxSize() {
    return get(__privateGet(this, _maxSize));
  }
  set maxSize(value) {
    set(__privateGet(this, _maxSize), value);
  }
  get disabled() {
    return get(__privateGet(this, _disabled3));
  }
  set disabled(value) {
    set(__privateGet(this, _disabled3), value);
  }
  get avoidDuplicates() {
    return get(__privateGet(this, _avoidDuplicates));
  }
  set avoidDuplicates(value) {
    set(__privateGet(this, _avoidDuplicates), value);
  }
  get isDragging() {
    return get(__privateGet(this, _isDragging));
  }
  /**
   * Gets the currently selected files
   */
  get selected() {
    return __privateGet(this, _selected).current;
  }
  /**
   * Sets the currently selected files
   */
  set selected(value) {
    __privateGet(this, _selected).current = value;
  }
  /**
   * Clears the currently selected files
   */
  clear() {
    __privateGet(this, _selected).clear();
  }
  /**
   * Removes a file from the selection
   */
  remove(file) {
    __privateGet(this, _selected).delete(file);
  }
  async has(file) {
    const files = __privateGet(this, _selected).toArray();
    const promises = files.map((f) => areFilesEqual(f, file));
    const results = await Promise.all(promises);
    return results.some(Boolean);
  }
  /** The dropzone element, where you can drag files into, or click to open the file picker. */
  get dropzone() {
    return {
      [dataAttrs5.dropzone]: "",
      "data-dragging": dataAttr(get(__privateGet(this, _isDragging))),
      "data-disabled": dataAttr(this.disabled),
      ondragenter: (e) => {
        if (this.disabled) return;
        e.preventDefault();
        if (!get(__privateGet(this, _isDragging))) {
          set(__privateGet(this, _isDragging), true);
        }
      },
      ondragleave: (e) => {
        if (this.disabled) return;
        e.preventDefault();
        const relatedTarget = e.relatedTarget;
        const dropzone = e.currentTarget;
        if (!relatedTarget || !dropzone.contains(relatedTarget)) {
          set(__privateGet(this, _isDragging), false);
        }
      },
      ondragover: (e) => {
        if (this.disabled) return;
        e.preventDefault();
      },
      ondrop: (e) => {
        var _a;
        if (this.disabled) return;
        e.preventDefault();
        set(__privateGet(this, _isDragging), false);
        if ((_a = e.dataTransfer) == null ? void 0 : _a.files) {
          __privateGet(this, _handleFiles).call(this, e.dataTransfer.files);
        }
      },
      onclick: () => {
        if (this.disabled) return;
        const input = document.getElementById(__privateGet(this, _ids4).input);
        if (input) {
          input.click();
        }
      }
    };
  }
  /** The hidden file input element. */
  get input() {
    watch(() => snapshot(__privateGet(this, _selected).toArray()), () => {
      const input = document.getElementById(__privateGet(this, _ids4).input);
      if (!input) return;
      const set2 = __privateGet(this, _selected).toSet();
      const dt = new DataTransfer();
      for (const file of set2) {
        dt.items.add(file);
      }
      input.files = dt.files;
    });
    return {
      [dataAttrs5.input]: "",
      id: __privateGet(this, _ids4).input,
      type: "file",
      accept: this.accept,
      multiple: this.multiple,
      style: "display: none;",
      disabled: this.disabled,
      onchange: (e) => {
        if (this.disabled) return;
        const input = e.target;
        const files = input.files;
        input.files = null;
        __privateGet(this, _handleFiles).call(this, files);
      }
    };
  }
  /** An optional trigger element, which can be used to open the file picker. */
  get trigger() {
    return {
      "data-disabled": dataAttr(this.disabled),
      onclick: () => {
        if (this.disabled) return;
        const input = document.getElementById(__privateGet(this, _ids4).input);
        if (input) {
          input.click();
        }
      }
    };
  }
  [ADD_OWNER](owner) {
    add_owner_to_class(this, owner, [
      () => get(__privateGet(this, _multiple3)),
      () => get(__privateGet(this, _accept)),
      () => get(__privateGet(this, _maxSize)),
      () => get(__privateGet(this, _disabled3)),
      () => get(__privateGet(this, _avoidDuplicates))
    ]);
  }
};
_props8 = new WeakMap();
_multiple3 = new WeakMap();
_accept = new WeakMap();
_maxSize = new WeakMap();
_disabled3 = new WeakMap();
_avoidDuplicates = new WeakMap();
_isDragging = new WeakMap();
_ids4 = new WeakMap();
_selected = new WeakMap();
_handleFiles = new WeakMap();

// node_modules/.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/builders/PinInput.svelte.js
var identifiers2 = createDataIds("pin-input", ["root", "input"]);
function validateInput(char, type) {
  switch (type) {
    case "alphanumeric":
      return /^[a-zA-Z0-9]$/.test(char);
    case "numeric":
      return /^[0-9]$/.test(char);
    case "text":
      return true;
  }
}
function setInputSelectionRange(input, start, end) {
  setTimeout(() => {
    if (strict_equals(input.value.length, 0)) return;
    if (strict_equals(input.selectionStart, start) && strict_equals(input.selectionEnd, end)) return;
    input.setSelectionRange(start, end);
  });
}
var _id, _props9, _maxLength, _placeholder, _disabled4, _mask, _type, _allowPaste, _value3, _focusedIndex, _isFilled, _PinInput_instances, getInputEls_fn, deleteCharAtIndex_fn, addCharAtIndex_fn, getInput_fn;
var PinInput = class {
  constructor(props = {}) {
    __privateAdd(this, _PinInput_instances);
    __privateAdd(this, _id, nanoid());
    /* Props */
    __privateAdd(this, _props9);
    __privateAdd(this, _maxLength, user_derived(() => extract(__privateGet(this, _props9).maxLength, 4)));
    __privateAdd(this, _placeholder, user_derived(() => extract(__privateGet(this, _props9).placeholder, "○")));
    __privateAdd(this, _disabled4, user_derived(() => extract(__privateGet(this, _props9).disabled, false)));
    __privateAdd(this, _mask, user_derived(() => extract(__privateGet(this, _props9).mask, false)));
    __privateAdd(this, _type, user_derived(() => extract(__privateGet(this, _props9).type, "text")));
    __privateAdd(this, _allowPaste, user_derived(() => extract(__privateGet(this, _props9).allowPaste, true)));
    /* State */
    __privateAdd(this, _value3);
    __privateAdd(this, _focusedIndex, state(-1));
    __privateAdd(this, _isFilled, user_derived(() => strict_equals(this.value.length, this.maxLength)));
    __privateSet(this, _value3, new Synced({
      value: props.value,
      onChange: props.onValueChange,
      defaultValue: ""
    }));
    __privateSet(this, _props9, props);
  }
  get maxLength() {
    return get(__privateGet(this, _maxLength));
  }
  set maxLength(value) {
    set(__privateGet(this, _maxLength), value);
  }
  get placeholder() {
    return get(__privateGet(this, _placeholder));
  }
  set placeholder(value) {
    set(__privateGet(this, _placeholder), value);
  }
  get disabled() {
    return get(__privateGet(this, _disabled4));
  }
  set disabled(value) {
    set(__privateGet(this, _disabled4), value);
  }
  get mask() {
    return get(__privateGet(this, _mask));
  }
  set mask(value) {
    set(__privateGet(this, _mask), value);
  }
  get type() {
    return get(__privateGet(this, _type));
  }
  set type(value) {
    set(__privateGet(this, _type), value);
  }
  get allowPaste() {
    return get(__privateGet(this, _allowPaste));
  }
  set allowPaste(value) {
    set(__privateGet(this, _allowPaste), value);
  }
  get isFilled() {
    return get(__privateGet(this, _isFilled));
  }
  set isFilled(value) {
    set(__privateGet(this, _isFilled), value);
  }
  get value() {
    return __privateGet(this, _value3).current;
  }
  set value(value) {
    var _a, _b;
    const prev = __privateGet(this, _value3).current;
    __privateGet(this, _value3).current = value;
    const inputs = __privateMethod(this, _PinInput_instances, getInputEls_fn).call(this);
    inputs.forEach((input, index) => {
      input.value = value[index] ?? "";
    });
    const completed = strict_equals(prev.length, value.length, false) && strict_equals(value.length, this.maxLength);
    if (completed) {
      (_b = (_a = __privateGet(this, _props9)).onComplete) == null ? void 0 : _b.call(_a, value);
    }
  }
  /** The root element's props. */
  get root() {
    return {
      [identifiers2.root]: "",
      id: __privateGet(this, _id),
      "data-complete": dataAttr(this.isFilled)
    };
  }
  /** An array of props that should be spread to the input elements. */
  get inputs() {
    return Array(this.maxLength).fill(0).map((_, index) => __privateMethod(this, _PinInput_instances, getInput_fn).call(this, index));
  }
  [ADD_OWNER](owner) {
    add_owner_to_class(this, owner, [
      () => get(__privateGet(this, _maxLength)),
      () => get(__privateGet(this, _placeholder)),
      () => get(__privateGet(this, _disabled4)),
      () => get(__privateGet(this, _mask)),
      () => get(__privateGet(this, _type)),
      () => get(__privateGet(this, _allowPaste)),
      () => get(__privateGet(this, _isFilled))
    ]);
  }
};
_id = new WeakMap();
_props9 = new WeakMap();
_maxLength = new WeakMap();
_placeholder = new WeakMap();
_disabled4 = new WeakMap();
_mask = new WeakMap();
_type = new WeakMap();
_allowPaste = new WeakMap();
_value3 = new WeakMap();
_focusedIndex = new WeakMap();
_isFilled = new WeakMap();
_PinInput_instances = new WeakSet();
getInputEls_fn = function() {
  if (!inBrowser()) return [];
  const rootEl = document.getElementById(__privateGet(this, _id));
  if (!rootEl) return [];
  return [
    ...rootEl.querySelectorAll(`[${identifiers2.input}]`)
  ].filter(isHtmlInputElement);
};
deleteCharAtIndex_fn = function(index) {
  this.value = this.value.slice(0, index) + this.value.slice(index + 1);
};
addCharAtIndex_fn = function(char, index) {
  this.value = this.value.slice(0, index) + char + this.value.slice(index + 1);
};
getInput_fn = function(index) {
  const currValue = this.value[index];
  const isFilled = strict_equals(currValue, void 0, false);
  const isFocused = strict_equals(get(__privateGet(this, _focusedIndex)), index);
  const isLast = strict_equals(index, this.maxLength - 1);
  const canFocus = this.isFilled && isLast || strict_equals(index, this.value.length);
  const onpaste = (pasted) => {
    var _a, _b, _c;
    if (!this.allowPaste) return;
    const inputs = __privateMethod(this, _PinInput_instances, getInputEls_fn).call(this);
    if (!inputs.length) return;
    const focusedIndex = Math.max(get(__privateGet(this, _focusedIndex)), 0);
    const initialIndex = pasted.length >= inputs.length ? 0 : focusedIndex;
    const lastIndex = Math.min(initialIndex + pasted.length, inputs.length);
    const valid = pasted.split("").every((char) => validateInput(char, this.type));
    if (!valid) {
      (_b = (_a = __privateGet(this, _props9)).onError) == null ? void 0 : _b.call(_a, {
        method: "paste",
        message: `Input did not match the type ${this.type}`
      });
      return;
    }
    for (let i = initialIndex; i < lastIndex; i++) {
      const input = inputs[i];
      if (!input) continue;
      input.value = pasted[i - initialIndex] ?? "";
      __privateMethod(this, _PinInput_instances, addCharAtIndex_fn).call(this, pasted[i - initialIndex] ?? "", i);
    }
    (_c = inputs[lastIndex]) == null ? void 0 : _c.focus();
  };
  return {
    [identifiers2.input]: "",
    placeholder: isFocused ? void 0 : this.placeholder,
    disabled: disabledAttr(this.disabled),
    type: this.mask ? "password" : "text",
    "data-filled": dataAttr(isFilled),
    tabindex: canFocus ? 0 : -1,
    inputmode: strict_equals(this.type, "numeric") ? "numeric" : "text",
    style: canFocus && isFocused && !isFilled ? void 0 : "caret-color: transparent;",
    onkeydown: (e) => {
      var _a, _b, _c, _d;
      const el = e.target;
      if (!isHtmlInputElement(el)) {
        return;
      }
      const inputs = __privateMethod(this, _PinInput_instances, getInputEls_fn).call(this);
      switch (e.key) {
        case "ArrowLeft": {
          e.preventDefault();
          (_a = inputs[index - 1]) == null ? void 0 : _a.focus();
          break;
        }
        case "ArrowRight": {
          if (!this.value[index]) return;
          e.preventDefault();
          (_b = inputs.at(index + 1)) == null ? void 0 : _b.focus();
          break;
        }
        case "Home": {
          e.preventDefault();
          (_c = inputs[0]) == null ? void 0 : _c.focus();
          break;
        }
        case "End": {
          e.preventDefault();
          const lastFocusableIndex = Math.min(this.value.length, inputs.length - 1);
          (_d = inputs[lastFocusableIndex]) == null ? void 0 : _d.focus();
          break;
        }
        case "Backspace": {
          e.preventDefault();
          if (this.value[index]) {
            __privateMethod(this, _PinInput_instances, deleteCharAtIndex_fn).call(this, index);
          } else {
            __privateMethod(this, _PinInput_instances, deleteCharAtIndex_fn).call(this, index - 1);
            setTimeout(() => {
              var _a2;
              return (_a2 = inputs[index - 1]) == null ? void 0 : _a2.focus();
            });
          }
          break;
        }
      }
    },
    onpointerdown: (e) => {
      const el = e.target;
      if (!isHtmlInputElement(el)) {
        return;
      }
      setInputSelectionRange(el, 1, 1);
      if (this.value[index]) return;
      const inputs = __privateMethod(this, _PinInput_instances, getInputEls_fn).call(this);
      setTimeout(() => {
        var _a;
        return (_a = inputs[this.value.length]) == null ? void 0 : _a.focus();
      });
    },
    onpointerup: (e) => {
      const el = e.target;
      if (!isHtmlInputElement(el)) {
        return;
      }
      setInputSelectionRange(el, 1, 1);
    },
    oninput: (e) => {
      var _a, _b;
      const el = e.target;
      if (!isHtmlInputElement(el)) {
        return;
      }
      e.preventDefault();
      const prev = currValue;
      const inputted = prev ? el.value.slice(prev.length) : el.value;
      if (strict_equals(inputted.length, 1)) {
        const char = el.value.slice(el.value.length - 1);
        if (!validateInput(char, this.type)) {
          (_b = (_a = __privateGet(this, _props9)).onError) == null ? void 0 : _b.call(_a, {
            method: "input",
            message: `Input did not match the type ${this.type}`
          });
          el.value = el.value.slice(0, -1);
          return;
        }
        el.value = char;
        __privateMethod(this, _PinInput_instances, addCharAtIndex_fn).call(this, char, index);
        const inputs = __privateMethod(this, _PinInput_instances, getInputEls_fn).call(this);
        const currIndex = inputs.indexOf(el);
        setTimeout(() => {
          var _a2;
          return (_a2 = inputs[currIndex + 1]) == null ? void 0 : _a2.focus();
        });
      } else {
        if (__privateGet(this, _props9).onPaste) {
          __privateGet(this, _props9).onPaste(inputted);
        } else {
          onpaste(inputted);
        }
      }
    },
    onfocus: () => {
      set(__privateGet(this, _focusedIndex), index, true);
    },
    onblur: () => {
      set(__privateGet(this, _focusedIndex), -1);
    },
    onpaste: (e) => {
      var _a;
      e.preventDefault();
      const pasted = (_a = e.clipboardData) == null ? void 0 : _a.getData("text");
      if (!pasted) return;
      if (__privateGet(this, _props9).onPaste) {
        __privateGet(this, _props9).onPaste(pasted);
      } else {
        onpaste(pasted);
      }
    }
  };
};

// node_modules/.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/builders/Progress.svelte.js
var dataIds = createDataIds("progress", ["root", "progress"]);
var _props10, _max, _value4;
var Progress = class {
  constructor(props = {}) {
    // Props
    __privateAdd(this, _props10);
    __privateAdd(this, _max, user_derived(() => extract(__privateGet(this, _props10).max, 100)));
    // States
    __privateAdd(this, _value4);
    __privateSet(this, _props10, props);
    __privateSet(this, _value4, new Synced({
      value: props.value,
      onChange: props.onValueChange,
      defaultValue: 0
    }));
  }
  get max() {
    return get(__privateGet(this, _max));
  }
  set max(value) {
    set(__privateGet(this, _max), value);
  }
  get value() {
    return __privateGet(this, _value4).current;
  }
  set value(value) {
    __privateGet(this, _value4).current = value;
  }
  /**
   * Spread attributes for the Progress root element.
   */
  get root() {
    return {
      [dataIds.root]: "",
      value: __privateGet(this, _value4).current,
      max: this.max,
      role: "meter",
      "aria-valuemin": 0,
      "aria-valuemax": this.max,
      "aria-valuenow": __privateGet(this, _value4).current,
      "data-value": __privateGet(this, _value4).current,
      "data-state": strict_equals(__privateGet(this, _value4).current, this.max) ? "complete" : "loading",
      "data-max": this.max
    };
  }
  /**
   * Spread attributes for the Progress percentage element.
   * Provides a --progress CSS variable that can be used to style the progress:
   * `transform: translateX(calc(var(--progress) * -1));`
   */
  get progress() {
    return {
      [dataIds.progress]: "",
      style: styleAttr({
        "--progress": `${100 - 100 * (__privateGet(this, _value4).current ?? 0) / (this.max ?? 1)}%`,
        "--neg-progress": `-${100 - 100 * (__privateGet(this, _value4).current ?? 0) / (this.max ?? 1)}%`
      })
    };
  }
  [ADD_OWNER](owner) {
    add_owner_to_class(this, owner, [() => get(__privateGet(this, _max))]);
  }
};
_props10 = new WeakMap();
_max = new WeakMap();
_value4 = new WeakMap();

// node_modules/.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/builders/RadioGroup.svelte.js
var metadata = createBuilderMetadata("radio-group", ["root", "item", "label", "hidden-input"]);
var _ids5, _props11, _disabled5, _required, _loop, _selectWhenFocused, _orientation, _value5, _RadioGroup_instances, sharedAttrs_get2;
var RadioGroup = class {
  constructor(props) {
    __privateAdd(this, _RadioGroup_instances);
    __privateAdd(this, _ids5, metadata.createIds());
    /* Props */
    __privateAdd(this, _props11);
    __privateAdd(this, _disabled5, user_derived(() => extract(__privateGet(this, _props11).disabled, false)));
    __privateAdd(this, _required, user_derived(() => extract(__privateGet(this, _props11).required, false)));
    __privateAdd(this, _loop, user_derived(() => extract(__privateGet(this, _props11).loop, true)));
    __privateAdd(this, _selectWhenFocused, user_derived(() => extract(__privateGet(this, _props11).selectWhenFocused, true)));
    __privateAdd(this, _orientation, user_derived(() => extract(__privateGet(this, _props11).orientation, "vertical")));
    /* State */
    __privateAdd(this, _value5);
    __privateSet(this, _props11, props);
    __privateSet(this, _value5, new Synced({
      value: props.value,
      onChange: props.onValueChange,
      defaultValue: ""
    }));
  }
  get disabled() {
    return get(__privateGet(this, _disabled5));
  }
  set disabled(value) {
    set(__privateGet(this, _disabled5), value);
  }
  get required() {
    return get(__privateGet(this, _required));
  }
  set required(value) {
    set(__privateGet(this, _required), value);
  }
  get loop() {
    return get(__privateGet(this, _loop));
  }
  set loop(value) {
    set(__privateGet(this, _loop), value);
  }
  get selectWhenFocused() {
    return get(__privateGet(this, _selectWhenFocused));
  }
  set selectWhenFocused(value) {
    set(__privateGet(this, _selectWhenFocused), value);
  }
  get orientation() {
    return get(__privateGet(this, _orientation));
  }
  set orientation(value) {
    set(__privateGet(this, _orientation), value);
  }
  get value() {
    return __privateGet(this, _value5).current;
  }
  set value(value) {
    __privateGet(this, _value5).current = value;
  }
  get root() {
    return {
      ...__privateGet(this, _RadioGroup_instances, sharedAttrs_get2),
      [metadata.dataAttrs["root"]]: "",
      id: __privateGet(this, _ids5).root,
      role: "radiogroup",
      "aria-required": this.required,
      "aria-labelledby": __privateGet(this, _ids5).label
    };
  }
  get label() {
    return {
      ...__privateGet(this, _RadioGroup_instances, sharedAttrs_get2),
      [metadata.dataAttrs.label]: "",
      id: __privateGet(this, _ids5).label,
      for: __privateGet(this, _ids5).root,
      onclick: (e) => {
        if (this.disabled) return;
        const el = e.currentTarget;
        if (!isHtmlElement(el)) return;
        const root = el.closest(metadata.dataSelectors.root);
        if (!isHtmlElement(root)) return;
        const item = root.querySelector(metadata.dataSelectors.item + `[data-value="${dataAttr(this.value)}"]`);
        if (isHtmlElement(item)) item.focus();
      }
    };
  }
  getItem(item) {
    return new RadioItem({
      group: this,
      item,
      getSharedAttrs: () => __privateGet(this, _RadioGroup_instances, sharedAttrs_get2)
    });
  }
  get hiddenInput() {
    return {
      [metadata.dataAttrs["hidden-input"]]: "",
      disabled: this.disabled,
      required: this.required,
      hidden: true,
      "aria-hidden": true,
      tabindex: -1,
      value: this.value,
      name: extract(__privateGet(this, _props11).name)
    };
  }
  select(item) {
    if (this.disabled) return;
    this.value = item;
  }
  [ADD_OWNER](owner) {
    add_owner_to_class(this, owner, [
      () => get(__privateGet(this, _disabled5)),
      () => get(__privateGet(this, _required)),
      () => get(__privateGet(this, _loop)),
      () => get(__privateGet(this, _selectWhenFocused)),
      () => get(__privateGet(this, _orientation))
    ]);
  }
};
_ids5 = new WeakMap();
_props11 = new WeakMap();
_disabled5 = new WeakMap();
_required = new WeakMap();
_loop = new WeakMap();
_selectWhenFocused = new WeakMap();
_orientation = new WeakMap();
_value5 = new WeakMap();
_RadioGroup_instances = new WeakSet();
sharedAttrs_get2 = function() {
  return {
    "data-orientation": dataAttr(this.orientation),
    "data-disabled": disabledAttr(this.disabled),
    "data-value": this.value
  };
};
var _props12, _group, _value6, _checked, _RadioItem_instances, select_fn;
var RadioItem = class {
  constructor(props) {
    __privateAdd(this, _RadioItem_instances);
    __privateAdd(this, _props12);
    __privateAdd(this, _group, user_derived(() => __privateGet(this, _props12).group));
    __privateAdd(this, _value6, user_derived(() => __privateGet(this, _props12).item));
    __privateAdd(this, _checked, user_derived(() => strict_equals(get(__privateGet(this, _group)).value, this.value)));
    __privateSet(this, _props12, props);
  }
  get value() {
    return get(__privateGet(this, _value6));
  }
  set value(value) {
    set(__privateGet(this, _value6), value);
  }
  get checked() {
    return get(__privateGet(this, _checked));
  }
  set checked(value) {
    set(__privateGet(this, _checked), value);
  }
  get attrs() {
    return {
      ...__privateGet(this, _props12).getSharedAttrs(),
      [metadata.dataAttrs["item"]]: "",
      "data-value": dataAttr(this.value),
      "data-state": dataAttr(this.checked ? "checked" : "unchecked"),
      "aria-checked": this.checked,
      role: "radio",
      tabindex: 0,
      onclick: (e) => {
        __privateMethod(this, _RadioItem_instances, select_fn).call(this, e);
      },
      onkeydown: (e) => {
        if (strict_equals(e.key, kbd.SPACE)) {
          e.preventDefault();
          __privateMethod(this, _RadioItem_instances, select_fn).call(this, e);
          return;
        }
        const el = e.currentTarget;
        const root = el.closest(metadata.dataSelectors.root);
        if (!isHtmlElement(root)) return;
        const items = Array.from(root.querySelectorAll(metadata.dataSelectors.item)).filter((el2) => isHtmlElement(el2) && !el2.hasAttribute("data-disabled"));
        const currentIdx = items.indexOf(el);
        const loop = get(__privateGet(this, _group)).loop;
        const style = window.getComputedStyle(el);
        const dir = style.getPropertyValue("direction");
        const { nextKey, prevKey } = getDirectionalKeys(dir, get(__privateGet(this, _group)).orientation);
        let itemToFocus;
        switch (e.key) {
          case nextKey: {
            e.preventDefault();
            const nextIdx = currentIdx + 1;
            if (nextIdx >= items.length && loop) {
              itemToFocus = items[0];
            } else {
              itemToFocus = items[nextIdx];
            }
            break;
          }
          case prevKey: {
            e.preventDefault();
            const prevIdx = currentIdx - 1;
            if (prevIdx < 0 && loop) {
              itemToFocus = items[items.length - 1];
            } else {
              itemToFocus = items[prevIdx];
            }
            break;
          }
          case kbd.HOME: {
            e.preventDefault();
            itemToFocus = items[0];
            break;
          }
          case kbd.END: {
            e.preventDefault();
            itemToFocus = items[items.length - 1];
            break;
          }
          default: {
            return;
          }
        }
        if (itemToFocus) {
          itemToFocus.focus();
          if (get(__privateGet(this, _group)).selectWhenFocused) get(__privateGet(this, _group)).select(itemToFocus.dataset.value);
        }
      }
    };
  }
  [ADD_OWNER](owner) {
    add_owner_to_class(this, owner, [
      () => get(__privateGet(this, _value6)),
      () => get(__privateGet(this, _checked))
    ]);
  }
};
_props12 = new WeakMap();
_group = new WeakMap();
_value6 = new WeakMap();
_checked = new WeakMap();
_RadioItem_instances = new WeakSet();
select_fn = function(e) {
  if (get(__privateGet(this, _group)).disabled) return;
  get(__privateGet(this, _group)).select(this.value);
  const el = e.currentTarget;
  if (!isHtmlElement(el)) return;
  el.focus();
};

// node_modules/.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/builders/Select.svelte.js
var { dataAttrs: dataAttrs6, dataSelectors: dataSelectors4, createIds: createIds6 } = createBuilderMetadata("select", ["trigger", "content", "option"]);
var _props13, _multiple4, _scrollAlignment2, _value7, _highlighted2, _typeaheadTimeout, _typeahead, _Select_instances, getOptionsEls_fn, highlight_fn, highlightNext_fn, highlightPrev_fn, highlightFirst_fn, highlightLast_fn;
var Select = class extends BasePopover {
  constructor(props = {}) {
    super({
      sameWidth: true,
      ...props,
      onOpenChange: async (open) => {
        var _a;
        (_a = props.onOpenChange) == null ? void 0 : _a.call(props, open);
        await tick();
        if (!open) {
          this.highlighted = null;
          return;
        }
        if (!this.highlighted) {
          const lastSelected = __privateGet(this, _value7).toArray().at(-1);
          if (lastSelected) this.highlighted = lastSelected;
          else __privateMethod(this, _Select_instances, highlightFirst_fn).call(this);
        }
        const content = document.getElementById(this.ids.content);
        if (!content) return;
        content.focus();
      }
    });
    __privateAdd(this, _Select_instances);
    /* Props */
    __privateAdd(this, _props13);
    __privateAdd(this, _multiple4, user_derived(() => extract(__privateGet(this, _props13).multiple, false)));
    __privateAdd(this, _scrollAlignment2, user_derived(() => extract(__privateGet(this, _props13).scrollAlignment, "nearest")));
    /* State */
    __privateAdd(this, _value7);
    __privateAdd(this, _highlighted2);
    __privateAdd(this, _typeaheadTimeout, user_derived(() => extract(__privateGet(this, _props13).typeaheadTimeout, 500)));
    __privateAdd(this, _typeahead, user_derived(() => createTypeahead({
      timeout: __privateGet(this, _props13).typeaheadTimeout,
      getItems: () => {
        return __privateMethod(this, _Select_instances, getOptionsEls_fn).call(this).reduce(
          (acc, curr) => {
            if (!curr.dataset.value) return acc;
            return [
              ...acc,
              {
                value: curr.dataset.value,
                typeahead: curr.dataset.typeahead,
                current: strict_equals(curr.dataset.value, this.highlighted)
              }
            ];
          },
          []
        );
      }
    })));
    __publicField(this, "isSelected", (value) => {
      return __privateGet(this, _value7).has(value);
    });
    __publicField(this, "select", (value) => {
      if (this.multiple) {
        __privateGet(this, _value7).toggle(value);
        return;
      }
      __privateGet(this, _value7).add(value);
      this.open = false;
      tick().then(() => {
        var _a;
        (_a = document.getElementById(this.ids.trigger)) == null ? void 0 : _a.focus();
      });
    });
    __privateSet(this, _props13, props);
    __privateSet(this, _value7, new SelectionState({
      value: props.value,
      onChange: props.onValueChange,
      multiple: props.multiple
    }));
    __privateSet(this, _highlighted2, new Synced({
      value: props.highlighted,
      onChange: props.onHighlightChange,
      defaultValue: null
    }));
    const oldIds = this.ids;
    const newIds = createIds6();
    this.ids = {
      ...oldIds,
      trigger: oldIds.invoker,
      content: oldIds.popover,
      option: newIds.option
    };
  }
  get multiple() {
    return get(__privateGet(this, _multiple4));
  }
  set multiple(value) {
    set(__privateGet(this, _multiple4), value);
  }
  get scrollAlignment() {
    return get(__privateGet(this, _scrollAlignment2));
  }
  set scrollAlignment(value) {
    set(__privateGet(this, _scrollAlignment2), value);
  }
  get typeaheadTimeout() {
    return get(__privateGet(this, _typeaheadTimeout));
  }
  set typeaheadTimeout(value) {
    set(__privateGet(this, _typeaheadTimeout), value);
  }
  get typeahead() {
    return get(__privateGet(this, _typeahead));
  }
  set typeahead(value) {
    set(__privateGet(this, _typeahead), value);
  }
  get value() {
    return __privateGet(this, _value7).current;
  }
  set value(value) {
    __privateGet(this, _value7).current = value;
  }
  get highlighted() {
    return __privateGet(this, _highlighted2).current;
  }
  set highlighted(v) {
    __privateGet(this, _highlighted2).current = v;
  }
  get valueAsString() {
    return __privateGet(this, _value7).toArray().join(", ");
  }
  get trigger() {
    return Object.assign(super.getInvoker(), {
      [dataAttrs6.trigger]: "",
      role: "combobox",
      "aria-expanded": this.open,
      "aria-controls": this.ids.content,
      "aria-owns": this.ids.content,
      onkeydown: (e) => {
        const kbdSubset = pick(kbd, "ARROW_DOWN", "ARROW_UP");
        if (Object.values(kbdSubset).includes(e.key)) e.preventDefault();
        switch (e.key) {
          case kbdSubset.ARROW_DOWN: {
            this.open = true;
            tick().then(() => {
              if (!this.value) __privateMethod(this, _Select_instances, highlightFirst_fn).call(this);
            });
            break;
          }
          case kbdSubset.ARROW_UP: {
            this.open = true;
            tick().then(() => {
              if (!this.value) __privateMethod(this, _Select_instances, highlightLast_fn).call(this);
            });
            break;
          }
        }
      }
    });
  }
  get content() {
    return Object.assign(super.getPopover(), {
      [dataAttrs6.content]: "",
      role: "listbox",
      "aria-expanded": this.open,
      "aria-activedescendant": this.highlighted ? this.getOptionId(this.highlighted) : void 0,
      onkeydown: (e) => {
        const kbdSubset = pick(kbd, "HOME", "END", "ARROW_DOWN", "ARROW_UP", "ESCAPE", "ENTER", "SPACE");
        if (Object.values(kbdSubset).includes(e.key)) e.preventDefault();
        switch (e.key) {
          case kbdSubset.HOME: {
            __privateMethod(this, _Select_instances, highlightFirst_fn).call(this);
            break;
          }
          case kbdSubset.END: {
            __privateMethod(this, _Select_instances, highlightLast_fn).call(this);
            break;
          }
          case kbdSubset.ARROW_DOWN: {
            __privateMethod(this, _Select_instances, highlightNext_fn).call(this);
            break;
          }
          case kbdSubset.ARROW_UP: {
            __privateMethod(this, _Select_instances, highlightPrev_fn).call(this);
            break;
          }
          case kbdSubset.SPACE:
          case kbdSubset.ENTER: {
            if (!this.highlighted) break;
            this.select(this.highlighted);
            break;
          }
          case kbdSubset.ESCAPE: {
            this.open = false;
            tick().then(() => {
              var _a;
              (_a = document.getElementById(this.ids.trigger)) == null ? void 0 : _a.focus();
            });
            break;
          }
          default: {
            if (!letterRegex.test(e.key)) break;
            e.preventDefault();
            e.stopPropagation();
            const next = this.typeahead(e.key);
            if (next) this.highlighted = next.value;
          }
        }
      }
    });
  }
  getOptionId(value) {
    return `${this.ids.content}-option-${dataAttr(value)}`;
  }
  getOption(value, options) {
    return {
      [dataAttrs6.option]: "",
      "data-value": dataAttr(value),
      "data-typeahead": dataAttr(options == null ? void 0 : options.typeahead),
      "aria-hidden": this.open ? void 0 : true,
      "aria-selected": __privateGet(this, _value7).has(value),
      "data-highlighted": dataAttr(strict_equals(this.highlighted, value)),
      role: "option",
      onmouseover: () => {
        this.highlighted = value;
      },
      onclick: () => {
        this.select(value);
      }
    };
  }
  [ADD_OWNER](owner) {
    add_owner_to_class(this, owner, [
      () => get(__privateGet(this, _multiple4)),
      () => get(__privateGet(this, _scrollAlignment2)),
      () => get(__privateGet(this, _typeaheadTimeout)),
      () => get(__privateGet(this, _typeahead))
    ]);
  }
};
_props13 = new WeakMap();
_multiple4 = new WeakMap();
_scrollAlignment2 = new WeakMap();
_value7 = new WeakMap();
_highlighted2 = new WeakMap();
_typeaheadTimeout = new WeakMap();
_typeahead = new WeakMap();
_Select_instances = new WeakSet();
getOptionsEls_fn = function() {
  const contentEl = document.getElementById(this.ids.content);
  if (!contentEl) return [];
  return [
    ...contentEl.querySelectorAll(dataSelectors4.option)
  ].filter(isHtmlElement);
};
highlight_fn = function(el) {
  if (!el.dataset.value) return;
  this.highlighted = el.dataset.value;
  if (strict_equals(this.scrollAlignment, null, false)) {
    el.scrollIntoView({ block: this.scrollAlignment });
  }
};
highlightNext_fn = function() {
  const options = __privateMethod(this, _Select_instances, getOptionsEls_fn).call(this);
  const next = findNext(options, (o) => strict_equals(o.dataset.value, this.highlighted));
  if (isHtmlElement(next)) __privateMethod(this, _Select_instances, highlight_fn).call(this, next);
};
highlightPrev_fn = function() {
  const options = __privateMethod(this, _Select_instances, getOptionsEls_fn).call(this);
  const prev = findPrev(options, (o) => strict_equals(o.dataset.value, this.highlighted));
  if (isHtmlElement(prev)) __privateMethod(this, _Select_instances, highlight_fn).call(this, prev);
};
highlightFirst_fn = function() {
  const first2 = __privateMethod(this, _Select_instances, getOptionsEls_fn).call(this)[0];
  if (first2) __privateMethod(this, _Select_instances, highlight_fn).call(this, first2);
};
highlightLast_fn = function() {
  const last2 = __privateMethod(this, _Select_instances, getOptionsEls_fn).call(this).at(-1);
  if (last2) __privateMethod(this, _Select_instances, highlight_fn).call(this, last2);
};

// node_modules/.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/number.js
function clamp2(min2, value, max2) {
  return Math.max(min2, Math.min(value, max2));
}

// node_modules/.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/builders/Slider.svelte.js
var { createIds: createIds7, dataAttrs: dataAttrs7 } = createBuilderMetadata("slider", ["root", "thumb"]);
var _props14, _min, _max2, _orientation2, _step, _value8, _mouseDown, _dragging, _mouseDownAt, _Slider_instances, percentage_get, commit_fn, sharedProps_get;
var Slider = class {
  constructor(props = {}) {
    __privateAdd(this, _Slider_instances);
    /* Props */
    __privateAdd(this, _props14);
    __privateAdd(this, _min, user_derived(() => extract(__privateGet(this, _props14).min, 0)));
    __privateAdd(this, _max2, user_derived(() => extract(__privateGet(this, _props14).max, 100)));
    __privateAdd(this, _orientation2, user_derived(() => extract(__privateGet(this, _props14).orientation, "horizontal")));
    __privateAdd(this, _step, user_derived(() => extract(__privateGet(this, _props14).step, 1)));
    /* State */
    __privateAdd(this, _value8);
    __publicField(this, "ids", createIds7());
    __privateAdd(this, _mouseDown, false);
    __privateAdd(this, _dragging, false);
    __privateAdd(this, _mouseDownAt, null);
    __privateSet(this, _props14, props);
    __privateSet(this, _value8, new Synced({
      value: props.value,
      onChange: props.onValueChange,
      defaultValue: 0
    }));
  }
  get min() {
    return get(__privateGet(this, _min));
  }
  set min(value) {
    set(__privateGet(this, _min), value);
  }
  get max() {
    return get(__privateGet(this, _max2));
  }
  set max(value) {
    set(__privateGet(this, _max2), value);
  }
  get orientation() {
    return get(__privateGet(this, _orientation2));
  }
  set orientation(value) {
    set(__privateGet(this, _orientation2), value);
  }
  get step() {
    return get(__privateGet(this, _step));
  }
  set step(value) {
    set(__privateGet(this, _step), value);
  }
  /** The value of the slider. */
  get value() {
    return __privateGet(this, _value8).current;
  }
  set value(value) {
    __privateGet(this, _value8).current = clamp2(this.min, value, this.max);
  }
  /**
   * The root of the slider.
   * Any cursor interaction along this element will change the slider's values.
   **/
  get root() {
    useEventListener(() => window, "pointermove", (e) => {
      if (!__privateGet(this, _mouseDown)) return;
      __privateMethod(this, _Slider_instances, commit_fn).call(this, e);
    });
    useEventListener(() => window, "pointerup", () => {
      __privateSet(this, _mouseDown, false);
      __privateSet(this, _dragging, false);
    });
    return {
      "aria-valuenow": this.value,
      "aria-valuemin": this.min,
      "aria-valuemax": this.max,
      "aria-orientation": this.orientation,
      style: styleAttr({
        "--percentage": `${__privateGet(this, _Slider_instances, percentage_get) * 100}%`,
        "--percentage-inv": `${(1 - __privateGet(this, _Slider_instances, percentage_get)) * 100}%`,
        "touch-action": strict_equals(this.orientation, "vertical") ? "pan-x" : "pan-y"
      }),
      tabindex: 0,
      role: "slider",
      [dataAttrs7.root]: "",
      id: this.ids.root,
      onpointerdown: (e) => {
        var _a;
        __privateSet(this, _mouseDown, true);
        __privateSet(this, _mouseDownAt, e.timeStamp);
        __privateMethod(this, _Slider_instances, commit_fn).call(this, e);
        (_a = document.getElementById(this.ids.thumb)) == null ? void 0 : _a.focus();
      },
      onkeydown: (e) => {
        switch (e.key) {
          case "ArrowDown":
          case "ArrowLeft": {
            if (e.metaKey) this.value = this.min;
            else this.value -= this.step;
            break;
          }
          case "ArrowUp":
          case "ArrowRight": {
            if (e.metaKey) this.value = this.max;
            else this.value += this.step;
            break;
          }
          case "Home": {
            this.value = this.min;
            break;
          }
          case "End": {
            this.value = this.max;
            break;
          }
          default: {
            return;
          }
        }
        e.preventDefault();
      },
      ...__privateGet(this, _Slider_instances, sharedProps_get)
    };
  }
  /** The slider's thumb, positioned at the end of the range. */
  get thumb() {
    return {
      [dataAttrs7.thumb]: "",
      id: this.ids.thumb,
      tabindex: 0,
      ...__privateGet(this, _Slider_instances, sharedProps_get)
    };
  }
  [ADD_OWNER](owner) {
    add_owner_to_class(this, owner, [
      () => get(__privateGet(this, _min)),
      () => get(__privateGet(this, _max2)),
      () => get(__privateGet(this, _orientation2)),
      () => get(__privateGet(this, _step))
    ]);
  }
};
_props14 = new WeakMap();
_min = new WeakMap();
_max2 = new WeakMap();
_orientation2 = new WeakMap();
_step = new WeakMap();
_value8 = new WeakMap();
_mouseDown = new WeakMap();
_dragging = new WeakMap();
_mouseDownAt = new WeakMap();
_Slider_instances = new WeakSet();
percentage_get = function() {
  const v = (this.value - this.min) / (this.max - this.min);
  return strict_equals(this.orientation, "vertical") ? 1 - v : v;
};
commit_fn = function(e) {
  __privateSet(this, _dragging, strict_equals(typeof __privateGet(this, _mouseDownAt), "number") && e.timeStamp - __privateGet(this, _mouseDownAt) > 50);
  const el = document.getElementById(this.ids.root);
  if (!isHtmlElement(el)) return;
  e.preventDefault();
  const elRect = el.getBoundingClientRect();
  let percentage;
  if (strict_equals(this.orientation, "vertical")) {
    percentage = 1 - clamp2(0, e.clientY - elRect.top, elRect.height) / elRect.height;
  } else {
    percentage = clamp2(0, e.clientX - elRect.left, elRect.width) / elRect.width;
  }
  this.value = getValueFixedToStep(this.min + percentage * (this.max - this.min), this.step);
};
sharedProps_get = function() {
  return {
    "data-dragging": dataAttr(__privateGet(this, _dragging)),
    "data-value": dataAttr(this.value),
    "data-orientation": dataAttr(this.orientation)
  };
};
function getValueFixedToStep(value, step) {
  return Math.round(value / step) * step;
}

// node_modules/.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/builders/Tabs.svelte.js
var TRIGGER_KEYS = [
  "ArrowLeft",
  "ArrowRight",
  "ArrowUp",
  "ArrowDown",
  "Home",
  "End"
];
var identifiers3 = createDataIds("tabs", ["trigger", "content", "trigger-list"]);
var _value9, _id2, _props15, _selectWhenFocused2, _loop2, _orientation3, _Tabs_instances, getTriggerId_fn, getContentId_fn;
var Tabs = class {
  constructor(props) {
    __privateAdd(this, _Tabs_instances);
    __privateAdd(this, _value9);
    __privateAdd(this, _id2, nanoid());
    /* Props */
    __privateAdd(this, _props15);
    __privateAdd(this, _selectWhenFocused2, user_derived(() => extract(__privateGet(this, _props15).selectWhenFocused, true)));
    __privateAdd(this, _loop2, user_derived(() => extract(__privateGet(this, _props15).loop, true)));
    __privateAdd(this, _orientation3, user_derived(() => extract(__privateGet(this, _props15).orientation, "horizontal")));
    __privateSet(this, _props15, props);
    __privateSet(this, _value9, new Synced({
      value: props.value,
      onChange: props.onValueChange
    }));
  }
  get selectWhenFocused() {
    return get(__privateGet(this, _selectWhenFocused2));
  }
  set selectWhenFocused(value) {
    set(__privateGet(this, _selectWhenFocused2), value);
  }
  get loop() {
    return get(__privateGet(this, _loop2));
  }
  set loop(value) {
    set(__privateGet(this, _loop2), value);
  }
  get orientation() {
    return get(__privateGet(this, _orientation3));
  }
  set orientation(value) {
    set(__privateGet(this, _orientation3), value);
  }
  /** The current selected tab. */
  get value() {
    return __privateGet(this, _value9).current;
  }
  set value(value) {
    __privateGet(this, _value9).current = value;
  }
  /** The attributes for the list that contains the tab triggers. */
  get triggerList() {
    return {
      [identifiers3["trigger-list"]]: "",
      role: "tablist",
      "aria-orientation": this.orientation,
      "data-orientation": this.orientation
    };
  }
  /** Gets the attributes and listeners for a tab trigger. Requires an identifying tab value. */
  getTrigger(value) {
    return {
      [identifiers3.trigger]: value,
      "data-active": dataAttr(strict_equals(this.value, value)),
      tabindex: strict_equals(this.value, value) ? 0 : -1,
      role: "tab",
      "aria-selected": strict_equals(this.value, value),
      "aria-controls": __privateMethod(this, _Tabs_instances, getContentId_fn).call(this, value),
      "data-orientation": this.orientation,
      onclick: () => this.value = value,
      onkeydown: (e) => {
        const el = e.target;
        if (!TRIGGER_KEYS.includes(e.key) || !isHtmlElement(el)) {
          return;
        }
        e.preventDefault();
        const triggerList = el.closest(`[${identifiers3["trigger-list"]}]`);
        if (!triggerList) return;
        const triggers = [
          ...triggerList.querySelectorAll(`[${identifiers3.trigger}]`)
        ];
        const currIndex = triggers.indexOf(el);
        let next = el;
        const prevKey = strict_equals(this.orientation, "horizontal") ? "ArrowLeft" : "ArrowUp";
        const nextKey = strict_equals(this.orientation, "horizontal") ? "ArrowRight" : "ArrowDown";
        switch (e.key) {
          case prevKey: {
            next = this.loop ? triggers.at(currIndex - 1) : triggers.at(Math.max(currIndex - 1, 0));
            break;
          }
          case nextKey: {
            next = this.loop ? triggers.at((currIndex + 1) % triggers.length) : triggers.at(currIndex + 1);
            break;
          }
          case "Home": {
            next = triggers[0];
            break;
          }
          case "End": {
            next = triggers.at(-1);
            break;
          }
        }
        if (!isHtmlElement(next)) return;
        next.focus();
        if (this.selectWhenFocused) {
          this.value = next.getAttribute(identifiers3.trigger);
        }
      },
      id: __privateMethod(this, _Tabs_instances, getTriggerId_fn).call(this, value)
    };
  }
  /** Gets the attributes and listeners for the tabs contents. Requires an identifying tab value. */
  getContent(value) {
    return {
      [identifiers3.content]: "",
      hidden: strict_equals(this.value, value, false),
      "data-active": dataAttr(strict_equals(this.value, value)),
      role: "tabpanel",
      id: __privateMethod(this, _Tabs_instances, getContentId_fn).call(this, value),
      "aria-labelledby": __privateMethod(this, _Tabs_instances, getTriggerId_fn).call(this, value),
      "data-orientation": this.orientation
    };
  }
  [ADD_OWNER](owner) {
    add_owner_to_class(this, owner, [
      () => get(__privateGet(this, _selectWhenFocused2)),
      () => get(__privateGet(this, _loop2)),
      () => get(__privateGet(this, _orientation3))
    ]);
  }
};
_value9 = new WeakMap();
_id2 = new WeakMap();
_props15 = new WeakMap();
_selectWhenFocused2 = new WeakMap();
_loop2 = new WeakMap();
_orientation3 = new WeakMap();
_Tabs_instances = new WeakSet();
getTriggerId_fn = function(value) {
  return `${__privateGet(this, _id2)}-trigger-${value.replace(/\s/g, "_")}`;
};
getContentId_fn = function(value) {
  return `${__privateGet(this, _id2)}-content-${value.replace(/\s/g, "_")}`;
};

// node_modules/.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/animation-frames.svelte.js
var _callback, _previousTimestamp, _fps, _running, _AnimationFrames_instances, loop_fn;
var AnimationFrames = class {
  constructor(callback) {
    __privateAdd(this, _AnimationFrames_instances);
    __privateAdd(this, _callback);
    __privateAdd(this, _previousTimestamp, null);
    __publicField(this, "frame", null);
    __privateAdd(this, _fps, state(0));
    __privateAdd(this, _running, state(false));
    __privateSet(this, _callback, callback);
    this.start = this.start.bind(this);
    this.stop = this.stop.bind(this);
    this.toggle = this.toggle.bind(this);
    this.start();
  }
  start() {
    if (get(__privateGet(this, _running))) return;
    set(__privateGet(this, _running), true);
    __privateSet(this, _previousTimestamp, null);
    this.frame = window.requestAnimationFrame(__privateMethod(this, _AnimationFrames_instances, loop_fn).bind(this));
  }
  stop() {
    if (!get(__privateGet(this, _running))) return;
    set(__privateGet(this, _running), false);
    if (this.frame) window.cancelAnimationFrame(this.frame);
    this.frame = null;
  }
  toggle() {
    get(__privateGet(this, _running)) ? this.stop() : this.start();
  }
  get fps() {
    return !get(__privateGet(this, _running)) ? 0 : get(__privateGet(this, _fps));
  }
  get running() {
    return get(__privateGet(this, _running));
  }
};
_callback = new WeakMap();
_previousTimestamp = new WeakMap();
_fps = new WeakMap();
_running = new WeakMap();
_AnimationFrames_instances = new WeakSet();
loop_fn = function(timestamp) {
  if (!get(__privateGet(this, _running))) return;
  if (strict_equals(__privateGet(this, _previousTimestamp), null)) {
    __privateSet(this, _previousTimestamp, timestamp);
  }
  const delta = timestamp - __privateGet(this, _previousTimestamp);
  const fps = 1e3 / delta;
  set(__privateGet(this, _fps), fps);
  __privateSet(this, _previousTimestamp, timestamp);
  __privateGet(this, _callback).call(this, { delta, timestamp });
  this.frame = window.requestAnimationFrame(__privateMethod(this, _AnimationFrames_instances, loop_fn).bind(this));
};

// node_modules/.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/builders/Toaster.svelte.js
var toasterMeta = createBuilderMetadata("toaster", ["root"]);
var toastMeta = createBuilderMetadata("toaster-toast", ["content", "title", "description", "close"]);
var _props16, _closeDelay, _type2, _hover, _toastsMap, _toasts, _subscribers;
var Toaster = class {
  constructor(props = {}) {
    // Props
    __privateAdd(this, _props16);
    __publicField(this, "ids", toasterMeta.createIds());
    __privateAdd(this, _closeDelay, user_derived(() => extract(__privateGet(this, _props16).closeDelay, 5e3)));
    __privateAdd(this, _type2, user_derived(() => extract(__privateGet(this, _props16).type, "polite")));
    __privateAdd(this, _hover, user_derived(() => extract(__privateGet(this, _props16).hover, "pause")));
    // State
    __privateAdd(this, _toastsMap, new SvelteMap());
    __privateAdd(this, _toasts, user_derived(() => Array.from(__privateGet(this, _toastsMap).values())));
    __privateAdd(this, _subscribers, 0);
    /**
     * Adds a toast.
     */
    __publicField(this, "addToast", (props) => {
      const propsWithDefaults = {
        closeDelay: this.closeDelay,
        type: this.type,
        ...props
      };
      const id = window.crypto.randomUUID();
      const toast = new Toast({ toaster: this, id, ...propsWithDefaults });
      __privateGet(this, _toastsMap).set(id, toast);
      return toast;
    });
    /**
     * Removes the toast with the specified ID.
     * @param id The id of the toast.
     */
    __publicField(this, "removeToast", (id) => {
      const toast = __privateGet(this, _toastsMap).get(id);
      if (!toast) return;
      __privateGet(this, _toastsMap).delete(id);
      toast.cleanup();
    });
    /**
     * Updates a toast's data.
     * @param id The id of the toast.
     * @param data The updated data.
     */
    __publicField(this, "updateToast", (id, data) => {
      const toast = __privateGet(this, _toastsMap).get(id);
      if (!toast) return;
      toast.data = data;
    });
    __privateSet(this, _props16, props);
  }
  get closeDelay() {
    return get(__privateGet(this, _closeDelay));
  }
  set closeDelay(value) {
    set(__privateGet(this, _closeDelay), value);
  }
  get type() {
    return get(__privateGet(this, _type2));
  }
  set type(value) {
    set(__privateGet(this, _type2), value);
  }
  get hover() {
    return get(__privateGet(this, _hover));
  }
  set hover(value) {
    set(__privateGet(this, _hover), value);
  }
  get toasts() {
    return get(__privateGet(this, _toasts));
  }
  set toasts(value) {
    set(__privateGet(this, _toasts), value);
  }
  /**
   * Spread attributes for the container of the toasts.
   */
  get root() {
    if (effect_tracking()) {
      __privateWrapper(this, _subscribers)._++;
      user_effect(() => {
        return () => {
          __privateWrapper(this, _subscribers)._--;
        };
      });
      watch(() => __privateGet(this, _subscribers), (s) => {
        if (strict_equals(s, 1, false)) return;
        user_effect(() => {
          const el = document.getElementById(this.ids.root);
          if (!isHtmlElement(el)) return;
          if (!this.toasts.length) {
            safelyHidePopover(el);
            return;
          }
          safelyShowPopover(el);
        });
      });
    }
    return {
      [toasterMeta.dataAttrs.root]: "",
      id: this.ids.root,
      popover: "manual"
    };
  }
  [ADD_OWNER](owner) {
    add_owner_to_class(this, owner, [
      () => get(__privateGet(this, _closeDelay)),
      () => get(__privateGet(this, _type2)),
      () => get(__privateGet(this, _hover)),
      () => get(__privateGet(this, _toasts))
    ]);
  }
};
_props16 = new WeakMap();
_closeDelay = new WeakMap();
_type2 = new WeakMap();
_hover = new WeakMap();
_toastsMap = new WeakMap();
_toasts = new WeakMap();
_subscribers = new WeakMap();
var _props17, _toaster, _id3, _data, _closeDelay2, _type3, _frames, _timeElapsed, _percentage;
var Toast = class {
  constructor(props) {
    /** Props */
    __privateAdd(this, _props17);
    __privateAdd(this, _toaster, user_derived(() => __privateGet(this, _props17).toaster));
    __privateAdd(this, _id3, user_derived(() => __privateGet(this, _props17).id));
    __privateAdd(this, _data, state());
    __privateAdd(this, _closeDelay2, user_derived(() => __privateGet(this, _props17).closeDelay));
    __privateAdd(this, _type3, user_derived(() => __privateGet(this, _props17).type));
    /** State */
    __publicField(this, "ids", toastMeta.createIds());
    __publicField(this, "createdAt");
    __privateAdd(this, _frames);
    __privateAdd(this, _timeElapsed, state(0));
    __privateAdd(this, _percentage, user_derived(() => 100 * this.timeElapsed / this.closeDelay));
    /** Remove toast. */
    __publicField(this, "removeSelf", () => {
      this.toaster.removeToast(this.id);
    });
    /** @internal */
    __publicField(this, "cleanup", () => {
      var _a;
      (_a = __privateGet(this, _frames)) == null ? void 0 : _a.stop();
    });
    /** Pause toast timer. */
    __publicField(this, "pause", () => {
      var _a;
      (_a = __privateGet(this, _frames)) == null ? void 0 : _a.stop();
    });
    /** Reset toast timer. */
    __publicField(this, "reset", () => {
      var _a;
      this.timeElapsed = 0;
      (_a = __privateGet(this, _frames)) == null ? void 0 : _a.start();
    });
    /** Resume toast timer */
    __publicField(this, "resume", () => {
      var _a;
      (_a = __privateGet(this, _frames)) == null ? void 0 : _a.start();
    });
    __privateSet(this, _props17, props);
    this.data = props.data;
    this.createdAt = performance.now();
    if (!this.closeDelay) return;
    __privateSet(this, _frames, new AnimationFrames(({ delta }) => {
      this.timeElapsed += delta;
      if (this.timeElapsed > this.closeDelay) {
        this.removeSelf();
      }
    }));
  }
  get toaster() {
    return get(__privateGet(this, _toaster));
  }
  set toaster(value) {
    set(__privateGet(this, _toaster), value);
  }
  get id() {
    return get(__privateGet(this, _id3));
  }
  set id(value) {
    set(__privateGet(this, _id3), value);
  }
  get data() {
    return get(__privateGet(this, _data));
  }
  set data(value) {
    set(__privateGet(this, _data), value, true);
  }
  get closeDelay() {
    return get(__privateGet(this, _closeDelay2));
  }
  set closeDelay(value) {
    set(__privateGet(this, _closeDelay2), value);
  }
  get type() {
    return get(__privateGet(this, _type3));
  }
  set type(value) {
    set(__privateGet(this, _type3), value);
  }
  get timeElapsed() {
    return get(__privateGet(this, _timeElapsed));
  }
  set timeElapsed(value) {
    set(__privateGet(this, _timeElapsed), value, true);
  }
  get percentage() {
    return get(__privateGet(this, _percentage));
  }
  set percentage(value) {
    set(__privateGet(this, _percentage), value);
  }
  /**
   * Spread attributes for a toast's content (wrapper) element.
   */
  get content() {
    return {
      [toastMeta.dataAttrs.content]: "",
      id: this.ids.content,
      role: "alert",
      "aria-labelledby": this.ids.title,
      "aria-describedby": this.ids.description,
      "aria-live": this.type ?? this.toaster.type,
      tabindex: -1,
      onpointerenter: (e) => {
        if (isTouch(e)) return;
        if (strict_equals(this.toaster.hover, "pause")) {
          this.pause();
        } else if (strict_equals(this.toaster.hover, "pause-all")) {
          for (const toast of this.toaster.toasts) {
            toast.pause();
          }
        }
      },
      onpointerleave: (e) => {
        if (isTouch(e)) return;
        if (strict_equals(this.toaster.hover, "pause")) {
          this.resume();
        } else if (strict_equals(this.toaster.hover, "pause-all")) {
          for (const toast of this.toaster.toasts) {
            toast.resume();
          }
        }
      }
    };
  }
  /**
   * Spread attributes for a toast's title element.
   */
  get title() {
    return { id: this.ids.title };
  }
  /**
   * Soread attributes for a toast's description element.
   */
  get description() {
    return { id: this.ids.description };
  }
  /**
   * Spread attributes for a toast's close button element.
   */
  get close() {
    return {
      [toastMeta.dataAttrs.close]: "",
      onclick: () => {
        this.removeSelf();
      }
    };
  }
  [ADD_OWNER](owner) {
    add_owner_to_class(this, owner, [
      () => get(__privateGet(this, _toaster)),
      () => get(__privateGet(this, _id3)),
      () => get(__privateGet(this, _data)),
      () => get(__privateGet(this, _closeDelay2)),
      () => get(__privateGet(this, _type3)),
      () => get(__privateGet(this, _timeElapsed)),
      () => get(__privateGet(this, _percentage))
    ]);
  }
};
_props17 = new WeakMap();
_toaster = new WeakMap();
_id3 = new WeakMap();
_data = new WeakMap();
_closeDelay2 = new WeakMap();
_type3 = new WeakMap();
_frames = new WeakMap();
_timeElapsed = new WeakMap();
_percentage = new WeakMap();

// node_modules/.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/builders/Toggle.svelte.js
var identifiers4 = createDataIds("toggle", ["trigger", "hidden-input"]);
var _props18, _disabled6, _value10;
var Toggle = class {
  constructor(props = {}) {
    /* Props */
    __privateAdd(this, _props18);
    __privateAdd(this, _disabled6, user_derived(() => extract(__privateGet(this, _props18).disabled, false)));
    /* State */
    __privateAdd(this, _value10);
    __privateSet(this, _value10, new Synced({
      value: props.value,
      onChange: props.onValueChange,
      defaultValue: false
    }));
    __privateSet(this, _props18, props);
  }
  get disabled() {
    return get(__privateGet(this, _disabled6));
  }
  set disabled(value) {
    set(__privateGet(this, _disabled6), value);
  }
  get value() {
    return __privateGet(this, _value10).current;
  }
  set value(value) {
    __privateGet(this, _value10).current = value;
  }
  /** The trigger that toggles the value. */
  get trigger() {
    return {
      [identifiers4.trigger]: "",
      "data-checked": dataAttr(this.value),
      "aria-pressed": this.value,
      disabled: disabledAttr(this.disabled),
      onclick: () => {
        if (this.disabled) return;
        this.value = !this.value;
      }
    };
  }
  /** A hidden input field to use within forms. */
  get hiddenInput() {
    return {
      [identifiers4["hidden-input"]]: "",
      type: "hidden",
      value: this.value ? "on" : "off"
    };
  }
  [ADD_OWNER](owner) {
    add_owner_to_class(this, owner, [() => get(__privateGet(this, _disabled6))]);
  }
};
_props18 = new WeakMap();
_disabled6 = new WeakMap();
_value10 = new WeakMap();

// node_modules/.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/polygon/hull.js
function computeConvexHull(points) {
  const sortedPoints = [...points].sort(comparePoints);
  return computeConvexHullSorted(sortedPoints);
}
function computeConvexHullSorted(points) {
  if (points.length <= 1) {
    return [...points];
  }
  const topChain = [];
  for (const currentPoint of points) {
    while (topChain.length >= 2) {
      const p1 = topChain[topChain.length - 1];
      const p2 = topChain[topChain.length - 2];
      if (!p1 || !p2)
        break;
      const crossProduct = (p1.x - p2.x) * (currentPoint.y - p2.y) - (p1.y - p2.y) * (currentPoint.x - p2.x);
      if (crossProduct < 0)
        break;
      topChain.pop();
    }
    topChain.push(currentPoint);
  }
  if (topChain.length > 0) {
    topChain.pop();
  }
  const bottomChain = [];
  for (let i = points.length - 1; i >= 0; i--) {
    const currentPoint = points[i];
    if (!currentPoint)
      continue;
    while (bottomChain.length >= 2) {
      const p1 = bottomChain[bottomChain.length - 1];
      const p2 = bottomChain[bottomChain.length - 2];
      if (!p1 || !p2)
        break;
      if ((p1.x - p2.x) * (currentPoint.y - p2.y) - (p1.y - p2.y) * (currentPoint.x - p2.x) < 0)
        break;
      bottomChain.pop();
    }
    bottomChain.push(currentPoint);
  }
  if (bottomChain.length > 0) {
    bottomChain.pop();
  }
  if (topChain.length === 1 && bottomChain.length === 1) {
    const topPoint = topChain[0];
    const bottomPoint = bottomChain[0];
    if (topPoint && bottomPoint && topPoint.x === bottomPoint.x && topPoint.y === bottomPoint.y) {
      return topChain;
    }
  }
  return [...topChain, ...bottomChain];
}
function comparePoints(a, b) {
  if (a.x !== b.x) {
    return a.x < b.x ? -1 : 1;
  }
  if (a.y !== b.y) {
    return a.y < b.y ? -1 : 1;
  }
  return 0;
}

// node_modules/.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/polygon/index.js
function getPointsFromEl(el) {
  const rect = el.getBoundingClientRect();
  return [
    { x: rect.left, y: rect.top },
    // tl
    { x: rect.right, y: rect.top },
    // tr
    { x: rect.right, y: rect.bottom },
    // br
    { x: rect.left, y: rect.bottom }
    // bl
  ];
}
function pointInPolygon(point, polygon) {
  let inside = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const pi = polygon[i];
    const pj = polygon[j];
    if (!pi || !pj)
      continue;
    const xi = pi.x;
    const yi = pi.y;
    const xj = pj.x;
    const yj = pj.y;
    const intersect = yi > point.y !== yj > point.y && point.x < (xj - xi) * (point.y - yi) / (yj - yi) + xi;
    if (intersect)
      inside = !inside;
  }
  return inside;
}

// node_modules/.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/pointer.js
function isPointerInGraceArea(e, area) {
  if (!area)
    return false;
  return pointInPolygon({ x: e.clientX, y: e.clientY }, area);
}

// node_modules/.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/builders/Tooltip.svelte.js
var { createIds: createIds8, dataAttrs: dataAttrs8, dataSelectors: dataSelectors5 } = createBuilderMetadata("tooltip", ["trigger", "content", "arrow"]);
var _ids6, _props19, _closeOnPointerDown, _openDelay, _closeDelay3, _disableHoverableContent, _forceVisible2, _floatingConfig2, _isVisible, _open3, _openReason, _clickedTrigger, _isPointerInsideTrigger, _isPointerInsideContent, _isMouseInTooltipArea, _openTimeout, _closeTimeout, _floatingData, _Tooltip_instances, sharedProps_get2, openTooltip_fn, stopOpening_fn, closeTooltip_fn, handleScroll_fn;
var Tooltip = class {
  constructor(props = {}) {
    __privateAdd(this, _Tooltip_instances);
    __privateAdd(this, _ids6, createIds8());
    /** Props */
    __privateAdd(this, _props19);
    __privateAdd(this, _closeOnPointerDown, user_derived(() => extract(__privateGet(this, _props19).closeOnPointerDown, true)));
    __privateAdd(this, _openDelay, user_derived(() => extract(__privateGet(this, _props19).openDelay, 1e3)));
    __privateAdd(this, _closeDelay3, user_derived(() => extract(__privateGet(this, _props19).closeDelay, 0)));
    __privateAdd(this, _disableHoverableContent, user_derived(() => extract(__privateGet(this, _props19).disableHoverableContent, false)));
    __privateAdd(this, _forceVisible2, user_derived(() => extract(__privateGet(this, _props19).forceVisible, false)));
    __privateAdd(this, _floatingConfig2, user_derived(() => extract(__privateGet(this, _props19).floatingConfig)));
    __privateAdd(this, _isVisible, user_derived(() => this.open || this.forceVisible));
    __privateAdd(this, _open3);
    __privateAdd(this, _openReason, state(null));
    __privateAdd(this, _clickedTrigger, state(false));
    __privateAdd(this, _isPointerInsideTrigger, state(false));
    __privateAdd(this, _isPointerInsideContent, state(false));
    __privateAdd(this, _isMouseInTooltipArea, state(false));
    __privateAdd(this, _openTimeout, state(null));
    __privateAdd(this, _closeTimeout, state(null));
    __privateAdd(this, _floatingData, state());
    __privateSet(this, _open3, new Synced({
      value: props.open,
      onChange: props.onOpenChange,
      defaultValue: false
    }));
    __privateSet(this, _props19, props);
    watch(
      [
        () => this.open,
        () => get(__privateGet(this, _openReason))
      ],
      () => {
        if (!this.open || strict_equals(typeof document, "undefined")) return;
        return on(document, "mousemove", (e) => {
          const contentEl = document.getElementById(__privateGet(this, _ids6).content);
          const triggerEl = document.getElementById(__privateGet(this, _ids6).trigger);
          if (!contentEl || !triggerEl) {
            if (this.open) __privateMethod(this, _Tooltip_instances, closeTooltip_fn).call(this);
            return;
          }
          const polygon = this.graceAreaPolygon;
          set(__privateGet(this, _isMouseInTooltipArea), get(__privateGet(this, _isPointerInsideContent)) || get(__privateGet(this, _isPointerInsideTrigger)) || isPointerInGraceArea(e, polygon), true);
          if (strict_equals(get(__privateGet(this, _openReason)), "pointer", false)) return;
          if (!get(__privateGet(this, _isMouseInTooltipArea))) {
            __privateMethod(this, _Tooltip_instances, closeTooltip_fn).call(this);
          }
        });
      }
    );
  }
  get closeOnPointerDown() {
    return get(__privateGet(this, _closeOnPointerDown));
  }
  set closeOnPointerDown(value) {
    set(__privateGet(this, _closeOnPointerDown), value);
  }
  get openDelay() {
    return get(__privateGet(this, _openDelay));
  }
  set openDelay(value) {
    set(__privateGet(this, _openDelay), value);
  }
  get closeDelay() {
    return get(__privateGet(this, _closeDelay3));
  }
  set closeDelay(value) {
    set(__privateGet(this, _closeDelay3), value);
  }
  get disableHoverableContent() {
    return get(__privateGet(this, _disableHoverableContent));
  }
  set disableHoverableContent(value) {
    set(__privateGet(this, _disableHoverableContent), value);
  }
  get forceVisible() {
    return get(__privateGet(this, _forceVisible2));
  }
  set forceVisible(value) {
    set(__privateGet(this, _forceVisible2), value);
  }
  get floatingConfig() {
    return get(__privateGet(this, _floatingConfig2));
  }
  set floatingConfig(value) {
    set(__privateGet(this, _floatingConfig2), value);
  }
  get isVisible() {
    return get(__privateGet(this, _isVisible));
  }
  set isVisible(value) {
    set(__privateGet(this, _isVisible), value);
  }
  get graceAreaPolygon() {
    var _a;
    const contentEl = document.getElementById(__privateGet(this, _ids6).content);
    const triggerEl = document.getElementById(__privateGet(this, _ids6).trigger);
    if (!contentEl || !triggerEl) {
      return [];
    }
    const PADDING = 6;
    const [tl, tr, br, bl] = getPointsFromEl(triggerEl);
    const contentPoints = this.disableHoverableContent ? [] : getPointsFromEl(contentEl);
    const placement = (_a = get(__privateGet(this, _floatingData))) == null ? void 0 : _a.placement;
    const points = [...contentPoints];
    if (placement == null ? void 0 : placement.startsWith("top")) {
      points.push(tl, tr);
    } else if (placement == null ? void 0 : placement.startsWith("right")) {
      points.push(tr, br);
    } else if (placement == null ? void 0 : placement.startsWith("bottom")) {
      points.push(br, bl);
    } else {
      points.push(bl, tl);
    }
    const withPadding = points.reduce(
      (acc, point) => {
        return [
          ...acc,
          { x: point.x + PADDING, y: point.y + PADDING },
          { x: point.x + PADDING, y: point.y - PADDING },
          { x: point.x - PADDING, y: point.y + PADDING },
          { x: point.x - PADDING, y: point.y - PADDING }
        ];
      },
      []
    );
    return computeConvexHull(withPadding);
  }
  get open() {
    return __privateGet(this, _open3).current;
  }
  set open(value) {
    __privateGet(this, _open3).current = value;
  }
  get trigger() {
    user_effect(() => {
      const el = document.getElementById(__privateGet(this, _ids6).content);
      if (!isHtmlElement(el)) return;
      return () => set(__privateGet(this, _isPointerInsideTrigger), false);
    });
    return {
      [dataAttrs8.trigger]: "",
      id: __privateGet(this, _ids6).trigger,
      "aria-describedby": __privateGet(this, _ids6).content,
      "data-open": dataAttr(this.open),
      onpointerdown: () => {
        if (!this.closeOnPointerDown) return;
        this.open = false;
        set(__privateGet(this, _clickedTrigger), true);
        __privateMethod(this, _Tooltip_instances, stopOpening_fn).call(this);
      },
      onpointerenter: (e) => {
        set(__privateGet(this, _isPointerInsideTrigger), true);
        if (strict_equals(e.pointerType, "touch")) return;
        __privateMethod(this, _Tooltip_instances, openTooltip_fn).call(this, "pointer");
      },
      onpointermove: () => {
        set(__privateGet(this, _isPointerInsideTrigger), true);
      },
      onpointerleave: (e) => {
        set(__privateGet(this, _isPointerInsideTrigger), false);
        if (strict_equals(e.pointerType, "touch")) return;
        __privateMethod(this, _Tooltip_instances, stopOpening_fn).call(this);
      },
      onfocus: () => {
        if (get(__privateGet(this, _clickedTrigger))) return;
        __privateMethod(this, _Tooltip_instances, openTooltip_fn).call(this, "focus");
      },
      onblur: () => __privateMethod(this, _Tooltip_instances, closeTooltip_fn).call(this, true),
      ...__privateGet(this, _Tooltip_instances, sharedProps_get2)
    };
  }
  get content() {
    user_effect(() => {
      const triggerEl = document.getElementById(__privateGet(this, _ids6).trigger);
      const contentEl = document.getElementById(__privateGet(this, _ids6).content);
      if (!triggerEl || !contentEl || !this.open) return;
      useFloating({
        node: () => triggerEl,
        floating: () => contentEl,
        config: {
          ...this.floatingConfig,
          onCompute: ({ floatingApply, arrowApply, ...data }) => {
            var _a;
            set(__privateGet(this, _floatingData), data, true);
            if ((_a = this.floatingConfig) == null ? void 0 : _a.onCompute) {
              this.floatingConfig.onCompute({ floatingApply, arrowApply, ...data });
            } else {
              floatingApply();
              arrowApply();
            }
          }
        }
      });
    });
    user_effect(() => {
      const triggerEl = document.getElementById(__privateGet(this, _ids6).trigger);
      const contentEl = document.getElementById(__privateGet(this, _ids6).content);
      if (!triggerEl || !contentEl) return;
      if (!this.isVisible) {
        safelyHidePopover(contentEl);
        return () => set(__privateGet(this, _isPointerInsideContent), false);
      }
      const parent = isHtmlElement(contentEl.parentNode) ? contentEl.parentNode.closest(dataSelectors5.content) : void 0;
      if (!isHtmlElement(parent)) {
        safelyShowPopover(contentEl);
        return;
      }
      if (strict_equals(parent.dataset.open, void 0, false)) safelyShowPopover(contentEl);
      const toggleUnsub = addEventListener(parent, "toggle", async (e) => {
        await new Promise((r) => setTimeout(r));
        const isOpen = strict_equals(e.newState, "open");
        if (isOpen) {
          safelyShowPopover(contentEl);
        } else {
          safelyHidePopover(contentEl);
        }
      });
      const observer = new MutationObserver((mutations) => untrack(() => {
        var _a;
        const parent2 = (_a = mutations[0]) == null ? void 0 : _a.target;
        if (!isHtmlElement(parent2)) return;
        if (parent2.inert && this.open) {
          __privateMethod(this, _Tooltip_instances, closeTooltip_fn).call(this);
        }
      }));
      observer.observe(parent, { attributes: true });
      return () => {
        toggleUnsub();
        observer.disconnect();
      };
    });
    useEventListener(() => document, "scroll", (e) => __privateMethod(this, _Tooltip_instances, handleScroll_fn).call(this, e), { capture: true });
    useEventListener(() => document, "keydown", (e) => {
      const el = document.getElementById(__privateGet(this, _ids6).content);
      if (strict_equals(e.key, "Escape", false) || !this.open || !el) return;
      e.preventDefault();
      const openTooltips = [...el.querySelectorAll("[popover]")].filter((child) => {
        if (!isHtmlElement(child)) return false;
        if (child.matches(dataSelectors5.content)) return strict_equals(child.dataset.open, void 0, false);
        return child.matches(":popover-open");
      });
      if (openTooltips.length) return;
      __privateMethod(this, _Tooltip_instances, stopOpening_fn).call(this);
      setTimeout(() => this.open = false);
    });
    return {
      [dataAttrs8.content]: "",
      id: __privateGet(this, _ids6).content,
      popover: "manual",
      role: "tooltip",
      tabindex: -1,
      style: `overflow: visible;`,
      inert: !this.open,
      "data-open": dataAttr(this.open),
      onpointerenter: () => {
        set(__privateGet(this, _isPointerInsideContent), true);
        __privateMethod(this, _Tooltip_instances, openTooltip_fn).call(this, "pointer");
      },
      onpointerleave: () => {
        set(__privateGet(this, _isPointerInsideContent), false);
      },
      onpointerdown: () => __privateMethod(this, _Tooltip_instances, openTooltip_fn).call(this, "pointer"),
      ...__privateGet(this, _Tooltip_instances, sharedProps_get2)
    };
  }
  get arrow() {
    return {
      [dataAttrs8.arrow]: "",
      id: __privateGet(this, _ids6).arrow,
      "data-arrow": "",
      "aria-hidden": true,
      "data-open": dataAttr(this.open)
    };
  }
  [ADD_OWNER](owner) {
    add_owner_to_class(this, owner, [
      () => get(__privateGet(this, _closeOnPointerDown)),
      () => get(__privateGet(this, _openDelay)),
      () => get(__privateGet(this, _closeDelay3)),
      () => get(__privateGet(this, _disableHoverableContent)),
      () => get(__privateGet(this, _forceVisible2)),
      () => get(__privateGet(this, _floatingConfig2)),
      () => get(__privateGet(this, _isVisible))
    ]);
  }
};
_ids6 = new WeakMap();
_props19 = new WeakMap();
_closeOnPointerDown = new WeakMap();
_openDelay = new WeakMap();
_closeDelay3 = new WeakMap();
_disableHoverableContent = new WeakMap();
_forceVisible2 = new WeakMap();
_floatingConfig2 = new WeakMap();
_isVisible = new WeakMap();
_open3 = new WeakMap();
_openReason = new WeakMap();
_clickedTrigger = new WeakMap();
_isPointerInsideTrigger = new WeakMap();
_isPointerInsideContent = new WeakMap();
_isMouseInTooltipArea = new WeakMap();
_openTimeout = new WeakMap();
_closeTimeout = new WeakMap();
_floatingData = new WeakMap();
_Tooltip_instances = new WeakSet();
sharedProps_get2 = function() {
  return {
    onfocusout: async () => {
      await new Promise((r) => setTimeout(r));
      const contentEl = document.getElementById(__privateGet(this, _ids6).content);
      const triggerEl = document.getElementById(__privateGet(this, _ids6).trigger);
      if ((contentEl == null ? void 0 : contentEl.contains(document.activeElement)) || (triggerEl == null ? void 0 : triggerEl.contains(document.activeElement))) {
        return;
      }
      this.open = false;
    }
  };
};
openTooltip_fn = function(reason) {
  if (get(__privateGet(this, _closeTimeout))) {
    window.clearTimeout(get(__privateGet(this, _closeTimeout)));
    set(__privateGet(this, _closeTimeout), null);
  }
  if (!get(__privateGet(this, _openTimeout))) {
    set(
      __privateGet(this, _openTimeout),
      window.setTimeout(
        () => {
          this.open = true;
          set(__privateGet(this, _openReason), get(__privateGet(this, _openReason)) ?? reason, true);
          set(__privateGet(this, _openTimeout), null);
        },
        this.openDelay
      ),
      true
    );
  }
};
stopOpening_fn = function() {
  if (get(__privateGet(this, _openTimeout))) {
    window.clearTimeout(get(__privateGet(this, _openTimeout)));
    set(__privateGet(this, _openTimeout), null);
  }
};
closeTooltip_fn = function(isBlur) {
  const contentEl = document.getElementById(__privateGet(this, _ids6).content);
  if (!isHtmlElement(contentEl)) return;
  __privateMethod(this, _Tooltip_instances, stopOpening_fn).call(this);
  if (isBlur && get(__privateGet(this, _isMouseInTooltipArea))) {
    set(__privateGet(this, _openReason), "pointer");
    return;
  }
  if (!get(__privateGet(this, _closeTimeout))) {
    set(
      __privateGet(this, _closeTimeout),
      window.setTimeout(
        () => {
          this.open = false;
          set(__privateGet(this, _openReason), null);
          if (isBlur) set(__privateGet(this, _clickedTrigger), false);
          set(__privateGet(this, _closeTimeout), null);
        },
        this.closeDelay
      ),
      true
    );
  }
};
handleScroll_fn = function(e) {
  if (!this.open) return;
  const target = e.target;
  if (!(target instanceof Element) && !(target instanceof Document)) return;
  const triggerEl = document.getElementById(__privateGet(this, _ids6).trigger);
  if (triggerEl && target.contains(triggerEl) || this.open) {
    __privateMethod(this, _Tooltip_instances, closeTooltip_fn).call(this);
  }
};

// node_modules/.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/collection.js
var Collection = class {
  constructor(source, defaultValue) {
    __publicField(this, "source");
    __publicField(this, "defaultValue");
    this.source = source;
    this.defaultValue = defaultValue;
  }
  getIterable() {
    if (!this.source) {
      return this.defaultValue !== void 0 ? this.defaultValue : [];
    }
    return typeof this.source === "function" ? this.source() : this.source;
  }
  *[Symbol.iterator]() {
    const iterable = this.getIterable();
    if (iterable) {
      yield* iterable;
    }
  }
  *keys() {
    const iterable = this.getIterable();
    if (iterable) {
      let index = 0;
      for (const _ of iterable) {
        yield index++;
      }
    }
  }
  *values() {
    const iterable = this.getIterable();
    if (iterable) {
      yield* iterable;
    }
  }
  *entries() {
    const iterable = this.getIterable();
    if (iterable) {
      let index = 0;
      for (const value of iterable) {
        yield [index++, value];
      }
    }
  }
  toArray() {
    const iterable = this.getIterable();
    return iterable ? Array.from(iterable) : [];
  }
  toSet() {
    const iterable = this.getIterable();
    return new Set(iterable);
  }
  size() {
    const iterable = this.getIterable();
    if (!iterable)
      return 0;
    let count = 0;
    for (const _ of iterable) {
      count++;
    }
    return count;
  }
  isEmpty() {
    const iterable = this.getIterable();
    if (!iterable)
      return true;
    for (const _ of iterable) {
      return false;
    }
    return true;
  }
  first() {
    const iterable = this.getIterable();
    if (!iterable)
      return void 0;
    for (const value of iterable) {
      return value;
    }
    return void 0;
  }
  last() {
    const iterable = this.getIterable();
    if (!iterable)
      return void 0;
    let lastValue;
    for (const value of iterable) {
      lastValue = value;
    }
    return lastValue;
  }
  find(predicate) {
    const iterable = this.getIterable();
    if (!iterable)
      return void 0;
    for (const value of iterable) {
      if (predicate(value)) {
        return value;
      }
    }
    return void 0;
  }
  some(predicate) {
    const iterable = this.getIterable();
    if (!iterable)
      return false;
    for (const value of iterable) {
      if (predicate(value)) {
        return true;
      }
    }
    return false;
  }
  every(predicate) {
    const iterable = this.getIterable();
    if (!iterable)
      return true;
    for (const value of iterable) {
      if (!predicate(value)) {
        return false;
      }
    }
    return true;
  }
};

// node_modules/.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/platform.js
function isMac() {
  return /mac/i.test(navigator.platform);
}
function isControlOrMeta(event) {
  return isMac() ? event.metaKey : event.ctrlKey;
}

// node_modules/.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/builders/Tree.svelte.js
var identifiers5 = createDataIds("tree", ["root", "item", "group"]);
var _props20, _multiple5, _expandOnClick, _typeaheadTimeout2, _typeahead2, _selected2, _expanded, _id4;
var Tree = class {
  /**
   * Creates a new Tree instance
   * @param props - Configuration props for the tree
   */
  constructor(props) {
    __privateAdd(this, _props20);
    /** The items contained in the tree */
    __publicField(this, "collection");
    __privateAdd(this, _multiple5, user_derived(() => extract(__privateGet(this, _props20).multiple, false)));
    __privateAdd(this, _expandOnClick, user_derived(() => extract(__privateGet(this, _props20).expandOnClick, true)));
    __privateAdd(this, _typeaheadTimeout2, user_derived(() => extract(__privateGet(this, _props20).typeaheadTimeout, 500)));
    __privateAdd(this, _typeahead2, user_derived(() => createTypeahead({
      timeout: __privateGet(this, _props20).typeaheadTimeout,
      getItems: () => {
        const activeEl = document.activeElement;
        if (!isString(activeEl == null ? void 0 : activeEl.getAttribute(identifiers5.item))) return [];
        const visibleChildren = getAllChildren(this, true);
        return visibleChildren.reduce(
          (acc, curr) => {
            var _a;
            if (!((_a = curr.el) == null ? void 0 : _a.innerText)) return acc;
            return [
              ...acc,
              {
                child: curr,
                value: curr.el.innerText,
                current: strict_equals(curr.el.id, activeEl.id)
              }
            ];
          },
          []
        );
      }
    })));
    __privateAdd(this, _selected2);
    __privateAdd(this, _expanded);
    __privateAdd(this, _id4, crypto.randomUUID());
    __privateSet(this, _props20, props);
    this.collection = new Collection(props.items);
    __privateSet(this, _selected2, new SelectionState({
      value: props.selected,
      onChange: props.onSelectedChange,
      multiple: props.multiple
    }));
    __privateSet(this, _expanded, new SelectionState({
      value: props.expanded,
      onChange: props.onExpandedChange,
      multiple: true
    }));
  }
  get multiple() {
    return get(__privateGet(this, _multiple5));
  }
  set multiple(value) {
    set(__privateGet(this, _multiple5), value);
  }
  get expandOnClick() {
    return get(__privateGet(this, _expandOnClick));
  }
  set expandOnClick(value) {
    set(__privateGet(this, _expandOnClick), value);
  }
  get typeaheadTimeout() {
    return get(__privateGet(this, _typeaheadTimeout2));
  }
  set typeaheadTimeout(value) {
    set(__privateGet(this, _typeaheadTimeout2), value);
  }
  get typeahead() {
    return get(__privateGet(this, _typeahead2));
  }
  set typeahead(value) {
    set(__privateGet(this, _typeahead2), value);
  }
  get items() {
    return [...this.collection];
  }
  /**
   * Currently selected item(s)
   * For multiple selection, returns a Set of IDs
   * For single selection, returns a single ID or undefined
   */
  get selected() {
    return __privateGet(this, _selected2).current;
  }
  set selected(v) {
    __privateGet(this, _selected2).current = v;
  }
  /**
   * Set of currently expanded item IDs
   */
  get expanded() {
    return __privateGet(this, _expanded).current;
  }
  set expanded(v) {
    __privateGet(this, _expanded).current = v;
  }
  /**
   * Checks if an item is currently selected
   * @param id - ID of the item to check
   */
  isSelected(id) {
    return __privateGet(this, _selected2).has(id);
  }
  /**
   * Checks if an item is currently expanded
   * @param id - ID of the item to check
   */
  isExpanded(id) {
    return __privateGet(this, _expanded).has(id);
  }
  /**
   * Expands a specific item
   * @param id - ID of the item to expand
   */
  expand(id) {
    __privateGet(this, _expanded).add(id);
  }
  /**
   * Collapses a specific item
   * @param id - ID of the item to collapse
   */
  collapse(id) {
    __privateGet(this, _expanded).delete(id);
  }
  /**
   * Toggles the expanded state of an item
   * @param id - ID of the item to toggle
   */
  toggleExpand(id) {
    __privateGet(this, _expanded).toggle(id);
  }
  /**
   * Selects a specific item
   * @param id - ID of the item to select
   */
  select(id) {
    __privateGet(this, _selected2).add(id);
  }
  /**
   * Deselects a specific item
   * @param id - ID of the item to deselect
   */
  deselect(id) {
    __privateGet(this, _selected2).delete(id);
  }
  /**
   * Clears all current selections
   */
  clearSelection() {
    __privateGet(this, _selected2).clear();
  }
  /**
   * Toggles the selected state of an item
   * @param id - ID of the item to toggle
   */
  toggleSelect(id) {
    __privateGet(this, _selected2).toggle(id);
  }
  /**
   * Selects all visible items.
   * If all items are already selected, clears the selection.
   */
  selectAll() {
    const ids = getAllChildren(this, true).map((c) => c.id);
    const alreadySelected = ids.every((id) => __privateGet(this, _selected2).has(id));
    if (alreadySelected) {
      this.clearSelection();
    } else {
      __privateGet(this, _selected2).addAll(ids);
    }
  }
  /**
   * Gets the DOM ID for a specific tree item
   * @param id - ID of the item
   */
  getItemId(id) {
    return `melt-tree-${__privateGet(this, _id4)}-item--${id}`;
  }
  /**
   * Gets the DOM element for a specific tree item
   * @param id - ID of the item
   */
  getItemEl(id) {
    return document.getElementById(this.getItemId(id));
  }
  /**
   * Selects all items between the last selected item and the specified item
   * @param id - ID of the item to select until
   */
  selectUntil(id) {
    if (!__privateGet(this, _selected2).size()) return this.select(id);
    const allChildren = getAllChildren(this);
    const to = allChildren.find((c) => strict_equals(c.id, id));
    if (!to) return;
    const from = allChildren.find((c) => strict_equals(c.id, first(__privateGet(this, _selected2).toSet())));
    if (!from) return this.select(id);
    const fromIdx = allChildren.indexOf(from);
    const toIdx = allChildren.indexOf(to);
    const [start, end] = fromIdx < toIdx ? [from, to] : [to, from];
    let current = start;
    this.clearSelection();
    this.select(from.id);
    this.select(start.id);
    while (strict_equals(current.id, end.id, false) && current.next) {
      current = current.next;
      this.select(current.id);
    }
  }
  /**
   * Gets ARIA attributes for the root tree element
   */
  get root() {
    return { role: "tree", [identifiers5.root]: "" };
  }
  /**
   * ARIA attributes for group elements
   */
  get group() {
    return { role: "group", [identifiers5.group]: "" };
  }
  /**
   * Array of Child instances representing the top-level items
   */
  get children() {
    return [...this.collection].map((i) => new Child({
      tree: this,
      item: i,
      parent: this,
      selectedState: __privateGet(this, _selected2)
    }));
  }
  [ADD_OWNER](owner) {
    add_owner_to_class(this, owner, [
      () => get(__privateGet(this, _multiple5)),
      () => get(__privateGet(this, _expandOnClick)),
      () => get(__privateGet(this, _typeaheadTimeout2)),
      () => get(__privateGet(this, _typeahead2))
    ]);
  }
};
_props20 = new WeakMap();
_multiple5 = new WeakMap();
_expandOnClick = new WeakMap();
_typeaheadTimeout2 = new WeakMap();
_typeahead2 = new WeakMap();
_selected2 = new WeakMap();
_expanded = new WeakMap();
_id4 = new WeakMap();
function getAllChildren(treeOrChild, onlyVisible = false) {
  const children = !onlyVisible || treeOrChild instanceof Tree || treeOrChild.expanded ? treeOrChild.children : [];
  return (children == null ? void 0 : children.reduce(
    (acc, c) => {
      return [
        ...acc,
        c,
        ...getAllChildren(c, onlyVisible)
      ];
    },
    []
  )) || [];
}
var _props21, _tree, _selectedState, _item2, _elId, _id5, _parent, _selected3, _expanded2, _canExpand, _idx;
var _Child = class _Child {
  /**
   * Creates a new Child instance
   * @param props - Configuration props for the child
   */
  constructor(props) {
    __privateAdd(this, _props21);
    __privateAdd(this, _tree, user_derived(() => __privateGet(this, _props21).tree));
    __privateAdd(this, _selectedState, user_derived(() => __privateGet(this, _props21).selectedState));
    __privateAdd(this, _item2, user_derived(() => __privateGet(this, _props21).item));
    __privateAdd(this, _elId, user_derived(() => this.tree.getItemId(this.item.id)));
    __privateAdd(this, _id5, user_derived(() => this.item.id));
    __privateAdd(this, _parent, user_derived(() => __privateGet(this, _props21).parent));
    __privateAdd(this, _selected3, user_derived(() => this.tree.isSelected(this.id)));
    __privateAdd(this, _expanded2, user_derived(() => this.tree.isExpanded(this.id)));
    __privateAdd(this, _canExpand, user_derived(() => {
      var _a;
      return Boolean(this.item.children && ((_a = this.item.children) == null ? void 0 : _a.length) > 0);
    }));
    /** Collapses this item */
    __publicField(this, "collapse", () => this.tree.collapse(this.id));
    /** Expands this item */
    __publicField(this, "expand", () => this.tree.expand(this.id));
    /** Toggles the expanded state of this item */
    __publicField(this, "toggleExpand", () => this.tree.toggleExpand(this.id));
    /** Selects this item */
    __publicField(this, "select", () => this.tree.select(this.id));
    /** Deselects this item */
    __publicField(this, "deselect", () => this.tree.deselect(this.id));
    /** Toggles the selected state of this item */
    __publicField(this, "toggleSelect", () => this.tree.toggleSelect(this.id));
    /** Focuses this item's DOM element */
    __publicField(this, "focus", () => {
      var _a;
      return (_a = this.el) == null ? void 0 : _a.focus();
    });
    __privateAdd(this, _idx, user_derived(() => {
      var _a, _b;
      return ((_b = (_a = this.parent) == null ? void 0 : _a.children) == null ? void 0 : _b.findIndex((c) => strict_equals(c.id, this.id))) ?? -1;
    }));
    __privateSet(this, _props21, props);
  }
  get tree() {
    return get(__privateGet(this, _tree));
  }
  set tree(value) {
    set(__privateGet(this, _tree), value);
  }
  get selectedState() {
    return get(__privateGet(this, _selectedState));
  }
  set selectedState(value) {
    set(__privateGet(this, _selectedState), value);
  }
  get item() {
    return get(__privateGet(this, _item2));
  }
  set item(value) {
    set(__privateGet(this, _item2), value);
  }
  get elId() {
    return get(__privateGet(this, _elId));
  }
  set elId(value) {
    set(__privateGet(this, _elId), value);
  }
  get id() {
    return get(__privateGet(this, _id5));
  }
  set id(value) {
    set(__privateGet(this, _id5), value);
  }
  get parent() {
    return get(__privateGet(this, _parent));
  }
  set parent(value) {
    set(__privateGet(this, _parent), value);
  }
  /** The DOM element representing this item */
  get el() {
    return document.getElementById(this.elId);
  }
  get selected() {
    return get(__privateGet(this, _selected3));
  }
  set selected(value) {
    set(__privateGet(this, _selected3), value);
  }
  get expanded() {
    return get(__privateGet(this, _expanded2));
  }
  set expanded(value) {
    set(__privateGet(this, _expanded2), value);
  }
  get canExpand() {
    return get(__privateGet(this, _canExpand));
  }
  set canExpand(value) {
    set(__privateGet(this, _canExpand), value);
  }
  get idx() {
    return get(__privateGet(this, _idx));
  }
  set idx(value) {
    set(__privateGet(this, _idx), value);
  }
  /** Gets all sibling items */
  get siblings() {
    var _a;
    return ((_a = this.parent) == null ? void 0 : _a.children) ?? [];
  }
  /** Gets the previous sibling item */
  get previousSibling() {
    return this.siblings[this.idx - 1];
  }
  /** Gets the next sibling item */
  get nextSibling() {
    return this.siblings[this.idx + 1];
  }
  /** Gets the previous item in the tree (including parent/child relationships) */
  get previous() {
    let current = this.previousSibling;
    if (!current) return this.parent instanceof _Child ? this.parent : void 0;
    while (current == null ? void 0 : current.expanded) {
      current = last((current == null ? void 0 : current.children) ?? []);
    }
    return current;
  }
  /** Gets the next item in the tree (including parent/child relationships) */
  get next() {
    var _a;
    if (this.expanded) {
      return (_a = this.children) == null ? void 0 : _a[0];
    }
    if (this.nextSibling) {
      return this.nextSibling;
    }
    if (this.parent instanceof _Child) {
      let p = this.parent;
      while (p && !p.nextSibling) {
        if (p.parent instanceof Tree) break;
        p = p.parent;
      }
      return p == null ? void 0 : p.nextSibling;
    }
  }
  /** Gets the tabindex for this item's DOM element */
  get tabindex() {
    if (this.selectedState.size()) {
      return this.tree.isSelected(this.id) ? 0 : -1;
    }
    return this.parent instanceof Tree && strict_equals(this.idx, 0) ? 0 : -1;
  }
  /** Gets DOM and ARIA attributes for this item */
  get attrs() {
    return {
      id: this.elId,
      [identifiers5.item]: "",
      "data-selected": dataAttr(this.selected),
      tabindex: this.tabindex,
      role: "treeitem",
      onclick: (e) => {
        e.stopPropagation();
        if (!isControlOrMeta(e) && !e.shiftKey) this.tree.clearSelection();
        if (this.tree.expandOnClick && this.canExpand && (!this.tree.multiple || !isControlOrMeta(e) && !e.shiftKey)) {
          this.toggleExpand();
        }
        if (isControlOrMeta(e)) this.toggleSelect();
        else this.tree.select(this.id);
        if (e.shiftKey) this.tree.selectUntil(this.id);
        this.focus();
      },
      onkeydown: (e) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
        let shouldPrevent = true;
        switch (e.key) {
          case "ArrowLeft": {
            if (this.expanded) {
              this.collapse();
              break;
            }
            if (!(this.parent instanceof _Child)) return;
            (_a = this.parent) == null ? void 0 : _a.focus();
            break;
          }
          case "ArrowRight": {
            if (!this.canExpand) break;
            if (this.expanded) {
              (_c = (_b = this.children) == null ? void 0 : _b[0]) == null ? void 0 : _c.focus();
              break;
            }
            this.expand();
            break;
          }
          case "ArrowUp": {
            (_d = this.previous) == null ? void 0 : _d.focus();
            if (e.shiftKey) (_e = this.previous) == null ? void 0 : _e.toggleSelect();
            break;
          }
          case "ArrowDown": {
            (_f = this.next) == null ? void 0 : _f.focus();
            if (e.shiftKey) (_g = this.next) == null ? void 0 : _g.toggleSelect();
            break;
          }
          case " ": {
            if (!this.tree.multiple) break;
            if (e.shiftKey) {
              this.tree.selectUntil(this.id);
              break;
            }
            this.toggleSelect();
            break;
          }
          case "Enter": {
            this.tree.clearSelection();
            this.select();
            break;
          }
          case "Home": {
            (_h = first(getAllChildren(this.tree))) == null ? void 0 : _h.focus();
            break;
          }
          case "End": {
            (_i = last(getAllChildren(this.tree, true))) == null ? void 0 : _i.focus();
            break;
          }
          case "*": {
            this.siblings.forEach((s) => s.expand());
            break;
          }
          default: {
            if (letterRegex.test(e.key)) {
              if (e.ctrlKey) {
                if (strict_equals(e.key, "a")) {
                  this.tree.selectAll();
                }
                break;
              }
              const next = this.tree.typeahead(e.key);
              (_j = next == null ? void 0 : next.child.el) == null ? void 0 : _j.focus();
              break;
            }
            shouldPrevent = false;
          }
        }
        if (shouldPrevent) {
          e.preventDefault();
          e.stopPropagation();
        }
      }
    };
  }
  /** The item's sub-items, if any */
  get children() {
    var _a;
    return (_a = this.item.children) == null ? void 0 : _a.map((i) => new _Child({ ...__privateGet(this, _props21), item: i, parent: this }));
  }
  [ADD_OWNER](owner) {
    add_owner_to_class(this, owner, [
      () => get(__privateGet(this, _tree)),
      () => get(__privateGet(this, _selectedState)),
      () => get(__privateGet(this, _item2)),
      () => get(__privateGet(this, _elId)),
      () => get(__privateGet(this, _id5)),
      () => get(__privateGet(this, _parent)),
      () => get(__privateGet(this, _selected3)),
      () => get(__privateGet(this, _expanded2)),
      () => get(__privateGet(this, _canExpand)),
      () => get(__privateGet(this, _idx))
    ]);
  }
};
_props21 = new WeakMap();
_tree = new WeakMap();
_selectedState = new WeakMap();
_item2 = new WeakMap();
_elId = new WeakMap();
_id5 = new WeakMap();
_parent = new WeakMap();
_selected3 = new WeakMap();
_expanded2 = new WeakMap();
_canExpand = new WeakMap();
_idx = new WeakMap();
var Child = _Child;
export {
  Accordion,
  Avatar,
  BasePopover,
  Collapsible,
  Combobox,
  FileUpload,
  PinInput,
  Popover,
  Progress,
  RadioGroup,
  Select,
  Slider,
  Tabs,
  Toaster,
  Toggle,
  Tooltip,
  Tree,
  isCloseOnOutsideClickCheck
};
//# sourceMappingURL=melt_builders.js.map
