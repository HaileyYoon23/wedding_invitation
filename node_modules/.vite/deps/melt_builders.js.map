{
  "version": 3,
  "sources": ["../../.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/is.js", "../../.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/extract.js", "../../.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/iterator.js", "../../.pnpm/runed@0.23.4_svelte@5.25.6/node_modules/runed/dist/internal/configurable-globals.js", "../../.pnpm/runed@0.23.4_svelte@5.25.6/node_modules/runed/dist/internal/utils/dom.js", "../../.pnpm/runed@0.23.4_svelte@5.25.6/node_modules/runed/dist/utilities/active-element/active-element.svelte.js", "../../.pnpm/runed@0.23.4_svelte@5.25.6/node_modules/runed/dist/internal/utils/is.js", "../../.pnpm/runed@0.23.4_svelte@5.25.6/node_modules/runed/dist/utilities/extract/extract.svelte.js", "../../.pnpm/runed@0.23.4_svelte@5.25.6/node_modules/runed/dist/utilities/use-debounce/use-debounce.svelte.js", "../../.pnpm/runed@0.23.4_svelte@5.25.6/node_modules/runed/dist/utilities/watch/watch.svelte.js", "../../.pnpm/runed@0.23.4_svelte@5.25.6/node_modules/runed/dist/internal/utils/get.js", "../../.pnpm/runed@0.23.4_svelte@5.25.6/node_modules/runed/dist/utilities/use-event-listener/use-event-listener.svelte.js", "../../.pnpm/runed@0.23.4_svelte@5.25.6/node_modules/runed/dist/utilities/state-history/state-history.svelte.js", "../../.pnpm/runed@0.23.4_svelte@5.25.6/node_modules/runed/dist/utilities/is-focus-within/is-focus-within.svelte.js", "../../.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/selection-state.svelte.js", "../../.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/keyboard.js", "../../.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/attribute.js", "../../.pnpm/nanoid@5.1.5/node_modules/nanoid/url-alphabet/index.js", "../../.pnpm/nanoid@5.1.5/node_modules/nanoid/index.browser.js", "../../.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/object.js", "../../.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/identifiers.js", "../../.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/builders/Accordion.svelte.js", "../../.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/browser.js", "../../.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/builders/Avatar.svelte.js", "../../.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/Synced.svelte.js", "../../.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/builders/Collapsible.svelte.js", "../../.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/typeahead.svelte.js", "../../.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/event.js", "../../.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/merge.js", "../../.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/popover.js", "../../.pnpm/@floating-ui+utils@0.2.9/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs", "../../.pnpm/@floating-ui+core@1.6.9/node_modules/@floating-ui/core/dist/floating-ui.core.mjs", "../../.pnpm/@floating-ui+utils@0.2.9/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs", "../../.pnpm/@floating-ui+dom@1.6.13/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs", "../../.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/use-floating.svelte.js", "../../.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/builders/Popover.svelte.js", "../../.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/array.js", "../../.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/effect.svelte.js", "../../.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/builders/Combobox.svelte.js", "../../.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/file.js", "../../.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/builders/FileUpload.svelte.js", "../../.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/builders/PinInput.svelte.js", "../../.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/builders/Progress.svelte.js", "../../.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/builders/RadioGroup.svelte.js", "../../.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/builders/Select.svelte.js", "../../.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/number.js", "../../.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/builders/Slider.svelte.js", "../../.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/builders/Tabs.svelte.js", "../../.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/animation-frames.svelte.js", "../../.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/builders/Toaster.svelte.js", "../../.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/builders/Toggle.svelte.js", "../../.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/polygon/hull.js", "../../.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/polygon/index.js", "../../.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/pointer.js", "../../.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/builders/Tooltip.svelte.js", "../../.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/collection.js", "../../.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/utils/platform.js", "../../.pnpm/melt@0.28.2_@floating-ui+dom@1.6.13_svelte@5.25.6/node_modules/melt/dist/builders/Tree.svelte.js"],
  "sourcesContent": ["import { SvelteSet } from \"svelte/reactivity\";\nexport function isHtmlElement(element) {\n    return element instanceof HTMLElement;\n}\nexport function isElement(element) {\n    return element instanceof Element;\n}\nexport function isNode(element) {\n    return element instanceof Node;\n}\nexport function isFunction(value) {\n    return typeof value === \"function\";\n}\nexport function isGetter(value) {\n    return isFunction(value) && value.length === 0;\n}\nexport function isSvelteSet(value) {\n    return value instanceof SvelteSet;\n}\nexport function isIterable(value) {\n    return value !== null && typeof value === \"object\" && Symbol.iterator in value;\n}\nexport function isObject(value) {\n    return value !== null && typeof value === \"object\";\n}\nexport function isHtmlInputElement(element) {\n    return element instanceof HTMLInputElement;\n}\nexport function isString(value) {\n    return typeof value === \"string\";\n}\nexport function isTouch(event) {\n    return event.pointerType === \"touch\";\n}\n", "import { isGetter } from \"./is\";\n/**\n * Extracts the value from a getter or a value.\n * Optionally, a default value can be provided.\n */\nexport function extract(value, defaultValue) {\n    if (isGetter(value)) {\n        const getter = value;\n        const gotten = getter();\n        if (gotten === undefined)\n            return defaultValue;\n        return gotten;\n    }\n    if (value === undefined)\n        return defaultValue;\n    return value;\n}\n", "export function last(values) {\n    let result;\n    for (const value of values) {\n        result = value;\n    }\n    return result;\n}\nexport function first(values) {\n    let result;\n    for (const value of values) {\n        result = value;\n        break;\n    }\n    return result;\n}\nexport function forEach(values, callback) {\n    for (const value of values) {\n        callback(value);\n    }\n}\n", "import { BROWSER } from \"esm-env\";\nexport const defaultWindow = BROWSER && typeof window !== \"undefined\" ? window : undefined;\nexport const defaultDocument = BROWSER && typeof window !== \"undefined\" ? window.document : undefined;\nexport const defaultNavigator = BROWSER && typeof window !== \"undefined\" ? window.navigator : undefined;\nexport const defaultLocation = BROWSER && typeof window !== \"undefined\" ? window.location : undefined;\n", "import { defaultDocument } from \"../configurable-globals.js\";\n/**\n * Handles getting the active element in a document or shadow root.\n * If the active element is within a shadow root, it will traverse the shadow root\n * to find the active element.\n * If not, it will return the active element in the document.\n *\n * @param document A document or shadow root to get the active element from.\n * @returns The active element in the document or shadow root.\n */\nexport function getActiveElement(document) {\n    let activeElement = document.activeElement;\n    while (activeElement?.shadowRoot) {\n        const node = activeElement.shadowRoot.activeElement;\n        if (node === activeElement)\n            break;\n        else\n            activeElement = node;\n    }\n    return activeElement;\n}\n/**\n * Returns the owner document of a given element.\n *\n * @param node The element to get the owner document from.\n * @returns\n */\nexport function getOwnerDocument(node, fallback = defaultDocument) {\n    return node?.ownerDocument ?? fallback;\n}\n/**\n * Checks if an element is or is contained by another element.\n *\n * @param node The element to check if it or its descendants contain the target element.\n * @param target The element to check if it is contained by the node.\n * @returns\n */\nexport function isOrContainsTarget(node, target) {\n    return node === target || node.contains(target);\n}\n", "import { defaultWindow, } from \"../../internal/configurable-globals.js\";\nimport { getActiveElement } from \"../../internal/utils/dom.js\";\nimport { on } from \"svelte/events\";\nimport { createSubscriber } from \"svelte/reactivity\";\nexport class ActiveElement {\n    #document;\n    #subscribe;\n    constructor(options = {}) {\n        const { window = defaultWindow, document = window?.document } = options;\n        if (window === undefined)\n            return;\n        this.#document = document;\n        this.#subscribe = createSubscriber((update) => {\n            const cleanupFocusIn = on(window, \"focusin\", update);\n            const cleanupFocusOut = on(window, \"focusout\", update);\n            return () => {\n                cleanupFocusIn();\n                cleanupFocusOut();\n            };\n        });\n    }\n    get current() {\n        this.#subscribe?.();\n        if (!this.#document)\n            return null;\n        return getActiveElement(this.#document);\n    }\n}\n/**\n * An object holding a reactive value that is equal to `document.activeElement`.\n * It automatically listens for changes, keeping the reference up to date.\n *\n * If you wish to use a custom document or shadowRoot, you should use\n * [useActiveElement](https://runed.dev/docs/utilities/active-element) instead.\n *\n * @see {@link https://runed.dev/docs/utilities/active-element}\n */\nexport const activeElement = new ActiveElement();\n", "export function isFunction(value) {\n    return typeof value === \"function\";\n}\nexport function isObject(value) {\n    return value !== null && typeof value === \"object\";\n}\nexport function isElement(value) {\n    return value instanceof Element;\n}\n", "import { isFunction } from \"../../internal/utils/is.js\";\n/**\n * Extracts the value from a getter or a value.\n * Optionally, a default value can be provided.\n */\nexport function extract(value, defaultValue) {\n    if (isFunction(value)) {\n        const getter = value;\n        return getter() ?? defaultValue ?? getter();\n    }\n    return value ?? defaultValue ?? value;\n}\n", "/**\n * Function that takes a callback, and returns a debounced version of it.\n * When calling the debounced function, it will wait for the specified time\n * before calling the original callback. If the debounced function is called\n * again before the time has passed, the timer will be reset.\n *\n * You can await the debounced function to get the value when it is eventually\n * called.\n *\n * The second parameter is the time to wait before calling the original callback.\n * Alternatively, it can also be a getter function that returns the time to wait.\n *\n * @see {@link https://runed.dev/docs/utilities/use-debounce}\n *\n * @param callback The callback to call when the time has passed.\n * @param wait The length of time to wait in ms, defaults to 250.\n */\nexport function useDebounce(callback, wait = 250) {\n    let context = $state(null);\n    function debounced(...args) {\n        if (context) {\n            // Old context will be reused so callers awaiting the promise will get the\n            // new value\n            if (context.timeout) {\n                clearTimeout(context.timeout);\n            }\n        }\n        else {\n            // No old context, create a new one\n            let resolve;\n            let reject;\n            const promise = new Promise((res, rej) => {\n                resolve = res;\n                reject = rej;\n            });\n            context = {\n                timeout: null,\n                runner: null,\n                promise,\n                resolve: resolve,\n                reject: reject,\n            };\n        }\n        context.runner = async () => {\n            // Grab the context and reset it\n            // -> new debounced calls will create a new context\n            if (!context)\n                return;\n            const ctx = context;\n            context = null;\n            try {\n                ctx.resolve(await callback.apply(this, args));\n            }\n            catch (error) {\n                ctx.reject(error);\n            }\n        };\n        context.timeout = setTimeout(context.runner, typeof wait === \"function\" ? wait() : wait);\n        return context.promise;\n    }\n    debounced.cancel = async () => {\n        if (!context || context.timeout === null) {\n            // Wait one event loop to see if something triggered the debounced function\n            await new Promise((resolve) => setTimeout(resolve, 0));\n            if (!context || context.timeout === null)\n                return;\n        }\n        clearTimeout(context.timeout);\n        context.reject(\"Cancelled\");\n        context = null;\n    };\n    debounced.runScheduledNow = async () => {\n        if (!context || !context.timeout) {\n            // Wait one event loop to see if something triggered the debounced function\n            await new Promise((resolve) => setTimeout(resolve, 0));\n            if (!context || !context.timeout)\n                return;\n        }\n        clearTimeout(context.timeout);\n        context.timeout = null;\n        await context.runner?.();\n    };\n    Object.defineProperty(debounced, \"pending\", {\n        enumerable: true,\n        get() {\n            return !!context?.timeout;\n        },\n    });\n    return debounced;\n}\n", "import { untrack } from \"svelte\";\nfunction runEffect(flush, effect) {\n    switch (flush) {\n        case \"post\":\n            $effect(effect);\n            break;\n        case \"pre\":\n            $effect.pre(effect);\n            break;\n    }\n}\nfunction runWatcher(sources, flush, effect, options = {}) {\n    const { lazy = false } = options;\n    // Run the effect immediately if `lazy` is `false`.\n    let active = !lazy;\n    // On the first run, if the dependencies are an array, pass an empty array\n    // to the previous value instead of `undefined` to allow destructuring.\n    //\n    // watch(() => [a, b], ([a, b], [prevA, prevB]) => { ... });\n    let previousValues = Array.isArray(sources)\n        ? []\n        : undefined;\n    runEffect(flush, () => {\n        const values = Array.isArray(sources) ? sources.map((source) => source()) : sources();\n        if (!active) {\n            active = true;\n            previousValues = values;\n            return;\n        }\n        const cleanup = untrack(() => effect(values, previousValues));\n        previousValues = values;\n        return cleanup;\n    });\n}\nfunction runWatcherOnce(sources, flush, effect) {\n    const cleanupRoot = $effect.root(() => {\n        let stop = false;\n        runWatcher(sources, flush, (values, previousValues) => {\n            if (stop) {\n                cleanupRoot();\n                return;\n            }\n            // Since `lazy` is `true`, `previousValues` is always defined.\n            const cleanup = effect(values, previousValues);\n            stop = true;\n            return cleanup;\n        }, \n        // Running the effect immediately just once makes no sense at all.\n        // That's just `onMount` with extra steps.\n        { lazy: true });\n    });\n    $effect(() => {\n        return cleanupRoot;\n    });\n}\nexport function watch(sources, effect, options) {\n    runWatcher(sources, \"post\", effect, options);\n}\nfunction watchPre(sources, effect, options) {\n    runWatcher(sources, \"pre\", effect, options);\n}\nwatch.pre = watchPre;\nexport function watchOnce(source, effect) {\n    runWatcherOnce(source, \"post\", effect);\n}\nfunction watchOncePre(source, effect) {\n    runWatcherOnce(source, \"pre\", effect);\n}\nwatchOnce.pre = watchOncePre;\n", "import { isFunction } from \"./is.js\";\nexport function get(value) {\n    if (isFunction(value)) {\n        return value();\n    }\n    return value;\n}\n", "import { extract } from \"../extract/extract.svelte.js\";\nimport { on } from \"svelte/events\";\nexport function useEventListener(_target, _events, handler, options) {\n    $effect(() => {\n        const target = extract(_target);\n        const events = extract(_events);\n        if (target === undefined || target === null)\n            return;\n        if (Array.isArray(events)) {\n            for (const event of events) {\n                $effect(() => on(target, event, handler, options));\n            }\n        }\n        else {\n            return on(target, events, handler, options);\n        }\n    });\n}\n", "import { watch } from \"../watch/watch.svelte.js\";\nimport { get } from \"../../internal/utils/get.js\";\n/**\n * Tracks the change history of a value, providing undo and redo capabilities.\n *\n * @see {@link https://runed.dev/docs/utilities/state-history}\n */\nexport class StateHistory {\n    #redoStack = $state([]);\n    #ignoreUpdate = false;\n    #set;\n    log = $state([]);\n    canUndo = $derived(this.log.length > 1);\n    canRedo = $derived(this.#redoStack.length > 0);\n    constructor(value, set, options) {\n        this.#redoStack = [];\n        this.#set = set;\n        this.undo = this.undo.bind(this);\n        this.redo = this.redo.bind(this);\n        const addEvent = (event) => {\n            this.log.push(event);\n            const capacity$ = get(options?.capacity);\n            if (capacity$ && this.log.length > capacity$) {\n                this.log = this.log.slice(-capacity$);\n            }\n        };\n        watch(() => get(value), (v) => {\n            if (this.#ignoreUpdate) {\n                this.#ignoreUpdate = false;\n                return;\n            }\n            addEvent({ snapshot: v, timestamp: new Date().getTime() });\n            this.#redoStack = [];\n        });\n        watch(() => get(options?.capacity), (c) => {\n            if (!c)\n                return;\n            this.log = this.log.slice(-c);\n        });\n    }\n    undo() {\n        const [prev, curr] = this.log.slice(-2);\n        if (!curr || !prev)\n            return;\n        this.#ignoreUpdate = true;\n        this.#redoStack.push(curr);\n        this.log.pop();\n        this.#set(prev.snapshot);\n    }\n    redo() {\n        const nextEvent = this.#redoStack.pop();\n        if (!nextEvent)\n            return;\n        this.#ignoreUpdate = true;\n        this.log.push(nextEvent);\n        this.#set(nextEvent.snapshot);\n    }\n}\n", "import { ActiveElement, } from \"../active-element/active-element.svelte.js\";\nimport { extract } from \"../extract/extract.svelte.js\";\n/**\n * Tracks whether the focus is within a target element.\n * @see {@link https://runed.dev/docs/utilities/is-focus-within}\n */\nexport class IsFocusWithin {\n    #node;\n    #activeElement;\n    constructor(node, options = {}) {\n        this.#node = node;\n        this.#activeElement = new ActiveElement(options);\n    }\n    current = $derived.by(() => {\n        const node = extract(this.#node);\n        if (node == null)\n            return false;\n        return node.contains(this.#activeElement.current);\n    });\n}\n", "import { SvelteSet } from \"svelte/reactivity\";\nimport { extract } from \"./extract\";\nimport { first, forEach, last } from \"./iterator\";\nimport { isFunction, isIterable, isSvelteSet } from \"./is\";\nimport { watch } from \"runed\";\n/**\n * Converts a value or iterable to a SvelteSet\n * @template T - The type of values in the set\n * @param v - The value or iterable to convert\n * @returns A new SvelteSet containing the value(s)\n * @internal\n */\nfunction toSet(v) {\n    if (v === undefined)\n        return new SvelteSet();\n    if (isSvelteSet(v))\n        return v;\n    if (!isIterable(v))\n        return new SvelteSet([v]);\n    return new SvelteSet(v);\n}\n/**\n * Extracts a single value from a value or iterable\n * @template T - The type of the value\n * @param v - The value or iterable to extract from\n * @returns The single value or undefined\n * @internal\n */\nfunction toSingle(v) {\n    if (!isIterable(v) || v === undefined)\n        return v;\n    return last(v);\n}\n/**\n * Manages selection state with support for single or multiple selection\n * @template T - The type of values that can be selected (defaults to string)\n * @template Multiple - Boolean flag indicating if multiple selection is enabled (defaults to false)\n *\n * @example\n * ```ts\n * // Single string selection\n * const singleSelect = new SelectionState<string>();\n *\n * // Multiple string selection\n * const multiSelect = new SelectionState<string, true>({ multiple: true });\n *\n * // Custom type selection\n * interface User { id: number; name: string }\n * const userSelect = new SelectionState<User>();\n * ```\n */\nexport class SelectionState {\n    #props;\n    #internal_set = new SvelteSet();\n    isControlled = $derived(isSvelteSet(this.#props.value) || isFunction(this.#props.value));\n    isMultiple = $derived(extract(this.#props.multiple, false));\n    constructor(props) {\n        this.#props = props;\n        if (this.isControlled)\n            return;\n        if (!isIterable(props.value) && props.value !== undefined) {\n            this.#internal_set.add(props.value);\n        }\n        else if (isIterable(props.value)) {\n            forEach(props.value, (v) => this.#internal_set.add(v));\n        }\n        watch(() => this.isMultiple, (isMultiple) => {\n            if (isMultiple)\n                return;\n            const curr = this.current;\n            this.#internal_set.clear();\n            if (curr === undefined)\n                return;\n            this.#internal_set.add(curr);\n        }, {\n            lazy: true,\n        });\n    }\n    /**\n     * Gets the current selection value(s)\n     * @returns For multiple selection, returns a SvelteSet of values. For single selection, returns a single value or undefined.\n     */\n    get current() {\n        let value;\n        if (isFunction(this.#props.value)) {\n            value = this.#props.value();\n        }\n        else if (isSvelteSet(this.#props.value)) {\n            value = this.#props.value;\n        }\n        else {\n            value = this.#internal_set;\n        }\n        if (this.isMultiple) {\n            return toSet(value);\n        }\n        return toSingle(value);\n    }\n    /**\n     * Sets the current selection value(s)\n     * @param value - The new selection value(s)\n     */\n    set current(value) {\n        this.onChange(value);\n        if (this.isControlled)\n            return;\n        this.#internal_set.clear();\n        if (isSvelteSet(value)) {\n            value.forEach((v) => this.#internal_set.add(v));\n        }\n        else if (value !== undefined) {\n            this.#internal_set.add(value);\n        }\n    }\n    /**\n     * Manipulates the selection set through a callback\n     * @param cb - Callback function that receives the selection set for manipulation\n     * @internal\n     */\n    manipulate(cb) {\n        const set = this.isControlled ? toSet(this.current) : this.#internal_set;\n        cb(set);\n        const newValue = this.isMultiple ? set : toSingle(set);\n        this.onChange(newValue);\n    }\n    /**\n     * Triggers the onChange callback with the current selection\n     * @param value - The current selection value(s)\n     * @internal\n     */\n    onChange(value) {\n        if (!this.#props.onChange)\n            return;\n        this.#props.onChange(value);\n    }\n    /**\n     * Checks if an item is currently selected\n     * @param item - The item to check\n     * @returns True if the item is selected, false otherwise\n     */\n    has(item) {\n        return toSet(this.current).has(item);\n    }\n    /**\n     * Adds an item to the selection\n     * For single selection, this replaces the current selection\n     * For multiple selection, this adds to the current selection\n     * @param value - The item to add\n     */\n    add(value) {\n        this.manipulate((set) => {\n            if (!this.isMultiple) {\n                set.clear();\n            }\n            set.add(value);\n        });\n    }\n    /**\n     * Adds multiple items to the selection\n     * For single selection, only the first item is selected\n     * For multiple selection, all items are added to the selection\n     * @param items - The items to add\n     */\n    addAll(items) {\n        this.manipulate((set) => {\n            if (!this.isMultiple) {\n                set.clear();\n                set.add(first(items));\n            }\n            else {\n                forEach(items, (i) => set.add(i));\n            }\n        });\n    }\n    /**\n     * Removes an item from the selection\n     * @param value - The item to remove\n     */\n    delete(value) {\n        this.manipulate((set) => {\n            set.delete(value);\n        });\n    }\n    /**\n     * Removes multiple items from the selection\n     * @param items - The items to remove\n     */\n    deleteAll(items) {\n        this.manipulate((set) => forEach(items, set.delete));\n    }\n    /**\n     * Clears all selections\n     */\n    clear() {\n        this.manipulate((set) => set.clear());\n    }\n    /**\n     * Gets the number of selected items\n     * @returns The number of selected items\n     */\n    size() {\n        return toSet(this.current).size;\n    }\n    /**\n     * Toggles the selection state of an item\n     * If the item is selected, it will be deselected\n     * If the item is not selected, it will be selected\n     * @param item - The item to toggle\n     */\n    toggle(item) {\n        this.manipulate((set) => {\n            if (set.has(item)) {\n                set.delete(item);\n            }\n            else {\n                if (!this.isMultiple)\n                    set.clear();\n                set.add(item);\n            }\n        });\n    }\n    /**\n     * Converts the current selection to a SvelteSet\n     * @returns A SvelteSet containing the current selection\n     */\n    toSet() {\n        return toSet(this.current);\n    }\n    /**\n     * Converts the current selection to an array\n     * @returns An array containing the current selection\n     */\n    toArray() {\n        return Array.from(this.toSet());\n    }\n}\n", "/**\n * A constant object that maps commonly used keyboard keys to their corresponding string values.\n * This object can be used in other parts of the application to handle keyboard input and prevent\n * hard-coded strings throughout.\n */\nexport const kbd = {\n    ALT: \"Alt\",\n    ARROW_DOWN: \"ArrowDown\",\n    ARROW_LEFT: \"ArrowLeft\",\n    ARROW_RIGHT: \"ArrowRight\",\n    ARROW_UP: \"ArrowUp\",\n    BACKSPACE: \"Backspace\",\n    CAPS_LOCK: \"CapsLock\",\n    CONTROL: \"Control\",\n    DELETE: \"Delete\",\n    END: \"End\",\n    ENTER: \"Enter\",\n    ESCAPE: \"Escape\",\n    F1: \"F1\",\n    F10: \"F10\",\n    F11: \"F11\",\n    F12: \"F12\",\n    F2: \"F2\",\n    F3: \"F3\",\n    F4: \"F4\",\n    F5: \"F5\",\n    F6: \"F6\",\n    F7: \"F7\",\n    F8: \"F8\",\n    F9: \"F9\",\n    HOME: \"Home\",\n    META: \"Meta\",\n    PAGE_DOWN: \"PageDown\",\n    PAGE_UP: \"PageUp\",\n    SHIFT: \"Shift\",\n    SPACE: \" \",\n    TAB: \"Tab\",\n    CTRL: \"Control\",\n    ASTERISK: \"*\",\n    A: \"a\",\n    P: \"p\",\n};\n/** Key sets for navigation within lists, such as select, menu, and combobox. */\nexport const FIRST_KEYS = [kbd.ARROW_DOWN, kbd.PAGE_UP, kbd.HOME];\nexport const LAST_KEYS = [kbd.ARROW_UP, kbd.PAGE_DOWN, kbd.END];\nexport const FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];\nexport const SELECTION_KEYS = [kbd.ENTER, kbd.SPACE];\nexport const getNextKey = (dir = \"ltr\", orientation = \"horizontal\") => {\n    return {\n        horizontal: dir === \"rtl\" ? kbd.ARROW_LEFT : kbd.ARROW_RIGHT,\n        vertical: kbd.ARROW_DOWN,\n    }[orientation];\n};\nexport const getPrevKey = (dir = \"ltr\", orientation = \"horizontal\") => {\n    return {\n        horizontal: dir === \"rtl\" ? kbd.ARROW_RIGHT : kbd.ARROW_LEFT,\n        vertical: kbd.ARROW_UP,\n    }[orientation];\n};\nexport const getDirectionalKeys = (dir = \"ltr\", orientation = \"horizontal\") => {\n    return {\n        nextKey: getNextKey(dir, orientation),\n        prevKey: getPrevKey(dir, orientation),\n    };\n};\n", "export function dataAttr(value) {\n    return (value === true ? \"\" : value === false ? undefined : value);\n}\nexport function disabledAttr(value) {\n    return (value === true ? true : undefined);\n}\nexport function styleAttr(value) {\n    return Object.entries(value)\n        .map(([key, value]) => `${key}: ${value};`)\n        .join(\" \");\n}\n", "export const urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\n", "/* @ts-self-types=\"./index.d.ts\" */\nimport { urlAlphabet as scopedUrlAlphabet } from './url-alphabet/index.js'\nexport { urlAlphabet } from './url-alphabet/index.js'\nexport let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\nexport let customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << Math.log2(alphabet.length - 1)) - 1\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let j = step | 0\n      while (j--) {\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length >= size) return id\n      }\n    }\n  }\n}\nexport let customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size | 0, random)\nexport let nanoid = (size = 21) => {\n  let id = ''\n  let bytes = crypto.getRandomValues(new Uint8Array((size |= 0)))\n  while (size--) {\n    id += scopedUrlAlphabet[bytes[size] & 63]\n  }\n  return id\n}\n", "/** Strongly typed Object.keys */\nexport function keys(obj) {\n    return Object.keys(obj);\n}\nexport function omit(obj, ...keys) {\n    const result = {};\n    for (const key of Object.keys(obj)) {\n        if (!keys.includes(key)) {\n            result[key] = obj[key];\n        }\n    }\n    return result;\n}\nexport function pick(obj, ...keys) {\n    const result = {};\n    for (const key of keys) {\n        result[key] = obj[key];\n    }\n    return result;\n}\n", "import { nanoid } from \"nanoid\";\nimport { keys } from \"./object\";\n/**\n * @deprecated use `createBuilderMetaData` instead\n */\nexport function createDataIds(name, parts) {\n    return parts.reduce((acc, part) => {\n        acc[part] = `data-melt-${name}-${part}`;\n        return acc;\n    }, {});\n}\nexport function createIds(identifiers) {\n    const id = nanoid();\n    return Object.keys(identifiers).reduce((acc, key) => {\n        acc[key] = `${key}-${id}`;\n        return acc;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    }, {});\n}\nexport function createBuilderMetadata(name, parts) {\n    // TODO: clean this up\n    const dataAttrs = createDataIds(name, parts);\n    const dataSelectors = keys(dataAttrs).reduce((acc, key) => {\n        acc[key] = `[${dataAttrs[key]}]`;\n        return acc;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    }, {});\n    return {\n        dataAttrs,\n        dataSelectors,\n        createIds: () => createIds(dataAttrs),\n    };\n}\n", "import { SelectionState } from \"../utils/selection-state.svelte\";\nimport { kbd } from \"../utils/keyboard\";\nimport { extract } from \"../utils/extract\";\nimport { dataAttr, disabledAttr } from \"../utils/attribute\";\nimport { createBuilderMetadata } from \"../utils/identifiers\";\nimport { isHtmlElement } from \"../utils/is\";\nconst { dataAttrs, dataSelectors, createIds } = createBuilderMetadata(\"accordion\", [\n    \"root\",\n    \"item\",\n    \"trigger\",\n    \"heading\",\n    \"content\",\n]);\nexport class Accordion {\n    // Props\n    #props;\n    multiple = $derived(extract(this.#props.multiple, false));\n    disabled = $derived(extract(this.#props.disabled, false));\n    // State\n    #value;\n    #ids = createIds();\n    constructor(props = {}) {\n        this.#props = props;\n        this.#value = new SelectionState({\n            value: props.value,\n            onChange: props.onValueChange,\n            multiple: props.multiple,\n        });\n    }\n    get value() {\n        return this.#value.current;\n    }\n    set value(value) {\n        this.#value.current = value;\n    }\n    /**\n     * Spread attributes for the accordion root element.\n     */\n    get root() {\n        return {\n            [dataAttrs.root]: \"\",\n            id: this.#ids.root,\n        };\n    }\n    /**\n     * Returns an Item class with the necessary\n     * spread attributes for an accordion item.\n     * @param item\n     */\n    getItem(item) {\n        return new Item({\n            accordion: this,\n            item,\n            rootId: this.#ids.root,\n        });\n    }\n    /**\n     * Checks if an item is currently expanded.\n     * @param id - ID of the item to check.\n     */\n    isExpanded(id) {\n        return this.#value.has(id);\n    }\n    /**\n     * Expands a specific item.\n     * @param id - ID of the item to expand.\n     */\n    expand(id) {\n        this.#value.add(id);\n    }\n    /**\n     * Collapses a specific item.\n     * @param id - ID of the item to collapse.\n     */\n    collapse(id) {\n        this.#value.delete(id);\n    }\n    /**\n     * Toggles the expanded state of an item.\n     * @param id - ID of the item to toggle.\n     */\n    toggleExpanded(id) {\n        if (this.#value.has(id)) {\n            this.collapse(id);\n        }\n        else {\n            if (this.multiple) {\n                this.expand(id);\n            }\n            else {\n                this.#value.clear();\n                this.expand(id);\n            }\n        }\n    }\n}\nclass Item {\n    #props;\n    item = $derived(this.#props.item);\n    #accordion = $derived(this.#props.accordion);\n    #rootId = $derived(this.#props.rootId);\n    /** Check if this item is disabled. */\n    isDisabled = $derived(this.#accordion.disabled || this.item.disabled);\n    /** Check if this item is expanded. */\n    isExpanded = $derived(this.#accordion.isExpanded(this.item.id));\n    /** Expands this item. */\n    expand = () => this.#accordion.expand(this.item.id);\n    /** Collapses this item. */\n    collapse = () => this.#accordion.collapse(this.item.id);\n    /** Toggles the expanded state of this item. */\n    toggleExpanded = () => this.#accordion.toggleExpanded(this.item.id);\n    constructor(props) {\n        this.#props = props;\n    }\n    /**\n     * Attributes for an accordion heading element.\n     */\n    get heading() {\n        return {\n            [dataAttrs.heading]: \"\",\n            role: \"heading\",\n            \"aria-level\": this.item.headingLevel,\n            \"data-heading-level\": this.item.headingLevel,\n        };\n    }\n    /**\n     * Attributes for an accordion item trigger.\n     */\n    get trigger() {\n        return {\n            [dataAttrs.trigger]: \"\",\n            disabled: disabledAttr(this.isDisabled),\n            \"aria-disabled\": this.isDisabled,\n            \"aria-expanded\": this.isExpanded,\n            \"data-disabled\": dataAttr(this.isDisabled),\n            \"data-value\": this.item.id,\n            \"data-state\": this.isExpanded ? \"open\" : \"closed\",\n            onclick: () => this.toggleExpanded(),\n            onkeydown: (e) => {\n                const key = e.key;\n                if (![kbd.ARROW_DOWN, kbd.ARROW_UP, kbd.HOME, kbd.END].includes(key)) {\n                    return;\n                }\n                e.preventDefault();\n                if (key === kbd.SPACE || key === kbd.ENTER) {\n                    if (this.isDisabled)\n                        return;\n                    this.toggleExpanded();\n                }\n                const el = e.target;\n                const rootEl = document.getElementById(this.#rootId);\n                if (!rootEl || !isHtmlElement(el))\n                    return;\n                const items = Array.from(rootEl.querySelectorAll(dataSelectors.trigger));\n                const candidateItems = items.filter((item) => {\n                    if (!isHtmlElement(item))\n                        return false;\n                    return !(\"disabled\" in item.dataset);\n                });\n                if (!candidateItems.length)\n                    return;\n                const elIdx = candidateItems.indexOf(el);\n                if (e.key === kbd.ARROW_DOWN) {\n                    candidateItems[(elIdx + 1) % candidateItems.length]?.focus();\n                }\n                if (e.key === kbd.ARROW_UP) {\n                    candidateItems[(elIdx - 1 + candidateItems.length) % candidateItems.length]?.focus();\n                }\n                if (e.key === kbd.HOME) {\n                    candidateItems[0]?.focus();\n                }\n                if (e.key === kbd.END) {\n                    candidateItems[candidateItems.length - 1]?.focus();\n                }\n            },\n        };\n    }\n    /**\n     * Attributes for an accordion content element.\n     */\n    get content() {\n        return {\n            [dataAttrs.content]: \"\",\n            \"data-state\": this.isExpanded ? \"open\" : \"closed\",\n            \"data-disabled\": disabledAttr(this.isDisabled),\n            \"data-value\": this.item.id,\n        };\n    }\n}\n", "export function inBrowser() {\n    return typeof window !== \"undefined\";\n}\n", "import { extract } from \"../utils/extract\";\nimport { createDataIds } from \"../utils/identifiers\";\nimport { styleAttr } from \"../utils/attribute\";\nimport { inBrowser } from \"../utils/browser\";\nimport { watch } from \"runed\";\nconst identifiers = createDataIds(\"avatar\", [\"image\", \"fallback\"]);\nexport class Avatar {\n    /* Props */\n    #props;\n    src = $derived(extract(this.#props.src, \"\"));\n    delayMs = $derived(extract(this.#props.delayMs, 0));\n    /* State */\n    #loadingStatus = $state(\"loading\");\n    constructor(props = {}) {\n        $effect(() => {\n            this.#props.onLoadingStatusChange?.(this.#loadingStatus);\n        });\n        watch(() => this.src, () => {\n            this.#loadingStatus = \"loading\";\n        });\n        this.#props = props;\n    }\n    get loadingStatus() {\n        return this.#loadingStatus;\n    }\n    get image() {\n        return {\n            [identifiers.image]: \"\",\n            src: this.src,\n            style: styleAttr({ display: this.#loadingStatus === \"loaded\" ? \"block\" : \"none\" }),\n            onload: () => {\n                if (!inBrowser())\n                    return;\n                const timerId = window.setTimeout(() => {\n                    this.#loadingStatus = \"loaded\";\n                }, this.delayMs);\n                return () => window.clearTimeout(timerId);\n            },\n            onerror: () => {\n                this.#loadingStatus = \"error\";\n            },\n        };\n    }\n    get fallback() {\n        return {\n            [identifiers.fallback]: \"\",\n            style: this.#loadingStatus === \"loaded\" ? styleAttr({ display: \"none\" }) : undefined,\n            hidden: this.#loadingStatus === \"loaded\" ? true : undefined,\n        };\n    }\n}\n", "import { extract } from \"./utils/extract\";\nimport { isFunction } from \"./utils/is\";\n/**\n * Setting `current` calls the `onChange` callback with the new value.\n *\n * If the value arg is static, it will be used as the default value,\n * and subsequent sets will set an internal state that gets read as `current`.\n *\n * Otherwise, if it is a getter, it will be called every time `current` is read,\n * and no internal state is used.\n */\nexport class Synced {\n    #internalValue = $state();\n    #valueArg;\n    #onChange;\n    #defaultValue;\n    constructor({ value, onChange, ...args }) {\n        this.#valueArg = value;\n        this.#onChange = onChange;\n        this.#defaultValue = \"defaultValue\" in args ? args?.defaultValue : undefined;\n        this.#internalValue = extract(value, this.#defaultValue);\n    }\n    get current() {\n        return isFunction(this.#valueArg)\n            ? this.#valueArg() ?? this.#defaultValue ?? this.#internalValue\n            : this.#internalValue;\n    }\n    set current(value) {\n        if (this.current === value)\n            return;\n        if (isFunction(this.#valueArg)) {\n            this.#onChange?.(value);\n            return;\n        }\n        this.#internalValue = value;\n        this.#onChange?.(value);\n    }\n}\n", "import { extract } from \"../utils/extract\";\nimport { Synced } from \"../Synced.svelte\";\nimport { dataAttr } from \"../utils/attribute\";\nimport { createBuilderMetadata } from \"../utils/identifiers\";\nconst { dataAttrs, createIds } = createBuilderMetadata(\"collapsible\", [\n    \"trigger\",\n    \"content\",\n]);\nexport class Collapsible {\n    // Props\n    #props;\n    disabled = $derived(extract(this.#props.disabled, false));\n    // State\n    #open;\n    #ids = createIds();\n    constructor(props = {}) {\n        this.#props = props;\n        this.#open = new Synced({\n            value: props.open,\n            onChange: props.onOpenChange,\n            defaultValue: false,\n        });\n    }\n    /**\n     * The open state of the collapsible.\n     */\n    get open() {\n        return this.#open.current;\n    }\n    set open(open) {\n        this.#open.current = open;\n    }\n    get #sharedAttrs() {\n        return {\n            \"data-state\": this.open ? \"open\" : \"closed\",\n            \"data-disabled\": dataAttr(this.disabled),\n        };\n    }\n    /**\n     * The spread attributes for the trigger button.\n     */\n    get trigger() {\n        return {\n            [dataAttrs.trigger]: \"\",\n            id: this.#ids.trigger,\n            \"aria-expanded\": this.open,\n            \"aria-controls\": this.#ids.content,\n            ...this.#sharedAttrs,\n            disabled: this.disabled,\n            onclick: () => {\n                if (this.disabled)\n                    return;\n                this.#open.current = !this.#open.current;\n            },\n        };\n    }\n    /**\n     * The spread attributes for the content element.\n     */\n    get content() {\n        return {\n            [dataAttrs.content]: \"\",\n            id: this.#ids.content,\n            ...this.#sharedAttrs,\n        };\n    }\n}\n", "import { useDebounce } from \"runed\";\nimport { extract } from \"./extract\";\nexport const letterRegex = /^[a-zA-Z]$/;\nexport function createTypeahead(args) {\n    let value = $state(\"\");\n    const timeout = $derived(extract(args.timeout, 500));\n    const debounceClear = useDebounce(() => {\n        value = \"\";\n    }, () => timeout);\n    function typeahead(letter) {\n        if (!letterRegex.test(letter))\n            return;\n        debounceClear();\n        value += letter.toLowerCase();\n        const isStartingTypeahead = value.length === 1;\n        const items = args.getItems();\n        const index = items.findIndex((item) => item.current);\n        const itemsForTypeahead = items\n            .filter((item) => {\n            const searchValue = item.typeahead ?? item.value;\n            return searchValue.toLowerCase().startsWith(value);\n        })\n            .map((item) => ({ item, index: items.indexOf(item) }));\n        if (!itemsForTypeahead.length)\n            return;\n        // In case you're starting the typeahead, a different element than the first one should be focused.\n        // Otherwise, if the current element matches the typed string, don't change.\n        const next = itemsForTypeahead.find((item) => {\n            if (isStartingTypeahead)\n                return item.index > index;\n            return item.index >= index;\n        }) ?? itemsForTypeahead[0];\n        return next?.item;\n    }\n    return typeahead;\n}\n", "export function addEventListener(target, event, handler, options) {\n    const events = Array.isArray(event) ? event : [event];\n    for (const event of events) {\n        target.addEventListener(event, handler, options);\n    }\n    return () => {\n        for (const event of events) {\n            target.removeEventListener(event, handler, options);\n        }\n    };\n}\n", "function isPlainObject(value) {\n    return value !== null\n        && typeof value === 'object'\n        && Object.getPrototypeOf(value) === Object.prototype;\n}\nexport function deepMerge(target, source) {\n    const result = { ...target };\n    for (const key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n            const sourceValue = source[key];\n            const targetValue = result[key];\n            // Handle arrays - merge them\n            if (Array.isArray(sourceValue)) {\n                result[key] = Array.isArray(targetValue)\n                    ? [...targetValue, ...sourceValue]\n                    : [...sourceValue];\n                continue;\n            }\n            // Handle plain objects (not null, not arrays, not class instances)\n            if (isPlainObject(sourceValue)) {\n                result[key] = Object.prototype.hasOwnProperty.call(result, key)\n                    && isPlainObject(result[key])\n                    ? deepMerge(result[key], sourceValue)\n                    : deepMerge({}, sourceValue);\n                continue;\n            }\n            // Handle primitives and everything else\n            result[key] = sourceValue;\n        }\n    }\n    return result;\n}\n", "/**\n * For some god-forsaken stupid reason, hidePopover throws an error\n * if the element is already hidden, and then breaks the entire app.\n * This avoids that.\n */\nexport function safelyHidePopover(el) {\n    try {\n        el.hidePopover();\n    }\n    catch {\n        // do nothing as god intended\n    }\n}\n/**\n * showPopover is equally stupid.\n */\nexport function safelyShowPopover(el) {\n    try {\n        el.showPopover();\n    }\n    catch {\n        // do nothing as god intended\n    }\n}\n", "/**\n * Custom positioning reference element.\n * @see https://floating-ui.com/docs/virtual-elements\n */\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nfunction getSideAxis(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nfunction getSideList(side, isStart, rtl) {\n  const lr = ['left', 'right'];\n  const rl = ['right', 'left'];\n  const tb = ['top', 'bottom'];\n  const bt = ['bottom', 'top'];\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rl : lr;\n      return isStart ? lr : rl;\n    case 'left':\n    case 'right':\n      return isStart ? tb : bt;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect;\n  return {\n    width,\n    height,\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height,\n    x,\n    y\n  };\n}\n\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\n", "import { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\nexport { rectToClientRect } from '@floating-ui/utils';\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    x,\n    y,\n    width: rects.floating.width,\n    height: rects.floating.height\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = clamp(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset,\n        ...(shouldAddOffset && {\n          alignmentOffset\n        })\n      },\n      reset: shouldAddOffset\n    };\n  }\n});\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = getSide(placement);\n      const initialSideAxis = getSideAxis(initialPlacement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== 'none';\n      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle.\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$filter2;\n                const placement = (_overflowsData$filter2 = overflowsData.filter(d => {\n                  if (hasFallbackAxisSideDirection) {\n                    const currentSideAxis = getSideAxis(d.placement);\n                    return currentSideAxis === initialSideAxis ||\n                    // Create a bias to the `y` side axis due to horizontal\n                    // reading directions favoring greater width.\n                    currentSideAxis === 'y';\n                  }\n                  return true;\n                }).map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = evaluate(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getPaddingObject(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getSideAxis(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\n\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === 'y';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: rawValue.mainAxis || 0,\n    crossAxis: rawValue.crossAxis || 0,\n    alignmentAxis: rawValue.alignmentAxis\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      var _middlewareData$offse, _middlewareData$arrow;\n      const {\n        x,\n        y,\n        placement,\n        middlewareData\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n\n      // If the placement is the same and the arrow caused an alignment offset\n      // then we don't need to change the positioning coordinates.\n      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: {\n          ...diffCoords,\n          placement\n        }\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y,\n          enabled: {\n            [mainAxis]: checkMainAxis,\n            [crossAxis]: checkCrossAxis\n          }\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element \n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      var _state$middlewareData, _state$middlewareData2;\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const maximumClippingHeight = height - overflow.top - overflow.bottom;\n      const maximumClippingWidth = width - overflow.left - overflow.right;\n      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);\n      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {\n        availableWidth = maximumClippingWidth;\n      }\n      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {\n        availableHeight = maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\n", "function hasWindow() {\n  return typeof window !== 'undefined';\n}\nfunction getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  if (!hasWindow() || typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isTopLayer(element) {\n  return [':popover-open', ':modal'].some(selector => {\n    try {\n      return element.matches(selector);\n    } catch (e) {\n      return false;\n    }\n  });\n}\nfunction isContainingBlock(elementOrCss) {\n  const webkit = isWebKit();\n  const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  // https://drafts.csswg.org/css-transforms-2/#individual-transforms\n  return ['transform', 'translate', 'scale', 'rotate', 'perspective'].some(value => css[value] ? css[value] !== 'none' : false) || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'translate', 'scale', 'rotate', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else if (isTopLayer(currentNode)) {\n      return null;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.scrollX,\n    scrollTop: element.scrollY\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    const frameElement = getFrameElement(win);\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\nfunction getFrameElement(win) {\n  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;\n}\n\nexport { getComputedStyle, getContainingBlock, getDocumentElement, getFrameElement, getNearestOverflowAncestor, getNodeName, getNodeScroll, getOverflowAncestors, getParentNode, getWindow, isContainingBlock, isElement, isHTMLElement, isLastTraversableNode, isNode, isOverflowElement, isShadowRoot, isTableElement, isTopLayer, isWebKit };\n", "import { rectToClientRect, detectOverflow as detectOverflow$1, offset as offset$1, autoPlacement as autoPlacement$1, shift as shift$1, flip as flip$1, size as size$1, hide as hide$1, arrow as arrow$1, inline as inline$1, limitShift as limitShift$1, computePosition as computePosition$1 } from '@floating-ui/core';\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\nimport { getComputedStyle, isHTMLElement, isElement, getWindow, isWebKit, getFrameElement, getNodeScroll, getDocumentElement, isTopLayer, getNodeName, isOverflowElement, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentWin = win;\n    let currentIFrame = getFrameElement(currentWin);\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentWin = getWindow(currentIFrame);\n      currentIFrame = getFrameElement(currentWin);\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\n// If <html> has a CSS width greater than the viewport, then this will be\n// incorrect for RTL.\nfunction getWindowScrollBarX(element, rect) {\n  const leftScroll = getNodeScroll(element).scrollLeft;\n  if (!rect) {\n    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;\n  }\n  return rect.left + leftScroll;\n}\n\nfunction getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {\n  if (ignoreScrollbarX === void 0) {\n    ignoreScrollbarX = false;\n  }\n  const htmlRect = documentElement.getBoundingClientRect();\n  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 :\n  // RTL <body> scrollbar.\n  getWindowScrollBarX(documentElement, htmlRect));\n  const y = htmlRect.top + scroll.scrollTop;\n  return {\n    x,\n    y\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isFixed = strategy === 'fixed';\n  const documentElement = getDocumentElement(offsetParent);\n  const topLayer = elements ? isTopLayer(elements.floating) : false;\n  if (offsetParent === documentElement || topLayer && isFixed) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y,\n      width: clippingAncestor.width,\n      height: clippingAncestor.height\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  const {\n    width,\n    height\n  } = getCssDimensions(element);\n  return {\n    width,\n    height\n  };\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      // If the <body> scrollbar appears on the left (e.g. RTL systems). Use\n      // Firefox with layout.scrollbar.side = 3 in about:config to test this.\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);\n  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;\n  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;\n  return {\n    x,\n    y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction isStaticPositioned(element) {\n  return getComputedStyle(element).position === 'static';\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  let rawOffsetParent = element.offsetParent;\n\n  // Firefox returns the <html> element as the offsetParent if it's non-static,\n  // while Chrome and Safari return the <body> element. The <body> element must\n  // be used to perform the correct calculations even if the <html> element is\n  // non-static.\n  if (getDocumentElement(element) === rawOffsetParent) {\n    rawOffsetParent = rawOffsetParent.ownerDocument.body;\n  }\n  return rawOffsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const win = getWindow(element);\n  if (isTopLayer(element)) {\n    return win;\n  }\n  if (!isHTMLElement(element)) {\n    let svgOffsetParent = getParentNode(element);\n    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {\n      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {\n        return svgOffsetParent;\n      }\n      svgOffsetParent = getParentNode(svgOffsetParent);\n    }\n    return win;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {\n    return win;\n  }\n  return offsetParent || getContainingBlock(element) || win;\n}\n\nconst getElementRects = async function (data) {\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  const floatingDimensions = await getDimensionsFn(data.floating);\n  return {\n    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      width: floatingDimensions.width,\n      height: floatingDimensions.height\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\n\nfunction rectsAreEqual(a, b) {\n  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;\n}\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    var _io;\n    clearTimeout(timeoutId);\n    (_io = io) == null || _io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const elementRectForRootMargin = element.getBoundingClientRect();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = elementRectForRootMargin;\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          // If the reference is clipped, the ratio is 0. Throttle the refresh\n          // to prevent an infinite loop of updates.\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 1000);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {\n        // It's possible that even though the ratio is reported as 1, the\n        // element is not actually fully within the IntersectionObserver's root\n        // area anymore. This can happen under performance constraints. This may\n        // be a bug in the browser's IntersectionObserver implementation. To\n        // work around this, we compare the element's bounding rect now with\n        // what it was at the time we created the IntersectionObserver. If they\n        // are not equal then the element moved, so we refresh.\n        refresh();\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          var _resizeObserver;\n          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _resizeObserver2;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo == null || cleanupIo();\n    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nconst detectOverflow = detectOverflow$1;\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = offset$1;\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = autoPlacement$1;\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = shift$1;\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = flip$1;\n\n/**\n * Provides data that allows you to change the size of the floating element \n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = size$1;\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = hide$1;\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = arrow$1;\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = inline$1;\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = limitShift$1;\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { arrow, autoPlacement, autoUpdate, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, platform, shift, size };\n", "import { arrow, offset, flip, shift, computePosition, autoUpdate, size, } from \"@floating-ui/dom\";\nimport { isFunction, isHtmlElement } from \"./is\";\nimport { deepMerge } from \"./merge\";\nimport { extract } from \"./extract\";\nimport { getters } from \"./getters.svelte\";\nconst ARROW_TRANSFORM = {\n    bottom: \"rotate(45deg)\",\n    left: \"rotate(135deg)\",\n    top: \"rotate(225deg)\",\n    right: \"rotate(315deg)\",\n};\nexport function useFloating(args) {\n    const nodeEl = $derived(extract(args.node));\n    const floatingEl = $derived(extract(args.floating));\n    const config = $derived(extract(args.config, {}));\n    let data = $state();\n    const compute = () => {\n        const arrowEl = floatingEl.querySelector(\"[data-arrow]\");\n        const arrowOffset = isHtmlElement(arrowEl) ? arrowEl.offsetHeight / 2 : 0;\n        const arrowMiddleware = isHtmlElement(arrowEl)\n            ? arrow({ element: arrowEl, ...config.arrow })\n            : undefined;\n        const baseOptions = {\n            middleware: [\n                shift(config.shift),\n                flip(config.flip),\n                arrowMiddleware,\n                offset(typeof config.offset === \"number\"\n                    ? config.offset\n                    : { mainAxis: 8 + arrowOffset, ...config.offset }),\n                config.sameWidth\n                    ? size({\n                        apply({ rects, elements }) {\n                            Object.assign(elements.floating?.style ?? {}, {\n                                width: `${rects.reference.width}px`,\n                                minWidth: `${rects.reference.width}px`,\n                            });\n                        },\n                    })\n                    : undefined,\n            ],\n        };\n        computePosition(nodeEl, floatingEl, deepMerge(baseOptions, config.computePosition ?? {})).then((returned) => {\n            data = returned;\n            const { x, y, placement, middlewareData, strategy } = returned;\n            const floatingApply = (el = floatingEl) => {\n                const transformOriginMap = {\n                    top: \"bottom center\",\n                    \"top-start\": \"bottom left\",\n                    \"top-end\": \"bottom right\",\n                    bottom: \"top center\",\n                    \"bottom-start\": \"top left\",\n                    \"bottom-end\": \"top right\",\n                    left: \"center center\",\n                    \"left-start\": \"top left\",\n                    \"left-end\": \"bottom left\",\n                    right: \"center center\",\n                    \"right-start\": \"top right\",\n                    \"right-end\": \"bottom right\",\n                };\n                Object.assign(el.style, {\n                    position: strategy,\n                    left: `${x}px`,\n                    top: `${y}px`,\n                });\n                const [side, align = \"center\"] = placement.split(\"-\");\n                el.style.transformOrigin = transformOriginMap[placement];\n                el.dataset.side = side;\n                el.dataset.align = align;\n            };\n            const arrowApply = (el = undefined) => {\n                const actualEl = el ?? arrowEl;\n                if (!isHtmlElement(actualEl) || !middlewareData.arrow)\n                    return;\n                const { x, y } = middlewareData.arrow;\n                const dir = placement.split(\"-\")[0];\n                Object.assign(actualEl.style, {\n                    position: \"absolute\",\n                    left: x ? `${x}px` : \"\",\n                    top: y ? `${y}px` : \"\",\n                    [dir]: `calc(100% - ${arrowOffset}px)`,\n                    transform: ARROW_TRANSFORM[dir],\n                    backgroundColor: \"inherit\",\n                    zIndex: \"inherit\",\n                });\n                actualEl.dataset.side = dir;\n            };\n            if (isFunction(config.onCompute)) {\n                config.onCompute({ ...returned, arrowApply, floatingApply });\n            }\n            else {\n                floatingApply();\n                arrowApply();\n            }\n        });\n    };\n    $effect(() => {\n        return autoUpdate(nodeEl, floatingEl, compute);\n    });\n    return {\n        get data() {\n            return data;\n        },\n    };\n}\n", "import { Synced } from \"../Synced.svelte\";\nimport { dataAttr } from \"../utils/attribute\";\nimport { addEventListener } from \"../utils/event\";\nimport { extract } from \"../utils/extract\";\nimport { createBuilderMetadata } from \"../utils/identifiers\";\nimport { isFunction, isHtmlElement } from \"../utils/is\";\nimport { deepMerge } from \"../utils/merge\";\nimport { safelyHidePopover, safelyShowPopover } from \"../utils/popover\";\nimport { useFloating, } from \"../utils/use-floating.svelte\";\nimport { nanoid } from \"nanoid\";\nimport { useEventListener } from \"runed\";\nconst { dataAttrs, dataSelectors } = createBuilderMetadata(\"popover\", [\n    \"trigger\",\n    \"content\",\n    \"arrow\",\n]);\nexport const isCloseOnOutsideClickCheck = (value) => isFunction(value) && value.length === 1;\nexport class BasePopover {\n    ids = $state({ invoker: nanoid(), popover: nanoid() });\n    /* Props */\n    #props;\n    forceVisible = $derived(extract(this.#props.forceVisible, false));\n    closeOnEscape = $derived(extract(this.#props.closeOnEscape, true));\n    sameWidth = $derived(extract(this.#props.sameWidth, false));\n    closeOnOutsideClick = $derived(extract(this.#props.closeOnOutsideClick, true));\n    floatingConfig = $derived.by(() => {\n        const config = extract(this.#props.floatingConfig, {});\n        const sameWidth = extract(this.#props.sameWidth);\n        const merged = deepMerge(config, sameWidth !== undefined ? { sameWidth } : {});\n        return merged;\n    });\n    /* State */\n    #open;\n    constructor(props = {}) {\n        this.#open = new Synced({\n            value: props.open,\n            onChange: props.onOpenChange,\n            defaultValue: false,\n        });\n        this.#props = props;\n    }\n    get open() {\n        return this.#open.current;\n    }\n    set open(value) {\n        this.#open.current = value;\n    }\n    #shouldClose(el) {\n        if (this.closeOnOutsideClick === false)\n            return false;\n        if (isFunction(this.closeOnOutsideClick)) {\n            return isCloseOnOutsideClickCheck(this.closeOnOutsideClick)\n                ? this.closeOnOutsideClick(el) // Pass target if it's the correct type\n                : this.closeOnOutsideClick(); // Otherwise, call without arguments\n        }\n        return true;\n    }\n    get sharedProps() {\n        return {\n            onfocusout: async () => {\n                await new Promise((r) => setTimeout(r));\n                const contentEl = document.getElementById(this.ids.popover);\n                const triggerEl = document.getElementById(this.ids.invoker);\n                const activeEl = document.activeElement;\n                if (!activeEl ||\n                    contentEl?.contains(activeEl) ||\n                    triggerEl?.contains(activeEl) ||\n                    !this.#shouldClose(activeEl) // Hack, we should probably have a focusOut prop\n                ) {\n                    return;\n                }\n                this.open = false;\n            },\n        };\n    }\n    /** The trigger that toggles the value. */\n    getInvoker() {\n        return {\n            id: this.ids.invoker,\n            popovertarget: this.ids.popover,\n            onclick: (e) => {\n                e.preventDefault();\n                this.open = !this.open;\n            },\n            ...this.sharedProps,\n        };\n    }\n    getPopover() {\n        // Show and hide popover based on open state\n        $effect(() => {\n            const el = document.getElementById(this.ids.popover);\n            if (!isHtmlElement(el)) {\n                return;\n            }\n            if (this.open || this.forceVisible) {\n                // Check if there's a parent popover. If so, only open if the parent's open.\n                // This is to guarantee correct layering.\n                const parent = isHtmlElement(el.parentNode)\n                    ? el.parentNode.closest(dataSelectors.content)\n                    : undefined;\n                if (!isHtmlElement(parent)) {\n                    safelyShowPopover(el);\n                    return;\n                }\n                if (parent.dataset.open !== undefined)\n                    safelyShowPopover(el);\n                return addEventListener(parent, \"toggle\", async (e) => {\n                    await new Promise((r) => setTimeout(r));\n                    const isOpen = e.newState === \"open\";\n                    if (isOpen) {\n                        safelyShowPopover(el);\n                    }\n                    else {\n                        safelyHidePopover(el);\n                    }\n                });\n            }\n            else {\n                safelyHidePopover(el);\n            }\n        });\n        $effect(() => {\n            const contentEl = document.getElementById(this.ids.popover);\n            const triggerEl = document.getElementById(this.ids.invoker);\n            if (!isHtmlElement(contentEl) || !isHtmlElement(triggerEl) || !this.open) {\n                return;\n            }\n            useFloating({\n                node: () => triggerEl,\n                floating: () => contentEl,\n                config: () => this.floatingConfig,\n            });\n        });\n        useEventListener(() => document, \"keydown\", (e) => {\n            if (!this.closeOnEscape)\n                return;\n            const el = document.getElementById(this.ids.popover);\n            if (e.key !== \"Escape\" || !this.open || !isHtmlElement(el))\n                return;\n            e.preventDefault();\n            const openPopovers = [...el.querySelectorAll(\"[popover]\")].filter((child) => {\n                if (!isHtmlElement(child))\n                    return false;\n                // If child is a Melt popover, check if it's open\n                if (child.matches(dataSelectors.content))\n                    return child.dataset.open !== undefined;\n                return child.matches(\":popover-open\");\n            });\n            if (openPopovers.length)\n                return;\n            // Set timeout to give time to all event listeners to run\n            setTimeout(() => (this.open = false));\n        });\n        useEventListener(() => document, \"click\", (e) => {\n            if (!this.open)\n                return; // Exit early if not open\n            const contentEl = document.getElementById(this.ids.popover);\n            const triggerEl = document.getElementById(this.ids.invoker);\n            if (!contentEl || !triggerEl)\n                return; // Exit if elements are missing\n            const target = e.target;\n            const isInsideContent = contentEl.contains(target);\n            const isInsideTrigger = triggerEl.contains(target);\n            if (isInsideContent || isInsideTrigger)\n                return; // Exit if clicked inside\n            if (this.#shouldClose(target))\n                this.open = false;\n        });\n        return {\n            id: this.ids.popover,\n            popover: \"manual\",\n            ontoggle: (e) => {\n                const newOpen = e.newState === \"open\";\n                if (this.open !== newOpen && newOpen === false) {\n                    this.open = newOpen;\n                }\n            },\n            // Needed so it receives focus on click, but not on tab, because of focus out\n            tabindex: -1,\n            inert: !this.open,\n            \"data-open\": dataAttr(this.open),\n            ...this.sharedProps,\n        };\n    }\n    get arrow() {\n        return {\n            [dataAttrs.arrow]: \"\",\n            \"data-arrow\": \"\",\n            \"aria-hidden\": true,\n            \"data-open\": dataAttr(this.open),\n        };\n    }\n}\nexport class Popover extends BasePopover {\n    constructor(props = {}) {\n        super({ ...props });\n        this.ids = { ...this.ids, trigger: this.ids.invoker, content: this.ids.popover };\n    }\n    /** The trigger that toggles the value. */\n    get trigger() {\n        return Object.assign(this.getInvoker(), {\n            [dataAttrs.trigger]: \"\",\n        });\n    }\n    get content() {\n        return Object.assign(this.getPopover(), {\n            [dataAttrs.content]: \"\",\n        });\n    }\n}\n", "export function findNext(array, condition) {\n    const index = array.findIndex(condition);\n    if (index === -1) {\n        return undefined; // Condition not met\n    }\n    const nextIndex = (index + 1) % array.length; // Wrap around\n    return array[nextIndex];\n}\nexport function findPrev(array, condition) {\n    const index = array.findIndex(condition);\n    if (index === -1) {\n        return undefined; // Condition not met\n    }\n    const prevIndex = (index - 1 + array.length) % array.length; // Wrap around\n    return array[prevIndex];\n}\n", "export function safeEffect(cb) {\n    try {\n        $effect(cb);\n    }\n    catch {\n        cb();\n    }\n}\n", "import { dataAttr } from \"../utils/attribute\";\nimport { extract } from \"../utils/extract\";\nimport { createBuilderMetadata } from \"../utils/identifiers\";\nimport { isHtmlElement, isHtmlInputElement, isNode } from \"../utils/is\";\nimport { kbd } from \"../utils/keyboard\";\nimport { pick } from \"../utils/object\";\nimport { SelectionState, } from \"../utils/selection-state.svelte\";\nimport { letterRegex } from \"../utils/typeahead.svelte\";\nimport { tick } from \"svelte\";\nimport { BasePopover } from \"./Popover.svelte\";\nimport { findNext, findPrev } from \"../utils/array\";\nimport { Synced } from \"../Synced.svelte\";\nimport { safeEffect } from \"../utils/effect.svelte\";\nconst { dataAttrs, dataSelectors, createIds } = createBuilderMetadata(\"combobox\", [\n    \"input\",\n    \"trigger\",\n    \"content\",\n    \"option\",\n]);\nexport class Combobox extends BasePopover {\n    /* Props */\n    #props;\n    multiple = $derived(extract(this.#props.multiple, false));\n    scrollAlignment = $derived(extract(this.#props.scrollAlignment, \"nearest\"));\n    /* State */\n    #value;\n    inputValue = $state(\"\");\n    #highlighted;\n    touched = $state(false);\n    onSelectMap = new Map();\n    constructor(props = {}) {\n        super({\n            sameWidth: true,\n            ...props,\n            closeOnOutsideClick: (el) => {\n                const triggerEl = document.getElementById(this.ids.trigger);\n                if (triggerEl && isNode(el) && triggerEl.contains(el))\n                    return false;\n                return true;\n            },\n            closeOnEscape: () => this.open,\n            onOpenChange: async (open) => {\n                this.touched = false;\n                props.onOpenChange?.(open);\n                await tick();\n                if (!open) {\n                    this.highlighted = null;\n                    if (!this.multiple) {\n                        this.inputValue = this.valueAsString ?? \"\";\n                    }\n                    return;\n                }\n                tick().then(() => {\n                    if (this.highlighted)\n                        return;\n                    const lastSelected = this.#value.toArray().at(-1);\n                    if (lastSelected)\n                        this.highlight(lastSelected);\n                    else\n                        this.highlightFirst();\n                });\n                // const content = document.getElementById(this.ids.content);\n                // if (!content) return;\n                // content.focus();\n            },\n        });\n        this.#props = props;\n        this.#value = new SelectionState({\n            value: props.value,\n            onChange: props.onValueChange,\n            multiple: props.multiple,\n        });\n        this.#highlighted = new Synced({\n            value: props.highlighted,\n            onChange: props.onHighlightChange,\n            defaultValue: null,\n        });\n        const oldIds = this.ids;\n        const newIds = createIds();\n        this.ids = {\n            ...oldIds,\n            input: oldIds.invoker,\n            content: oldIds.popover,\n            trigger: newIds.trigger,\n        };\n    }\n    get value() {\n        return this.#value.current;\n    }\n    set value(value) {\n        this.#value.current = value;\n    }\n    get highlighted() {\n        return this.#highlighted.current;\n    }\n    set highlighted(v) {\n        this.#highlighted.current = v;\n    }\n    get valueAsString() {\n        return this.#value.toArray().join(\", \");\n    }\n    isSelected = (value) => {\n        return this.#value.has(value);\n    };\n    select(value) {\n        const onSelect = this.onSelectMap.get(value);\n        if (!this.isSelected(value) && onSelect) {\n            onSelect();\n            return;\n        }\n        this.#value.toggle(value);\n        if (this.multiple) {\n            this.inputValue = \"\";\n            return;\n        }\n        this.inputValue = this.valueAsString;\n        this.open = false;\n    }\n    get input() {\n        // using object.assign breaks types here\n        return {\n            ...super.getInvoker(),\n            [dataAttrs.input]: \"\",\n            id: this.ids.input,\n            role: \"combobox\",\n            \"aria-expanded\": this.open,\n            \"aria-controls\": this.ids.content,\n            \"aria-owns\": this.ids.content,\n            onclick: undefined,\n            value: this.inputValue,\n            oninput: (e) => {\n                const input = e.currentTarget;\n                if (!isHtmlInputElement(input))\n                    return;\n                this.open = true;\n                this.inputValue = input.value;\n                tick().then(() => this.highlightFirst());\n                this.touched = true;\n            },\n            onkeydown: (e) => {\n                if (this.open) {\n                    const kbdSubset = pick(kbd, \"ARROW_DOWN\", \"ARROW_UP\", \"ESCAPE\", \"ENTER\");\n                    if (Object.values(kbdSubset).includes(e.key))\n                        e.preventDefault();\n                    switch (e.key) {\n                        case kbdSubset.ARROW_DOWN: {\n                            this.highlightNext();\n                            break;\n                        }\n                        case kbdSubset.ARROW_UP: {\n                            this.highlightPrev();\n                            break;\n                        }\n                        case kbdSubset.ESCAPE: {\n                            this.open = false;\n                            break;\n                        }\n                        case kbdSubset.ENTER: {\n                            if (this.highlighted === null)\n                                return;\n                            this.select(this.highlighted);\n                            break;\n                        }\n                    }\n                }\n                else {\n                    const kbdSubset = pick(kbd, \"ARROW_DOWN\", \"ARROW_UP\", \"ESCAPE\");\n                    if (Object.values(kbdSubset).includes(e.key))\n                        e.preventDefault();\n                    else if (letterRegex.test(e.key))\n                        this.open = true;\n                    switch (e.key) {\n                        case kbdSubset.ARROW_DOWN: {\n                            if (this.open) {\n                                return this.highlightNext();\n                            }\n                            this.open = true;\n                            tick().then(() => {\n                                if (!this.value)\n                                    this.highlightFirst();\n                            });\n                            break;\n                        }\n                        case kbdSubset.ARROW_UP: {\n                            if (this.open) {\n                                return this.highlightNext();\n                            }\n                            this.open = true;\n                            tick().then(() => {\n                                if (!this.value)\n                                    this.highlightLast();\n                            });\n                            break;\n                        }\n                        case kbdSubset.ESCAPE: {\n                            this.#value.clear();\n                            this.inputValue = \"\";\n                            break;\n                        }\n                    }\n                }\n            },\n        };\n    }\n    get trigger() {\n        return {\n            [dataAttrs.trigger]: \"\",\n            id: this.ids.trigger,\n            onclick: () => {\n                this.open = !this.open;\n                document.getElementById(this.ids.input)?.focus();\n            },\n            ...super.sharedProps,\n        };\n    }\n    get content() {\n        return Object.assign(super.getPopover(), {\n            [dataAttrs.content]: \"\",\n            role: \"listbox\",\n            \"aria-expanded\": this.open,\n            \"aria-activedescendant\": this.highlighted ? this.getOptionId(this.highlighted) : undefined,\n        });\n    }\n    scrollIntoView(value) {\n        if (this.scrollAlignment === null)\n            return;\n        const v = value ?? this.highlighted;\n        if (!v)\n            return;\n        const id = this.getOptionId(v);\n        const el = document.getElementById(id);\n        if (el)\n            el.scrollIntoView({ block: this.scrollAlignment });\n    }\n    getOptionId(value) {\n        return `${this.ids.content}-option-${dataAttr(value)}`;\n    }\n    /**\n     * Gets the attributes for the option element.\n     * @param value The value of the option.\n     * @param onSelect An optional callback to call when the option is selected, overriding the default behavior.\n     * @returns The attributes for the option element.\n     */\n    getOption(value, onSelect) {\n        safeEffect(() => {\n            if (onSelect)\n                this.onSelectMap.set(value, onSelect);\n            return () => {\n                this.onSelectMap.delete(value);\n            };\n        });\n        return {\n            id: this.getOptionId(value),\n            [dataAttrs.option]: \"\",\n            \"data-value\": dataAttr(value),\n            \"aria-hidden\": this.open ? undefined : true,\n            \"aria-selected\": this.#value.has(value),\n            \"data-highlighted\": dataAttr(this.highlighted === value),\n            role: \"option\",\n            onmouseover: () => {\n                this.highlighted = value;\n            },\n            onclick: () => {\n                this.select(value);\n            },\n        };\n    }\n    getOptionsEls() {\n        const contentEl = document.getElementById(this.ids.content);\n        if (!contentEl)\n            return [];\n        return [...contentEl.querySelectorAll(dataSelectors.option)].filter(isHtmlElement);\n    }\n    getOptions() {\n        const els = this.getOptionsEls();\n        return els.map((el) => el.dataset.value);\n    }\n    highlight(value) {\n        this.highlighted = value;\n        this.scrollIntoView(value);\n    }\n    highlightNext() {\n        const options = this.getOptions();\n        const next = findNext(options, (v) => v === this.highlighted);\n        if (next !== undefined)\n            this.highlight(next);\n    }\n    highlightPrev() {\n        const options = this.getOptions();\n        const prev = findPrev(options, (v) => v === this.highlighted);\n        if (prev !== undefined)\n            this.highlight(prev);\n    }\n    highlightFirst() {\n        const first = this.getOptions()[0];\n        if (first)\n            this.highlight(first);\n    }\n    highlightLast() {\n        const last = this.getOptions().at(-1);\n        if (last)\n            this.highlight(last);\n    }\n}\n", "/**\n * Convert a blob to a binary string\n *\n * The blob can optionnaly be sliced with the slice arguments\n *\n * @version 1.0.0\n * @since   1.0.0\n * @param   {Blob}  blob Blob to convert and optionnally sample\n * @param   {Number}  chunk Size in bytes to slice blob\n * @return  {Promise<string>}       Binary data as a string\n */\nexport function blobToBinaryString(blob, chunk) {\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        const s = chunk ? Math.min(chunk, blob.size) : blob.size;\n        const b = blob.slice(0, s);\n        reader.onload = () => resolve(reader.result); // Type assertion\n        reader.onerror = reject;\n        reader.readAsBinaryString(b);\n    });\n}\n/**\n * Convert a blob to an ArrayBuffer\n *\n * The blob can optionnally be sliced with the `size`argument\n *\n * @version 1.0.0\n * @since   1.0.0\n * @param   {Blob}  blob Blob\n * @param   {Number}  chunk Size in bytes to slice blob\n * @return  {Promise<ArrayBuffer>}       Binary data as a buffer\n */\nexport function blobToArrayBuffer(blob, chunk) {\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        const s = chunk ? Math.min(chunk, blob.size) : blob.size;\n        const b = blob.slice(0, s);\n        reader.onload = () => resolve(reader.result); // Type assertion\n        reader.onerror = reject;\n        reader.readAsArrayBuffer(b);\n    });\n}\n/**\n * Compares two buffers byte to byte\n *\n * @version 1.0.0\n * @since   1.0.0\n * @param   {ArrayBuffer}  buf1          First buffer\n * @param   {ArrayBuffer}  buf2          Second buffer\n * @return  {Boolean}           `true` if buffers are equal\n */\nexport function compareBuffers(buf1, buf2) {\n    if (buf1 === buf2)\n        return true;\n    if (buf1.byteLength !== buf2.byteLength)\n        return false;\n    const d1 = new DataView(buf1), d2 = new DataView(buf2);\n    let i = buf1.byteLength;\n    while (i--) {\n        /* istanbul ignore else */\n        if (d1.getUint8(i) !== d2.getUint8(i))\n            return false;\n    }\n    return true;\n}\n/**\n * Compares two File objects by their content using chunking.\n *\n * @param {File} file1 The first File object.\n * @param {File} file2 The second File object.\n * @param {number} [chunkSize=1024 * 1024] The chunk size in bytes.  Defaults\n *  to 1MB.\n * @returns {Promise<boolean>} A promise that resolves to true if the files\n *  have the same content, false otherwise.\n */\nexport async function areFilesEqual(file1, file2, chunkSize = 1024 * 1024) {\n    if (file1.size !== file2.size) {\n        return false; // Optimization: Different sizes mean different content\n    }\n    let offset = 0;\n    while (offset < file1.size) {\n        const s = Math.min(chunkSize, file1.size - offset); // Correct slice size\n        const b1 = file1.slice(offset, offset + s);\n        const b2 = file2.slice(offset, offset + s);\n        const chunk1 = await blobToArrayBuffer(b1, chunkSize);\n        const chunk2 = await blobToArrayBuffer(b2, chunkSize);\n        if (!compareBuffers(chunk1, chunk2)) {\n            return false;\n        }\n        offset += chunkSize;\n    }\n    return true;\n}\n", "import { dataAttr } from \"../utils/attribute\";\nimport { extract } from \"../utils/extract\";\nimport { areFilesEqual } from \"../utils/file\";\nimport { createBuilderMetadata } from \"../utils/identifiers\";\nimport { SelectionState } from \"../utils/selection-state.svelte\";\nimport { watch } from \"runed\";\nconst { dataAttrs, createIds } = createBuilderMetadata(\"fileupload\", [\"dropzone\", \"input\"]);\nexport class FileUpload {\n    #props;\n    multiple = $derived(extract(this.#props.multiple, false));\n    accept = $derived(extract(this.#props.accept, undefined));\n    maxSize = $derived(extract(this.#props.maxSize, undefined));\n    disabled = $derived(extract(this.#props.disabled, false));\n    avoidDuplicates = $derived(extract(this.#props.avoidDuplicates, false));\n    /* State */\n    #isDragging = $state(false);\n    #ids = createIds();\n    #selected;\n    constructor(props = {}) {\n        this.#props = props;\n        this.#selected = new SelectionState({\n            value: props.selected,\n            onChange: props.onSelectedChange,\n            multiple: props.multiple,\n        });\n    }\n    get isDragging() {\n        return this.#isDragging;\n    }\n    /**\n     * Gets the currently selected files\n     */\n    get selected() {\n        return this.#selected.current;\n    }\n    /**\n     * Sets the currently selected files\n     */\n    set selected(value) {\n        this.#selected.current = value;\n    }\n    /**\n     * Clears the currently selected files\n     */\n    clear() {\n        this.#selected.clear();\n    }\n    /**\n     * Removes a file from the selection\n     */\n    remove(file) {\n        this.#selected.delete(file);\n    }\n    async has(file) {\n        const files = this.#selected.toArray();\n        const promises = files.map((f) => areFilesEqual(f, file));\n        const results = await Promise.all(promises);\n        return results.some(Boolean);\n    }\n    #handleFiles = async (files) => {\n        if (!files)\n            return;\n        const fileArray = Array.from(files);\n        const validFiles = [];\n        for (const file of fileArray) {\n            if (this.avoidDuplicates && (await this.has(file)))\n                continue;\n            // Check file type if accept is specified\n            if (this.accept) {\n                const acceptTypes = this.accept.split(\",\").map((t) => t.trim());\n                const isValidType = acceptTypes.some((type) => {\n                    if (type.startsWith(\".\")) {\n                        // Extension check\n                        return file.name.toLowerCase().endsWith(type.toLowerCase());\n                    }\n                    else if (type.endsWith(\"/*\")) {\n                        // Mime type group check\n                        const group = type.split(\"/\")[0];\n                        return file.type.startsWith(`${group}/`);\n                    }\n                    else {\n                        // Exact mime type check\n                        return file.type === type;\n                    }\n                });\n                if (!isValidType) {\n                    this.#props.onError?.({\n                        type: \"type\",\n                        file,\n                        message: `File type ${file.type} is not accepted`,\n                    });\n                    continue;\n                }\n            }\n            // Check file size if maxSize is specified\n            if (this.maxSize && file.size > this.maxSize) {\n                this.#props.onError?.({\n                    type: \"size\",\n                    file,\n                    message: `File size ${file.size} exceeds maximum size of ${this.maxSize}`,\n                });\n                continue;\n            }\n            // Run custom validation if provided\n            if (this.#props.validate && !this.#props.validate(file)) {\n                this.#props.onError?.({\n                    type: \"validation\",\n                    file,\n                    message: `File failed custom validation`,\n                });\n                continue;\n            }\n            // File passed all validations\n            validFiles.push(file);\n            this.#props.onAccept?.(file);\n        }\n        if (!validFiles.length)\n            return;\n        if (this.multiple) {\n            this.#selected.addAll(validFiles);\n        }\n        else {\n            const firstFile = validFiles[0];\n            if (firstFile)\n                this.#selected.add(firstFile);\n        }\n    };\n    /** The dropzone element, where you can drag files into, or click to open the file picker. */\n    get dropzone() {\n        return {\n            [dataAttrs.dropzone]: \"\",\n            \"data-dragging\": dataAttr(this.#isDragging),\n            \"data-disabled\": dataAttr(this.disabled),\n            ondragenter: (e) => {\n                if (this.disabled)\n                    return;\n                e.preventDefault();\n                if (!this.#isDragging) {\n                    this.#isDragging = true;\n                }\n            },\n            ondragleave: (e) => {\n                if (this.disabled)\n                    return;\n                e.preventDefault();\n                // Check if we're actually leaving the dropzone\n                const relatedTarget = e.relatedTarget;\n                const dropzone = e.currentTarget;\n                // Only set dragging to false if we're actually leaving the dropzone\n                // and not just moving between its children\n                if (!relatedTarget || !dropzone.contains(relatedTarget)) {\n                    this.#isDragging = false;\n                }\n            },\n            ondragover: (e) => {\n                if (this.disabled)\n                    return;\n                e.preventDefault();\n            },\n            ondrop: (e) => {\n                if (this.disabled)\n                    return;\n                e.preventDefault();\n                this.#isDragging = false;\n                if (e.dataTransfer?.files) {\n                    this.#handleFiles(e.dataTransfer.files);\n                }\n            },\n            onclick: () => {\n                if (this.disabled)\n                    return;\n                const input = document.getElementById(this.#ids.input);\n                if (input) {\n                    input.click();\n                }\n            },\n        };\n    }\n    /** The hidden file input element. */\n    get input() {\n        watch(() => $state.snapshot(this.#selected.toArray()), () => {\n            const input = document.getElementById(this.#ids.input);\n            if (!input)\n                return;\n            const set = this.#selected.toSet();\n            const dt = new DataTransfer();\n            for (const file of set) {\n                dt.items.add(file);\n            }\n            input.files = dt.files;\n        });\n        return {\n            [dataAttrs.input]: \"\",\n            id: this.#ids.input,\n            type: \"file\",\n            accept: this.accept,\n            multiple: this.multiple,\n            style: \"display: none;\",\n            disabled: this.disabled,\n            onchange: (e) => {\n                if (this.disabled)\n                    return;\n                const input = e.target;\n                const files = input.files;\n                input.files = null;\n                this.#handleFiles(files);\n            },\n        };\n    }\n    /** An optional trigger element, which can be used to open the file picker. */\n    get trigger() {\n        return {\n            \"data-disabled\": dataAttr(this.disabled),\n            onclick: () => {\n                if (this.disabled)\n                    return;\n                const input = document.getElementById(this.#ids.input);\n                if (input) {\n                    input.click();\n                }\n            },\n        };\n    }\n}\n", "import { Synced } from \"../Synced.svelte\";\nimport { dataAttr, disabledAttr } from \"../utils/attribute\";\nimport { inBrowser } from \"../utils/browser\";\nimport { extract } from \"../utils/extract\";\nimport { createDataIds } from \"../utils/identifiers\";\nimport { isHtmlInputElement } from \"../utils/is\";\nimport { nanoid } from \"nanoid\";\nconst identifiers = createDataIds(\"pin-input\", [\"root\", \"input\"]);\nfunction validateInput(char, type) {\n    switch (type) {\n        case \"alphanumeric\":\n            return /^[a-zA-Z0-9]$/.test(char);\n        case \"numeric\":\n            return /^[0-9]$/.test(char);\n        case \"text\":\n            return true;\n    }\n}\nfunction setInputSelectionRange(input, start, end) {\n    setTimeout(() => {\n        if (input.value.length === 0)\n            return;\n        if (input.selectionStart === start && input.selectionEnd === end)\n            return;\n        input.setSelectionRange(start, end);\n    });\n}\nexport class PinInput {\n    #id = nanoid();\n    /* Props */\n    #props;\n    maxLength = $derived(extract(this.#props.maxLength, 4));\n    placeholder = $derived(extract(this.#props.placeholder, \"\"));\n    disabled = $derived(extract(this.#props.disabled, false));\n    mask = $derived(extract(this.#props.mask, false));\n    type = $derived(extract(this.#props.type, \"text\"));\n    allowPaste = $derived(extract(this.#props.allowPaste, true));\n    /* State */\n    #value;\n    #focusedIndex = $state(-1);\n    isFilled = $derived(this.value.length === this.maxLength);\n    constructor(props = {}) {\n        this.#value = new Synced({\n            value: props.value,\n            onChange: props.onValueChange,\n            defaultValue: \"\",\n        });\n        this.#props = props;\n    }\n    #getInputEls() {\n        if (!inBrowser())\n            return [];\n        const rootEl = document.getElementById(this.#id);\n        if (!rootEl)\n            return [];\n        return [...rootEl.querySelectorAll(`[${identifiers.input}]`)].filter(isHtmlInputElement);\n    }\n    get value() {\n        return this.#value.current;\n    }\n    set value(value) {\n        const prev = this.#value.current;\n        this.#value.current = value;\n        // set values in inputs\n        const inputs = this.#getInputEls();\n        inputs.forEach((input, index) => {\n            input.value = value[index] ?? \"\";\n        });\n        const completed = prev.length !== value.length && value.length === this.maxLength;\n        if (completed) {\n            this.#props.onComplete?.(value);\n        }\n    }\n    /** The root element's props. */\n    get root() {\n        return {\n            [identifiers.root]: \"\",\n            id: this.#id,\n            \"data-complete\": dataAttr(this.isFilled),\n        };\n    }\n    /** An array of props that should be spread to the input elements. */\n    get inputs() {\n        return Array(this.maxLength)\n            .fill(0)\n            .map((_, index) => this.#getInput(index));\n    }\n    #deleteCharAtIndex(index) {\n        this.value = this.value.slice(0, index) + this.value.slice(index + 1);\n    }\n    #addCharAtIndex(char, index) {\n        this.value = this.value.slice(0, index) + char + this.value.slice(index + 1);\n    }\n    #getInput(index) {\n        const currValue = this.value[index];\n        const isFilled = currValue !== undefined;\n        const isFocused = this.#focusedIndex === index;\n        const isLast = index === this.maxLength - 1;\n        const canFocus = (this.isFilled && isLast) || index === this.value.length;\n        const onpaste = (pasted) => {\n            if (!this.allowPaste)\n                return;\n            const inputs = this.#getInputEls();\n            if (!inputs.length)\n                return;\n            const focusedIndex = Math.max(this.#focusedIndex, 0);\n            const initialIndex = pasted.length >= inputs.length ? 0 : focusedIndex;\n            const lastIndex = Math.min(initialIndex + pasted.length, inputs.length);\n            const valid = pasted.split(\"\").every((char) => validateInput(char, this.type));\n            if (!valid) {\n                this.#props.onError?.({\n                    method: \"paste\",\n                    message: `Input did not match the type ${this.type}`,\n                });\n                return;\n            }\n            for (let i = initialIndex; i < lastIndex; i++) {\n                const input = inputs[i];\n                if (!input)\n                    continue;\n                input.value = pasted[i - initialIndex] ?? \"\";\n                this.#addCharAtIndex(pasted[i - initialIndex] ?? \"\", i);\n            }\n            inputs[lastIndex]?.focus();\n        };\n        return {\n            [identifiers.input]: \"\",\n            placeholder: isFocused ? undefined : this.placeholder,\n            disabled: disabledAttr(this.disabled),\n            type: this.mask ? \"password\" : \"text\",\n            \"data-filled\": dataAttr(isFilled),\n            tabindex: canFocus ? 0 : -1,\n            inputmode: this.type === \"numeric\" ? \"numeric\" : \"text\",\n            style: canFocus && isFocused && !isFilled ? undefined : \"caret-color: transparent;\",\n            onkeydown: (e) => {\n                const el = e.target;\n                if (!isHtmlInputElement(el)) {\n                    return;\n                }\n                const inputs = this.#getInputEls();\n                switch (e.key) {\n                    case \"ArrowLeft\": {\n                        e.preventDefault();\n                        inputs[index - 1]?.focus();\n                        break;\n                    }\n                    case \"ArrowRight\": {\n                        if (!this.value[index])\n                            return;\n                        e.preventDefault();\n                        inputs.at(index + 1)?.focus();\n                        break;\n                    }\n                    case \"Home\": {\n                        e.preventDefault();\n                        inputs[0]?.focus();\n                        break;\n                    }\n                    case \"End\": {\n                        e.preventDefault();\n                        const lastFocusableIndex = Math.min(this.value.length, inputs.length - 1);\n                        inputs[lastFocusableIndex]?.focus();\n                        break;\n                    }\n                    case \"Backspace\": {\n                        e.preventDefault();\n                        if (this.value[index]) {\n                            this.#deleteCharAtIndex(index);\n                        }\n                        else {\n                            this.#deleteCharAtIndex(index - 1);\n                            setTimeout(() => inputs[index - 1]?.focus());\n                        }\n                        break;\n                    }\n                }\n            },\n            onpointerdown: (e) => {\n                const el = e.target;\n                if (!isHtmlInputElement(el)) {\n                    return;\n                }\n                setInputSelectionRange(el, 1, 1);\n                if (this.value[index])\n                    return;\n                const inputs = this.#getInputEls();\n                // Set timeout so deps can change, and canFocus is re-evaluated.\n                setTimeout(() => inputs[this.value.length]?.focus());\n            },\n            onpointerup: (e) => {\n                const el = e.target;\n                if (!isHtmlInputElement(el)) {\n                    return;\n                }\n                setInputSelectionRange(el, 1, 1);\n            },\n            oninput: (e) => {\n                const el = e.target;\n                if (!isHtmlInputElement(el)) {\n                    return;\n                }\n                e.preventDefault();\n                const prev = currValue;\n                const inputted = prev ? el.value.slice(prev.length) : el.value;\n                if (inputted.length === 1) {\n                    const char = el.value.slice(el.value.length - 1);\n                    if (!validateInput(char, this.type)) {\n                        this.#props.onError?.({\n                            method: \"input\",\n                            message: `Input did not match the type ${this.type}`,\n                        });\n                        el.value = el.value.slice(0, -1);\n                        return;\n                    }\n                    el.value = char;\n                    this.#addCharAtIndex(char, index);\n                    const inputs = this.#getInputEls();\n                    const currIndex = inputs.indexOf(el);\n                    // Set timeout so deps can change, and canFocus is re-evaluated.\n                    setTimeout(() => inputs[currIndex + 1]?.focus());\n                }\n                else {\n                    if (this.#props.onPaste) {\n                        this.#props.onPaste(inputted);\n                    }\n                    else {\n                        onpaste(inputted);\n                    }\n                }\n            },\n            onfocus: () => {\n                this.#focusedIndex = index;\n            },\n            onblur: () => {\n                this.#focusedIndex = -1;\n            },\n            onpaste: (e) => {\n                e.preventDefault();\n                const pasted = e.clipboardData?.getData(\"text\");\n                if (!pasted)\n                    return;\n                if (this.#props.onPaste) {\n                    this.#props.onPaste(pasted);\n                }\n                else {\n                    onpaste(pasted);\n                }\n            },\n        };\n    }\n}\n", "import { Synced } from \"../Synced.svelte\";\nimport { styleAttr } from \"../utils/attribute\";\nimport { extract } from \"../utils/extract\";\nimport { createDataIds } from \"../utils/identifiers\";\nconst dataIds = createDataIds(\"progress\", [\"root\", \"progress\"]);\nexport class Progress {\n    // Props\n    #props;\n    max = $derived(extract(this.#props.max, 100));\n    // States\n    #value;\n    constructor(props = {}) {\n        this.#props = props;\n        this.#value = new Synced({\n            value: props.value,\n            onChange: props.onValueChange,\n            defaultValue: 0,\n        });\n    }\n    get value() {\n        return this.#value.current;\n    }\n    set value(value) {\n        this.#value.current = value;\n    }\n    /**\n     * Spread attributes for the Progress root element.\n     */\n    get root() {\n        return {\n            [dataIds.root]: \"\",\n            value: this.#value.current,\n            max: this.max,\n            role: \"meter\",\n            \"aria-valuemin\": 0,\n            \"aria-valuemax\": this.max,\n            \"aria-valuenow\": this.#value.current,\n            \"data-value\": this.#value.current,\n            \"data-state\": this.#value.current === this.max ? \"complete\" : \"loading\",\n            \"data-max\": this.max,\n        };\n    }\n    /**\n     * Spread attributes for the Progress percentage element.\n     * Provides a --progress CSS variable that can be used to style the progress:\n     * `transform: translateX(calc(var(--progress) * -1));`\n     */\n    get progress() {\n        return {\n            [dataIds.progress]: \"\",\n            style: styleAttr({\n                \"--progress\": `${100 - (100 * (this.#value.current ?? 0)) / (this.max ?? 1)}%`,\n                \"--neg-progress\": `-${100 - (100 * (this.#value.current ?? 0)) / (this.max ?? 1)}%`,\n            }),\n        };\n    }\n}\n", "import { Synced } from \"../Synced.svelte\";\nimport { dataAttr, disabledAttr } from \"../utils/attribute\";\nimport { extract } from \"../utils/extract\";\nimport { createBuilderMetadata } from \"../utils/identifiers\";\nimport { isHtmlElement } from \"../utils/is\";\nimport { getDirectionalKeys, kbd } from \"../utils/keyboard\";\nconst metadata = createBuilderMetadata(\"radio-group\", [\"root\", \"item\", \"label\", \"hidden-input\"]);\nexport class RadioGroup {\n    #ids = metadata.createIds();\n    /* Props */\n    #props;\n    disabled = $derived(extract(this.#props.disabled, false));\n    required = $derived(extract(this.#props.required, false));\n    loop = $derived(extract(this.#props.loop, true));\n    selectWhenFocused = $derived(extract(this.#props.selectWhenFocused, true));\n    orientation = $derived(extract(this.#props.orientation, \"vertical\"));\n    /* State */\n    #value;\n    constructor(props) {\n        this.#props = props;\n        this.#value = new Synced({\n            value: props.value,\n            onChange: props.onValueChange,\n            defaultValue: \"\",\n        });\n    }\n    get value() {\n        return this.#value.current;\n    }\n    set value(value) {\n        this.#value.current = value;\n    }\n    get #sharedAttrs() {\n        return {\n            \"data-orientation\": dataAttr(this.orientation),\n            \"data-disabled\": disabledAttr(this.disabled),\n            \"data-value\": this.value,\n        };\n    }\n    get root() {\n        // TODO: add attachment and check if aria-label is present. Otherwise, use aria-labelledby\n        return {\n            ...this.#sharedAttrs,\n            [metadata.dataAttrs[\"root\"]]: \"\",\n            id: this.#ids.root,\n            role: \"radiogroup\",\n            \"aria-required\": this.required,\n            \"aria-labelledby\": this.#ids.label,\n        };\n    }\n    get label() {\n        return {\n            ...this.#sharedAttrs,\n            [metadata.dataAttrs.label]: \"\",\n            id: this.#ids.label,\n            for: this.#ids.root,\n            onclick: (e) => {\n                if (this.disabled)\n                    return;\n                // focus the selected item\n                const el = e.currentTarget;\n                if (!isHtmlElement(el))\n                    return;\n                const root = el.closest(metadata.dataSelectors.root);\n                if (!isHtmlElement(root))\n                    return;\n                const item = root.querySelector(metadata.dataSelectors.item + `[data-value=\"${dataAttr(this.value)}\"]`);\n                if (isHtmlElement(item))\n                    item.focus();\n            },\n        };\n    }\n    getItem(item) {\n        return new RadioItem({ group: this, item, getSharedAttrs: () => this.#sharedAttrs });\n    }\n    get hiddenInput() {\n        return {\n            [metadata.dataAttrs[\"hidden-input\"]]: \"\",\n            disabled: this.disabled,\n            required: this.required,\n            hidden: true,\n            \"aria-hidden\": true,\n            tabindex: -1,\n            value: this.value,\n            name: extract(this.#props.name),\n        };\n    }\n    select(item) {\n        if (this.disabled)\n            return;\n        this.value = item;\n    }\n}\nclass RadioItem {\n    #props;\n    #group = $derived(this.#props.group);\n    value = $derived(this.#props.item);\n    checked = $derived(this.#group.value === this.value);\n    constructor(props) {\n        this.#props = props;\n    }\n    #select(e) {\n        if (this.#group.disabled)\n            return;\n        this.#group.select(this.value);\n        const el = e.currentTarget;\n        if (!isHtmlElement(el))\n            return;\n        el.focus();\n    }\n    get attrs() {\n        return {\n            ...this.#props.getSharedAttrs(),\n            [metadata.dataAttrs[\"item\"]]: \"\",\n            \"data-value\": dataAttr(this.value),\n            \"data-state\": dataAttr(this.checked ? \"checked\" : \"unchecked\"),\n            \"aria-checked\": this.checked,\n            role: \"radio\",\n            tabindex: 0,\n            onclick: (e) => {\n                this.#select(e);\n            },\n            onkeydown: (e) => {\n                if (e.key === kbd.SPACE) {\n                    e.preventDefault();\n                    this.#select(e);\n                    return;\n                }\n                const el = e.currentTarget;\n                const root = el.closest(metadata.dataSelectors.root);\n                if (!isHtmlElement(root))\n                    return;\n                const items = Array.from(root.querySelectorAll(metadata.dataSelectors.item)).filter((el) => isHtmlElement(el) && !el.hasAttribute(\"data-disabled\"));\n                const currentIdx = items.indexOf(el);\n                const loop = this.#group.loop;\n                const style = window.getComputedStyle(el);\n                const dir = style.getPropertyValue(\"direction\");\n                const { nextKey, prevKey } = getDirectionalKeys(dir, this.#group.orientation);\n                let itemToFocus;\n                switch (e.key) {\n                    case nextKey: {\n                        e.preventDefault();\n                        const nextIdx = currentIdx + 1;\n                        if (nextIdx >= items.length && loop) {\n                            itemToFocus = items[0];\n                        }\n                        else {\n                            itemToFocus = items[nextIdx];\n                        }\n                        break;\n                    }\n                    case prevKey: {\n                        e.preventDefault();\n                        const prevIdx = currentIdx - 1;\n                        if (prevIdx < 0 && loop) {\n                            itemToFocus = items[items.length - 1];\n                        }\n                        else {\n                            itemToFocus = items[prevIdx];\n                        }\n                        break;\n                    }\n                    case kbd.HOME: {\n                        e.preventDefault();\n                        itemToFocus = items[0];\n                        break;\n                    }\n                    case kbd.END: {\n                        e.preventDefault();\n                        itemToFocus = items[items.length - 1];\n                        break;\n                    }\n                    default: {\n                        return;\n                    }\n                }\n                if (itemToFocus) {\n                    itemToFocus.focus();\n                    if (this.#group.selectWhenFocused)\n                        this.#group.select(itemToFocus.dataset.value);\n                }\n            },\n        };\n    }\n}\n", "import { dataAttr } from \"../utils/attribute\";\nimport { extract } from \"../utils/extract\";\nimport { createBuilderMetadata } from \"../utils/identifiers\";\nimport { isHtmlElement } from \"../utils/is\";\nimport { kbd } from \"../utils/keyboard\";\nimport { pick } from \"../utils/object\";\nimport { SelectionState, } from \"../utils/selection-state.svelte\";\nimport { createTypeahead, letterRegex } from \"../utils/typeahead.svelte\";\nimport { tick } from \"svelte\";\nimport { BasePopover } from \"./Popover.svelte\";\nimport { findNext, findPrev } from \"../utils/array\";\nimport { Synced } from \"../Synced.svelte\";\nconst { dataAttrs, dataSelectors, createIds } = createBuilderMetadata(\"select\", [\n    \"trigger\",\n    \"content\",\n    \"option\",\n]);\nexport class Select extends BasePopover {\n    /* Props */\n    #props;\n    multiple = $derived(extract(this.#props.multiple, false));\n    scrollAlignment = $derived(extract(this.#props.scrollAlignment, \"nearest\"));\n    /* State */\n    #value;\n    #highlighted;\n    typeaheadTimeout = $derived(extract(this.#props.typeaheadTimeout, 500));\n    typeahead = $derived(createTypeahead({\n        timeout: this.#props.typeaheadTimeout,\n        getItems: () => {\n            return this.#getOptionsEls().reduce((acc, curr) => {\n                if (!curr.dataset.value)\n                    return acc;\n                return [\n                    ...acc,\n                    {\n                        value: curr.dataset.value,\n                        typeahead: curr.dataset.typeahead,\n                        current: curr.dataset.value === this.highlighted,\n                    },\n                ];\n            }, []);\n        },\n    }));\n    constructor(props = {}) {\n        super({\n            sameWidth: true,\n            ...props,\n            onOpenChange: async (open) => {\n                props.onOpenChange?.(open);\n                await tick();\n                if (!open) {\n                    this.highlighted = null;\n                    return;\n                }\n                if (!this.highlighted) {\n                    const lastSelected = this.#value.toArray().at(-1);\n                    if (lastSelected)\n                        this.highlighted = lastSelected;\n                    else\n                        this.#highlightFirst();\n                }\n                const content = document.getElementById(this.ids.content);\n                if (!content)\n                    return;\n                content.focus();\n            },\n        });\n        this.#props = props;\n        this.#value = new SelectionState({\n            value: props.value,\n            onChange: props.onValueChange,\n            multiple: props.multiple,\n        });\n        this.#highlighted = new Synced({\n            value: props.highlighted,\n            onChange: props.onHighlightChange,\n            defaultValue: null,\n        });\n        const oldIds = this.ids;\n        const newIds = createIds();\n        this.ids = {\n            ...oldIds,\n            trigger: oldIds.invoker,\n            content: oldIds.popover,\n            option: newIds.option,\n        };\n    }\n    get value() {\n        return this.#value.current;\n    }\n    set value(value) {\n        this.#value.current = value;\n    }\n    get highlighted() {\n        return this.#highlighted.current;\n    }\n    set highlighted(v) {\n        this.#highlighted.current = v;\n    }\n    get valueAsString() {\n        return this.#value.toArray().join(\", \");\n    }\n    isSelected = (value) => {\n        return this.#value.has(value);\n    };\n    select = (value) => {\n        if (this.multiple) {\n            this.#value.toggle(value);\n            return;\n        }\n        this.#value.add(value);\n        this.open = false;\n        tick().then(() => {\n            document.getElementById(this.ids.trigger)?.focus();\n        });\n    };\n    get trigger() {\n        return Object.assign(super.getInvoker(), {\n            [dataAttrs.trigger]: \"\",\n            role: \"combobox\",\n            \"aria-expanded\": this.open,\n            \"aria-controls\": this.ids.content,\n            \"aria-owns\": this.ids.content,\n            onkeydown: (e) => {\n                const kbdSubset = pick(kbd, \"ARROW_DOWN\", \"ARROW_UP\");\n                if (Object.values(kbdSubset).includes(e.key))\n                    e.preventDefault();\n                switch (e.key) {\n                    case kbdSubset.ARROW_DOWN: {\n                        this.open = true;\n                        tick().then(() => {\n                            if (!this.value)\n                                this.#highlightFirst();\n                        });\n                        break;\n                    }\n                    case kbdSubset.ARROW_UP: {\n                        this.open = true;\n                        tick().then(() => {\n                            if (!this.value)\n                                this.#highlightLast();\n                        });\n                        break;\n                    }\n                }\n            },\n        });\n    }\n    get content() {\n        return Object.assign(super.getPopover(), {\n            [dataAttrs.content]: \"\",\n            role: \"listbox\",\n            \"aria-expanded\": this.open,\n            \"aria-activedescendant\": this.highlighted ? this.getOptionId(this.highlighted) : undefined,\n            onkeydown: (e) => {\n                const kbdSubset = pick(kbd, \"HOME\", \"END\", \"ARROW_DOWN\", \"ARROW_UP\", \"ESCAPE\", \"ENTER\", \"SPACE\");\n                if (Object.values(kbdSubset).includes(e.key))\n                    e.preventDefault();\n                switch (e.key) {\n                    case kbdSubset.HOME: {\n                        this.#highlightFirst();\n                        break;\n                    }\n                    case kbdSubset.END: {\n                        this.#highlightLast();\n                        break;\n                    }\n                    case kbdSubset.ARROW_DOWN: {\n                        this.#highlightNext();\n                        break;\n                    }\n                    case kbdSubset.ARROW_UP: {\n                        this.#highlightPrev();\n                        break;\n                    }\n                    case kbdSubset.SPACE:\n                    case kbdSubset.ENTER: {\n                        if (!this.highlighted)\n                            break;\n                        this.select(this.highlighted);\n                        break;\n                    }\n                    case kbdSubset.ESCAPE: {\n                        this.open = false;\n                        tick().then(() => {\n                            document.getElementById(this.ids.trigger)?.focus();\n                        });\n                        break;\n                    }\n                    default: {\n                        if (!letterRegex.test(e.key))\n                            break;\n                        e.preventDefault();\n                        e.stopPropagation();\n                        const next = this.typeahead(e.key);\n                        if (next)\n                            this.highlighted = next.value;\n                    }\n                }\n            },\n        });\n    }\n    getOptionId(value) {\n        return `${this.ids.content}-option-${dataAttr(value)}`;\n    }\n    getOption(value, options) {\n        return {\n            [dataAttrs.option]: \"\",\n            \"data-value\": dataAttr(value),\n            \"data-typeahead\": dataAttr(options?.typeahead),\n            \"aria-hidden\": this.open ? undefined : true,\n            \"aria-selected\": this.#value.has(value),\n            \"data-highlighted\": dataAttr(this.highlighted === value),\n            role: \"option\",\n            onmouseover: () => {\n                this.highlighted = value;\n            },\n            onclick: () => {\n                this.select(value);\n            },\n        };\n    }\n    #getOptionsEls() {\n        const contentEl = document.getElementById(this.ids.content);\n        if (!contentEl)\n            return [];\n        return [...contentEl.querySelectorAll(dataSelectors.option)].filter(isHtmlElement);\n    }\n    #highlight(el) {\n        if (!el.dataset.value)\n            return;\n        this.highlighted = el.dataset.value;\n        if (this.scrollAlignment !== null) {\n            el.scrollIntoView({ block: this.scrollAlignment });\n        }\n    }\n    #highlightNext() {\n        const options = this.#getOptionsEls();\n        const next = findNext(options, (o) => o.dataset.value === this.highlighted);\n        if (isHtmlElement(next))\n            this.#highlight(next);\n    }\n    #highlightPrev() {\n        const options = this.#getOptionsEls();\n        const prev = findPrev(options, (o) => o.dataset.value === this.highlighted);\n        if (isHtmlElement(prev))\n            this.#highlight(prev);\n    }\n    #highlightFirst() {\n        const first = this.#getOptionsEls()[0];\n        if (first)\n            this.#highlight(first);\n    }\n    #highlightLast() {\n        const last = this.#getOptionsEls().at(-1);\n        if (last)\n            this.#highlight(last);\n    }\n}\n", "export function clamp(min, value, max) {\n    return Math.max(min, Math.min(value, max));\n}\n", "import { dataAttr, styleAttr } from \"../utils/attribute\";\nimport { extract } from \"../utils/extract\";\nimport { clamp } from \"../utils/number\";\nimport { useEventListener } from \"runed\";\nimport { Synced } from \"../Synced.svelte\";\nimport { createBuilderMetadata } from \"../utils/identifiers\";\nimport { isHtmlElement } from \"../utils/is\";\nconst { createIds, dataAttrs } = createBuilderMetadata(\"slider\", [\"root\", \"thumb\"]);\nexport class Slider {\n    /* Props */\n    #props;\n    min = $derived(extract(this.#props.min, 0));\n    max = $derived(extract(this.#props.max, 100));\n    orientation = $derived(extract(this.#props.orientation, \"horizontal\"));\n    step = $derived(extract(this.#props.step, 1));\n    /* State */\n    #value;\n    ids = createIds();\n    #mouseDown = false;\n    #dragging = false;\n    #mouseDownAt = null;\n    constructor(props = {}) {\n        this.#props = props;\n        this.#value = new Synced({\n            value: props.value,\n            onChange: props.onValueChange,\n            defaultValue: 0,\n        });\n    }\n    /** The value of the slider. */\n    get value() {\n        return this.#value.current;\n    }\n    set value(value) {\n        this.#value.current = clamp(this.min, value, this.max);\n    }\n    get #percentage() {\n        const v = (this.value - this.min) / (this.max - this.min);\n        return this.orientation === \"vertical\" ? 1 - v : v;\n    }\n    #commit(e) {\n        this.#dragging = typeof this.#mouseDownAt === \"number\" && e.timeStamp - this.#mouseDownAt > 50;\n        const el = document.getElementById(this.ids.root);\n        if (!isHtmlElement(el))\n            return;\n        e.preventDefault();\n        const elRect = el.getBoundingClientRect();\n        let percentage;\n        if (this.orientation === \"vertical\") {\n            percentage = 1 - clamp(0, e.clientY - elRect.top, elRect.height) / elRect.height;\n        }\n        else {\n            percentage = clamp(0, e.clientX - elRect.left, elRect.width) / elRect.width;\n        }\n        this.value = getValueFixedToStep(this.min + percentage * (this.max - this.min), this.step);\n    }\n    get #sharedProps() {\n        return {\n            \"data-dragging\": dataAttr(this.#dragging),\n            \"data-value\": dataAttr(this.value),\n            \"data-orientation\": dataAttr(this.orientation),\n        };\n    }\n    /**\n     * The root of the slider.\n     * Any cursor interaction along this element will change the slider's values.\n     **/\n    get root() {\n        useEventListener(() => window, \"pointermove\", (e) => {\n            if (!this.#mouseDown)\n                return;\n            this.#commit(e);\n        });\n        useEventListener(() => window, \"pointerup\", () => {\n            this.#mouseDown = false;\n            this.#dragging = false;\n        });\n        return {\n            \"aria-valuenow\": this.value,\n            \"aria-valuemin\": this.min,\n            \"aria-valuemax\": this.max,\n            \"aria-orientation\": this.orientation,\n            style: styleAttr({\n                \"--percentage\": `${this.#percentage * 100}%`,\n                \"--percentage-inv\": `${(1 - this.#percentage) * 100}%`,\n                \"touch-action\": this.orientation === \"vertical\" ? \"pan-x\" : \"pan-y\",\n            }),\n            tabindex: 0,\n            role: \"slider\",\n            [dataAttrs.root]: \"\",\n            id: this.ids.root,\n            onpointerdown: (e) => {\n                this.#mouseDown = true;\n                this.#mouseDownAt = e.timeStamp;\n                this.#commit(e);\n                document.getElementById(this.ids.thumb)?.focus();\n            },\n            onkeydown: (e) => {\n                switch (e.key) {\n                    case \"ArrowDown\":\n                    case \"ArrowLeft\": {\n                        if (e.metaKey)\n                            this.value = this.min;\n                        else\n                            this.value -= this.step;\n                        break;\n                    }\n                    case \"ArrowUp\":\n                    case \"ArrowRight\": {\n                        if (e.metaKey)\n                            this.value = this.max;\n                        else\n                            this.value += this.step;\n                        break;\n                    }\n                    case \"Home\": {\n                        this.value = this.min;\n                        break;\n                    }\n                    case \"End\": {\n                        this.value = this.max;\n                        break;\n                    }\n                    default: {\n                        return;\n                    }\n                }\n                e.preventDefault();\n            },\n            ...this.#sharedProps,\n        };\n    }\n    /** The slider's thumb, positioned at the end of the range. */\n    get thumb() {\n        return {\n            [dataAttrs.thumb]: \"\",\n            id: this.ids.thumb,\n            tabindex: 0,\n            ...this.#sharedProps,\n        };\n    }\n}\nfunction getValueFixedToStep(value, step) {\n    return Math.round(value / step) * step;\n}\n", "import { dataAttr } from \"../utils/attribute\";\nimport { extract } from \"../utils/extract\";\nimport { nanoid } from \"nanoid\";\nimport { Synced } from \"../Synced.svelte\";\nimport { createDataIds } from \"../utils/identifiers\";\nimport { isHtmlElement } from \"../utils/is\";\nconst TRIGGER_KEYS = [\"ArrowLeft\", \"ArrowRight\", \"ArrowUp\", \"ArrowDown\", \"Home\", \"End\"];\nconst identifiers = createDataIds(\"tabs\", [\"trigger\", \"content\", \"trigger-list\"]);\nexport class Tabs {\n    #value;\n    #id = nanoid();\n    /* Props */\n    #props;\n    selectWhenFocused = $derived(extract(this.#props.selectWhenFocused, true));\n    loop = $derived(extract(this.#props.loop, true));\n    orientation = $derived(extract(this.#props.orientation, \"horizontal\"));\n    constructor(props) {\n        this.#props = props;\n        this.#value = new Synced({\n            value: props.value,\n            onChange: props.onValueChange,\n        });\n    }\n    #getTriggerId(value) {\n        return `${this.#id}-trigger-${value.replace(/\\s/g, \"_\")}`;\n    }\n    #getContentId(value) {\n        return `${this.#id}-content-${value.replace(/\\s/g, \"_\")}`;\n    }\n    /** The current selected tab. */\n    get value() {\n        return this.#value.current;\n    }\n    set value(value) {\n        this.#value.current = value;\n    }\n    /** The attributes for the list that contains the tab triggers. */\n    get triggerList() {\n        return {\n            [identifiers[\"trigger-list\"]]: \"\",\n            role: \"tablist\",\n            \"aria-orientation\": this.orientation,\n            \"data-orientation\": this.orientation,\n        };\n    }\n    /** Gets the attributes and listeners for a tab trigger. Requires an identifying tab value. */\n    getTrigger(value) {\n        return {\n            [identifiers.trigger]: value,\n            \"data-active\": dataAttr(this.value === value),\n            tabindex: this.value === value ? 0 : -1,\n            role: \"tab\",\n            \"aria-selected\": this.value === value,\n            \"aria-controls\": this.#getContentId(value),\n            \"data-orientation\": this.orientation,\n            onclick: () => (this.value = value),\n            onkeydown: (e) => {\n                const el = e.target;\n                if (!TRIGGER_KEYS.includes(e.key) || !isHtmlElement(el)) {\n                    return;\n                }\n                e.preventDefault();\n                const triggerList = el.closest(`[${identifiers[\"trigger-list\"]}]`);\n                if (!triggerList)\n                    return;\n                const triggers = [...triggerList.querySelectorAll(`[${identifiers.trigger}]`)];\n                const currIndex = triggers.indexOf(el);\n                let next = el;\n                const prevKey = this.orientation === \"horizontal\" ? \"ArrowLeft\" : \"ArrowUp\";\n                const nextKey = this.orientation === \"horizontal\" ? \"ArrowRight\" : \"ArrowDown\";\n                switch (e.key) {\n                    case prevKey: {\n                        next = this.loop ? triggers.at(currIndex - 1) : triggers.at(Math.max(currIndex - 1, 0));\n                        break;\n                    }\n                    case nextKey: {\n                        next = this.loop\n                            ? triggers.at((currIndex + 1) % triggers.length)\n                            : triggers.at(currIndex + 1);\n                        break;\n                    }\n                    case \"Home\": {\n                        next = triggers[0];\n                        break;\n                    }\n                    case \"End\": {\n                        next = triggers.at(-1);\n                        break;\n                    }\n                }\n                if (!isHtmlElement(next))\n                    return;\n                next.focus();\n                if (this.selectWhenFocused) {\n                    this.value = next.getAttribute(identifiers.trigger);\n                }\n            },\n            id: this.#getTriggerId(value),\n        };\n    }\n    /** Gets the attributes and listeners for the tabs contents. Requires an identifying tab value. */\n    getContent(value) {\n        return {\n            [identifiers.content]: \"\",\n            hidden: this.value !== value,\n            \"data-active\": dataAttr(this.value === value),\n            role: \"tabpanel\",\n            id: this.#getContentId(value),\n            \"aria-labelledby\": this.#getTriggerId(value),\n            \"data-orientation\": this.orientation,\n        };\n    }\n}\n", "import { untrack } from \"svelte\";\n/**\n * Wrapper over {@link https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame requestAnimationFrame},\n * with controls for pausing and resuming the animation, reactive tracking and optional limiting of fps, and utilities.\n */\nexport class AnimationFrames {\n    #callback;\n    #previousTimestamp = null;\n    frame = null;\n    #fps = $state(0);\n    #running = $state(false);\n    constructor(callback) {\n        this.#callback = callback;\n        this.start = this.start.bind(this);\n        this.stop = this.stop.bind(this);\n        this.toggle = this.toggle.bind(this);\n        this.start();\n    }\n    #loop(timestamp) {\n        if (!this.#running)\n            return;\n        if (this.#previousTimestamp === null) {\n            this.#previousTimestamp = timestamp;\n        }\n        const delta = timestamp - this.#previousTimestamp;\n        const fps = 1000 / delta;\n        this.#fps = fps;\n        this.#previousTimestamp = timestamp;\n        this.#callback({ delta, timestamp });\n        this.frame = window.requestAnimationFrame(this.#loop.bind(this));\n    }\n    start() {\n        if (this.#running)\n            return;\n        this.#running = true;\n        this.#previousTimestamp = null;\n        this.frame = window.requestAnimationFrame(this.#loop.bind(this));\n    }\n    stop() {\n        if (!this.#running)\n            return;\n        this.#running = false;\n        if (this.frame)\n            window.cancelAnimationFrame(this.frame);\n        this.frame = null;\n    }\n    toggle() {\n        this.#running ? this.stop() : this.start();\n    }\n    get fps() {\n        return !this.#running ? 0 : this.#fps;\n    }\n    get running() {\n        return this.#running;\n    }\n}\n", "import { extract } from \"../utils/extract\";\nimport { createBuilderMetadata } from \"../utils/identifiers\";\nimport { SvelteMap } from \"svelte/reactivity\";\nimport { isHtmlElement, isTouch } from \"../utils/is\";\nimport { AnimationFrames } from \"../utils/animation-frames.svelte\";\nimport { safelyHidePopover, safelyShowPopover } from \"../utils/popover\";\nimport { watch } from \"runed\";\nconst toasterMeta = createBuilderMetadata(\"toaster\", [\"root\"]);\nconst toastMeta = createBuilderMetadata(\"toaster-toast\", [\n    \"content\",\n    \"title\",\n    \"description\",\n    \"close\",\n]);\nexport class Toaster {\n    // Props\n    #props;\n    ids = toasterMeta.createIds();\n    closeDelay = $derived(extract(this.#props.closeDelay, 5000));\n    type = $derived(extract(this.#props.type, \"polite\"));\n    hover = $derived(extract(this.#props.hover, \"pause\"));\n    // State\n    #toastsMap = new SvelteMap();\n    /** The active toasts. */\n    toasts = $derived(Array.from(this.#toastsMap.values()));\n    #subscribers = 0;\n    constructor(props = {}) {\n        this.#props = props;\n    }\n    /**\n     * Adds a toast.\n     */\n    addToast = (props) => {\n        const propsWithDefaults = {\n            closeDelay: this.closeDelay,\n            type: this.type,\n            ...props,\n        };\n        const id = window.crypto.randomUUID();\n        const toast = new Toast({\n            toaster: this,\n            id,\n            ...propsWithDefaults,\n        });\n        this.#toastsMap.set(id, toast);\n        return toast;\n    };\n    /**\n     * Removes the toast with the specified ID.\n     * @param id The id of the toast.\n     */\n    removeToast = (id) => {\n        const toast = this.#toastsMap.get(id);\n        if (!toast)\n            return;\n        this.#toastsMap.delete(id);\n        toast.cleanup();\n    };\n    /**\n     * Updates a toast's data.\n     * @param id The id of the toast.\n     * @param data The updated data.\n     */\n    updateToast = (id, data) => {\n        const toast = this.#toastsMap.get(id);\n        if (!toast)\n            return;\n        toast.data = data;\n    };\n    /**\n     * Spread attributes for the container of the toasts.\n     */\n    get root() {\n        if ($effect.tracking()) {\n            this.#subscribers++;\n            $effect(() => {\n                return () => {\n                    this.#subscribers--;\n                };\n            });\n            watch(() => this.#subscribers, (s) => {\n                if (s !== 1)\n                    return;\n                $effect(() => {\n                    const el = document.getElementById(this.ids.root);\n                    if (!isHtmlElement(el))\n                        return;\n                    if (!this.toasts.length) {\n                        safelyHidePopover(el);\n                        return;\n                    }\n                    safelyShowPopover(el);\n                });\n            });\n        }\n        return {\n            [toasterMeta.dataAttrs.root]: \"\",\n            id: this.ids.root,\n            popover: \"manual\",\n        };\n    }\n}\nclass Toast {\n    /** Props */\n    #props;\n    toaster = $derived(this.#props.toaster);\n    id = $derived(this.#props.id);\n    /** The original data you passed to the `addToast` function. */\n    data = $state();\n    closeDelay = $derived(this.#props.closeDelay);\n    type = $derived(this.#props.type);\n    /** State */\n    ids = toastMeta.createIds();\n    createdAt;\n    #frames;\n    timeElapsed = $state(0);\n    percentage = $derived((100 * this.timeElapsed) / this.closeDelay);\n    constructor(props) {\n        this.#props = props;\n        this.data = props.data;\n        this.createdAt = performance.now();\n        if (!this.closeDelay)\n            return;\n        this.#frames = new AnimationFrames(({ delta }) => {\n            this.timeElapsed += delta;\n            if (this.timeElapsed > this.closeDelay) {\n                this.removeSelf();\n            }\n        });\n    }\n    /** Remove toast. */\n    removeSelf = () => {\n        this.toaster.removeToast(this.id);\n    };\n    /** @internal */\n    cleanup = () => {\n        this.#frames?.stop();\n    };\n    /** Pause toast timer. */\n    pause = () => {\n        this.#frames?.stop();\n    };\n    /** Reset toast timer. */\n    reset = () => {\n        this.timeElapsed = 0;\n        this.#frames?.start();\n    };\n    /** Resume toast timer */\n    resume = () => {\n        this.#frames?.start();\n    };\n    /**\n     * Spread attributes for a toast's content (wrapper) element.\n     */\n    get content() {\n        return {\n            [toastMeta.dataAttrs.content]: \"\",\n            id: this.ids.content,\n            role: \"alert\",\n            \"aria-labelledby\": this.ids.title,\n            \"aria-describedby\": this.ids.description,\n            \"aria-live\": this.type ?? this.toaster.type,\n            tabindex: -1,\n            onpointerenter: (e) => {\n                if (isTouch(e))\n                    return;\n                if (this.toaster.hover === \"pause\") {\n                    this.pause();\n                }\n                else if (this.toaster.hover === \"pause-all\") {\n                    for (const toast of this.toaster.toasts) {\n                        toast.pause();\n                    }\n                }\n            },\n            onpointerleave: (e) => {\n                if (isTouch(e))\n                    return;\n                if (this.toaster.hover === \"pause\") {\n                    this.resume();\n                }\n                else if (this.toaster.hover === \"pause-all\") {\n                    for (const toast of this.toaster.toasts) {\n                        toast.resume();\n                    }\n                }\n            },\n        };\n    }\n    /**\n     * Spread attributes for a toast's title element.\n     */\n    get title() {\n        return { id: this.ids.title };\n    }\n    /**\n     * Soread attributes for a toast's description element.\n     */\n    get description() {\n        return { id: this.ids.description };\n    }\n    /**\n     * Spread attributes for a toast's close button element.\n     */\n    get close() {\n        return {\n            [toastMeta.dataAttrs.close]: \"\",\n            onclick: () => {\n                this.removeSelf();\n            },\n        };\n    }\n}\n", "import { Synced } from \"../Synced.svelte\";\nimport { dataAttr, disabledAttr } from \"../utils/attribute\";\nimport { extract } from \"../utils/extract\";\nimport { createDataIds } from \"../utils/identifiers\";\nconst identifiers = createDataIds(\"toggle\", [\"trigger\", \"hidden-input\"]);\nexport class Toggle {\n    /* Props */\n    #props;\n    disabled = $derived(extract(this.#props.disabled, false));\n    /* State */\n    #value;\n    constructor(props = {}) {\n        this.#value = new Synced({\n            value: props.value,\n            onChange: props.onValueChange,\n            defaultValue: false,\n        });\n        this.#props = props;\n    }\n    get value() {\n        return this.#value.current;\n    }\n    set value(value) {\n        this.#value.current = value;\n    }\n    /** The trigger that toggles the value. */\n    get trigger() {\n        return {\n            [identifiers.trigger]: \"\",\n            \"data-checked\": dataAttr(this.value),\n            \"aria-pressed\": this.value,\n            disabled: disabledAttr(this.disabled),\n            onclick: () => {\n                if (this.disabled)\n                    return;\n                this.value = !this.value;\n            },\n        };\n    }\n    /** A hidden input field to use within forms. */\n    get hiddenInput() {\n        return {\n            [identifiers[\"hidden-input\"]]: \"\",\n            type: \"hidden\",\n            value: this.value ? \"on\" : \"off\",\n        };\n    }\n}\n", "// Computes the convex hull of a set of points using an O(n log n) algorithm\nexport function computeConvexHull(points) {\n    // Create a copy and sort points\n    const sortedPoints = [...points].sort(comparePoints);\n    return computeConvexHullSorted(sortedPoints);\n}\n// Computes the convex hull assuming points are already sorted by x-coordinate\n// This implementation runs in O(n) time\nexport function computeConvexHullSorted(points) {\n    // Handle edge cases\n    if (points.length <= 1) {\n        return [...points];\n    }\n    // Implement Andrew's monotone chain algorithm\n    // Process points to create the top part of the hull\n    const topChain = [];\n    for (const currentPoint of points) {\n        // Remove points that make a non-right turn\n        while (topChain.length >= 2) {\n            const p1 = topChain[topChain.length - 1];\n            const p2 = topChain[topChain.length - 2];\n            if (!p1 || !p2)\n                break;\n            // Check if we need to remove the middle point using cross product\n            const crossProduct = (p1.x - p2.x) * (currentPoint.y - p2.y) - (p1.y - p2.y) * (currentPoint.x - p2.x);\n            if (crossProduct < 0)\n                break;\n            topChain.pop();\n        }\n        topChain.push(currentPoint);\n    }\n    // Remove the last point as it will be added in the bottom chain\n    if (topChain.length > 0) {\n        topChain.pop();\n    }\n    // Process points in reverse to create the bottom part of the hull\n    const bottomChain = [];\n    for (let i = points.length - 1; i >= 0; i--) {\n        const currentPoint = points[i];\n        if (!currentPoint)\n            continue;\n        // Remove points that make a non-right turn\n        while (bottomChain.length >= 2) {\n            const p1 = bottomChain[bottomChain.length - 1];\n            const p2 = bottomChain[bottomChain.length - 2];\n            if (!p1 || !p2)\n                break;\n            // Check if we need to remove the middle point\n            if ((p1.x - p2.x) * (currentPoint.y - p2.y) - (p1.y - p2.y) * (currentPoint.x - p2.x) < 0)\n                break;\n            bottomChain.pop();\n        }\n        bottomChain.push(currentPoint);\n    }\n    // Remove the last point to avoid duplication\n    if (bottomChain.length > 0) {\n        bottomChain.pop();\n    }\n    // Handle special case with only one point\n    if (topChain.length === 1 && bottomChain.length === 1) {\n        const topPoint = topChain[0];\n        const bottomPoint = bottomChain[0];\n        if (topPoint && bottomPoint && topPoint.x === bottomPoint.x && topPoint.y === bottomPoint.y) {\n            return topChain;\n        }\n    }\n    // Combine the two chains to form the complete hull\n    return [...topChain, ...bottomChain];\n}\n// Comparator function for sorting points\nexport function comparePoints(a, b) {\n    // First sort by x-coordinate\n    if (a.x !== b.x) {\n        return a.x < b.x ? -1 : 1;\n    }\n    // If x-coordinates are equal, sort by y-coordinate\n    if (a.y !== b.y) {\n        return a.y < b.y ? -1 : 1;\n    }\n    // Points are equal\n    return 0;\n}\n", "export * from \"./hull\";\nimport { computeConvexHull } from \"./hull\";\nexport function getPointsFromEl(el) {\n    const rect = el.getBoundingClientRect();\n    return [\n        { x: rect.left, y: rect.top }, // tl\n        { x: rect.right, y: rect.top }, // tr\n        { x: rect.right, y: rect.bottom }, // br\n        { x: rect.left, y: rect.bottom }, // bl\n    ];\n}\nexport function computeConvexHullFromElements(els) {\n    const points = els.flatMap((el) => getPointsFromEl(el));\n    return computeConvexHull(points);\n}\nexport function pointInPolygon(point, polygon) {\n    let inside = false;\n    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n        const pi = polygon[i];\n        const pj = polygon[j];\n        if (!pi || !pj)\n            continue;\n        const xi = pi.x;\n        const yi = pi.y;\n        const xj = pj.x;\n        const yj = pj.y;\n        const intersect = yi > point.y !== yj > point.y && point.x < ((xj - xi) * (point.y - yi)) / (yj - yi) + xi;\n        if (intersect)\n            inside = !inside;\n    }\n    return inside;\n}\n", "import { pointInPolygon } from \"./polygon\";\nexport function isPointerInGraceArea(e, area) {\n    if (!area)\n        return false;\n    return pointInPolygon({ x: e.clientX, y: e.clientY }, area);\n}\n", "import { Synced } from \"../Synced.svelte\";\nimport { dataAttr } from \"../utils/attribute\";\nimport { addEventListener } from \"../utils/event\";\nimport { extract } from \"../utils/extract\";\nimport { createBuilderMetadata } from \"../utils/identifiers\";\nimport { isHtmlElement } from \"../utils/is\";\nimport { isPointerInGraceArea } from \"../utils/pointer\";\nimport { computeConvexHull, getPointsFromEl } from \"../utils/polygon\";\nimport { safelyHidePopover, safelyShowPopover } from \"../utils/popover\";\nimport { useFloating } from \"../utils/use-floating.svelte\";\nimport { useEventListener, watch } from \"runed\";\nimport { untrack } from \"svelte\";\nimport { on } from \"svelte/events\";\nconst { createIds, dataAttrs, dataSelectors } = createBuilderMetadata(\"tooltip\", [\n    \"trigger\",\n    \"content\",\n    \"arrow\",\n]);\nexport class Tooltip {\n    #ids = createIds();\n    /** Props */\n    #props;\n    closeOnPointerDown = $derived(extract(this.#props.closeOnPointerDown, true));\n    openDelay = $derived(extract(this.#props.openDelay, 1000));\n    closeDelay = $derived(extract(this.#props.closeDelay, 0));\n    disableHoverableContent = $derived(extract(this.#props.disableHoverableContent, false));\n    forceVisible = $derived(extract(this.#props.forceVisible, false));\n    floatingConfig = $derived(extract(this.#props.floatingConfig));\n    /** State */\n    isVisible = $derived(this.open || this.forceVisible);\n    #open;\n    #openReason = $state(null);\n    #clickedTrigger = $state(false);\n    #isPointerInsideTrigger = $state(false);\n    #isPointerInsideContent = $state(false);\n    #isMouseInTooltipArea = $state(false);\n    #openTimeout = $state(null);\n    #closeTimeout = $state(null);\n    #floatingData = $state();\n    get graceAreaPolygon() {\n        const contentEl = document.getElementById(this.#ids.content);\n        const triggerEl = document.getElementById(this.#ids.trigger);\n        if (!contentEl || !triggerEl) {\n            return [];\n        }\n        const PADDING = 6;\n        const [tl, tr, br, bl] = getPointsFromEl(triggerEl);\n        const contentPoints = this.disableHoverableContent ? [] : getPointsFromEl(contentEl);\n        const placement = this.#floatingData?.placement;\n        const points = [...contentPoints];\n        if (placement?.startsWith(\"top\")) {\n            points.push(tl, tr);\n        }\n        else if (placement?.startsWith(\"right\")) {\n            points.push(tr, br);\n        }\n        else if (placement?.startsWith(\"bottom\")) {\n            points.push(br, bl);\n        }\n        else {\n            points.push(bl, tl);\n        }\n        const withPadding = points.reduce((acc, point) => {\n            return [\n                ...acc,\n                { x: point.x + PADDING, y: point.y + PADDING },\n                { x: point.x + PADDING, y: point.y - PADDING },\n                { x: point.x - PADDING, y: point.y + PADDING },\n                { x: point.x - PADDING, y: point.y - PADDING },\n            ];\n        }, []);\n        return computeConvexHull(withPadding);\n    }\n    constructor(props = {}) {\n        this.#open = new Synced({\n            value: props.open,\n            onChange: props.onOpenChange,\n            defaultValue: false,\n        });\n        this.#props = props;\n        watch([() => this.open, () => this.#openReason], () => {\n            if (!this.open || typeof document === \"undefined\")\n                return;\n            return on(document, \"mousemove\", (e) => {\n                const contentEl = document.getElementById(this.#ids.content);\n                const triggerEl = document.getElementById(this.#ids.trigger);\n                if (!contentEl || !triggerEl) {\n                    if (this.open)\n                        this.#closeTooltip();\n                    return;\n                }\n                const polygon = this.graceAreaPolygon;\n                // DEBUG PURPOSES ONLY.\n                // Draw the polygon on the screen\n                // const debugEl = document.createElement(\"div\");\n                // debugEl.style.position = \"fixed\";\n                // debugEl.style.pointerEvents = \"none\";\n                // debugEl.style.zIndex = \"9999\";\n                // debugEl.style.backgroundColor = \"rgba(255, 0, 0, 0.2)\";\n                // debugEl.style.border = \"1px solid red\";\n                //\n                // const points = polygon.map((p) => `${p.x}px ${p.y}px`).join(\", \");\n                // debugEl.style.clipPath = `polygon(${points})`;\n                //\n                // debugEl.style.width = \"100vw\";\n                // debugEl.style.height = \"100vh\";\n                // debugEl.style.left = \"0\";\n                // debugEl.style.top = \"0\";\n                //\n                // document.body.appendChild(debugEl);\n                //\n                // // Clean up previous debug element if any\n                // const prevDebug = document.querySelector(\"[data-melt-tooltip-debug]\");\n                // if (prevDebug) prevDebug.remove();\n                //\n                // debugEl.setAttribute(\"data-melt-tooltip-debug\", \"\");\n                // DEBUG END\n                this.#isMouseInTooltipArea =\n                    this.#isPointerInsideContent ||\n                        this.#isPointerInsideTrigger ||\n                        isPointerInGraceArea(e, polygon);\n                if (this.#openReason !== \"pointer\")\n                    return;\n                if (!this.#isMouseInTooltipArea) {\n                    this.#closeTooltip();\n                }\n            });\n        });\n    }\n    get open() {\n        return this.#open.current;\n    }\n    set open(value) {\n        this.#open.current = value;\n    }\n    get #sharedProps() {\n        return {\n            onfocusout: async () => {\n                await new Promise((r) => setTimeout(r)); // tick\n                const contentEl = document.getElementById(this.#ids.content);\n                const triggerEl = document.getElementById(this.#ids.trigger);\n                if (contentEl?.contains(document.activeElement) ||\n                    triggerEl?.contains(document.activeElement)) {\n                    return;\n                }\n                this.open = false;\n            },\n        };\n    }\n    get trigger() {\n        $effect(() => {\n            const el = document.getElementById(this.#ids.content);\n            if (!isHtmlElement(el))\n                return;\n            return () => (this.#isPointerInsideTrigger = false);\n        });\n        return {\n            [dataAttrs.trigger]: \"\",\n            id: this.#ids.trigger,\n            \"aria-describedby\": this.#ids.content,\n            \"data-open\": dataAttr(this.open),\n            onpointerdown: () => {\n                if (!this.closeOnPointerDown)\n                    return;\n                this.open = false;\n                this.#clickedTrigger = true;\n                this.#stopOpening();\n            },\n            onpointerenter: (e) => {\n                this.#isPointerInsideTrigger = true;\n                if (e.pointerType === \"touch\")\n                    return;\n                this.#openTooltip(\"pointer\");\n            },\n            onpointermove: () => {\n                this.#isPointerInsideTrigger = true;\n            },\n            onpointerleave: (e) => {\n                this.#isPointerInsideTrigger = false;\n                if (e.pointerType === \"touch\")\n                    return;\n                this.#stopOpening();\n            },\n            onfocus: () => {\n                if (this.#clickedTrigger)\n                    return;\n                this.#openTooltip(\"focus\");\n            },\n            onblur: () => this.#closeTooltip(true),\n            ...this.#sharedProps,\n        };\n    }\n    get content() {\n        $effect(() => {\n            const triggerEl = document.getElementById(this.#ids.trigger);\n            const contentEl = document.getElementById(this.#ids.content);\n            if (!triggerEl || !contentEl || !this.open)\n                return;\n            useFloating({\n                node: () => triggerEl,\n                floating: () => contentEl,\n                config: {\n                    ...this.floatingConfig,\n                    onCompute: ({ floatingApply, arrowApply, ...data }) => {\n                        this.#floatingData = data;\n                        if (this.floatingConfig?.onCompute) {\n                            this.floatingConfig.onCompute({ floatingApply, arrowApply, ...data });\n                        }\n                        else {\n                            floatingApply();\n                            arrowApply();\n                        }\n                    },\n                },\n            });\n        });\n        $effect(() => {\n            const triggerEl = document.getElementById(this.#ids.trigger);\n            const contentEl = document.getElementById(this.#ids.content);\n            if (!triggerEl || !contentEl)\n                return;\n            if (!this.isVisible) {\n                safelyHidePopover(contentEl);\n                return () => (this.#isPointerInsideContent = false);\n            }\n            // Check if there's a parent tooltip. If so, only open if the parent's open.\n            // This is to guarantee correct layering.\n            const parent = isHtmlElement(contentEl.parentNode)\n                ? contentEl.parentNode.closest(dataSelectors.content)\n                : undefined;\n            if (!isHtmlElement(parent)) {\n                safelyShowPopover(contentEl);\n                return;\n            }\n            if (parent.dataset.open !== undefined)\n                safelyShowPopover(contentEl);\n            const toggleUnsub = addEventListener(parent, \"toggle\", async (e) => {\n                await new Promise((r) => setTimeout(r));\n                const isOpen = e.newState === \"open\";\n                if (isOpen) {\n                    safelyShowPopover(contentEl);\n                }\n                else {\n                    safelyHidePopover(contentEl);\n                }\n            });\n            const observer = new MutationObserver((mutations) => untrack(() => {\n                const parent = mutations[0]?.target;\n                if (!isHtmlElement(parent))\n                    return;\n                if (parent.inert && this.open) {\n                    this.#closeTooltip();\n                }\n            }));\n            observer.observe(parent, {\n                attributes: true,\n            });\n            return () => {\n                toggleUnsub();\n                observer.disconnect();\n            };\n        });\n        useEventListener(() => document, \"scroll\", (e) => this.#handleScroll(e), { capture: true });\n        useEventListener(() => document, \"keydown\", (e) => {\n            const el = document.getElementById(this.#ids.content);\n            if (e.key !== \"Escape\" || !this.open || !el)\n                return;\n            e.preventDefault();\n            const openTooltips = [...el.querySelectorAll(\"[popover]\")].filter((child) => {\n                if (!isHtmlElement(child))\n                    return false;\n                // If child is a Melt popover, check if it's open\n                if (child.matches(dataSelectors.content))\n                    return child.dataset.open !== undefined;\n                return child.matches(\":popover-open\");\n            });\n            if (openTooltips.length)\n                return;\n            this.#stopOpening();\n            setTimeout(() => (this.open = false));\n        });\n        return {\n            [dataAttrs.content]: \"\",\n            id: this.#ids.content,\n            popover: \"manual\",\n            role: \"tooltip\",\n            tabindex: -1,\n            style: `overflow: visible;`,\n            inert: !this.open,\n            \"data-open\": dataAttr(this.open),\n            onpointerenter: () => {\n                this.#isPointerInsideContent = true;\n                this.#openTooltip(\"pointer\");\n            },\n            onpointerleave: () => {\n                this.#isPointerInsideContent = false;\n            },\n            onpointerdown: () => this.#openTooltip(\"pointer\"),\n            ...this.#sharedProps,\n        };\n    }\n    get arrow() {\n        return {\n            [dataAttrs.arrow]: \"\",\n            id: this.#ids.arrow,\n            \"data-arrow\": \"\",\n            \"aria-hidden\": true,\n            \"data-open\": dataAttr(this.open),\n        };\n    }\n    #openTooltip(reason) {\n        if (this.#closeTimeout) {\n            window.clearTimeout(this.#closeTimeout);\n            this.#closeTimeout = null;\n        }\n        if (!this.#openTimeout) {\n            this.#openTimeout = window.setTimeout(() => {\n                this.open = true;\n                this.#openReason = this.#openReason ?? reason;\n                this.#openTimeout = null;\n            }, this.openDelay);\n        }\n    }\n    #stopOpening() {\n        if (this.#openTimeout) {\n            window.clearTimeout(this.#openTimeout);\n            this.#openTimeout = null;\n        }\n    }\n    #closeTooltip(isBlur) {\n        const contentEl = document.getElementById(this.#ids.content);\n        if (!isHtmlElement(contentEl))\n            return;\n        this.#stopOpening();\n        if (isBlur && this.#isMouseInTooltipArea) {\n            this.#openReason = \"pointer\";\n            return;\n        }\n        if (!this.#closeTimeout) {\n            this.#closeTimeout = window.setTimeout(() => {\n                this.open = false;\n                this.#openReason = null;\n                if (isBlur)\n                    this.#clickedTrigger = false;\n                this.#closeTimeout = null;\n            }, this.closeDelay);\n        }\n    }\n    #handleScroll(e) {\n        if (!this.open)\n            return;\n        const target = e.target;\n        if (!(target instanceof Element) && !(target instanceof Document))\n            return;\n        const triggerEl = document.getElementById(this.#ids.trigger);\n        if ((triggerEl && target.contains(triggerEl)) || this.open) {\n            this.#closeTooltip();\n        }\n    }\n}\n", "export class Collection {\n    source;\n    defaultValue;\n    constructor(source, defaultValue) {\n        this.source = source;\n        this.defaultValue = defaultValue;\n    }\n    getIterable() {\n        if (!this.source) {\n            return this.defaultValue !== undefined ? this.defaultValue : [];\n        }\n        return typeof this.source === \"function\" ? this.source() : this.source;\n    }\n    *[Symbol.iterator]() {\n        const iterable = this.getIterable();\n        if (iterable) {\n            yield* iterable;\n        }\n    }\n    *keys() {\n        const iterable = this.getIterable();\n        if (iterable) {\n            let index = 0;\n            for (const _ of iterable) {\n                yield index++;\n            }\n        }\n    }\n    *values() {\n        const iterable = this.getIterable();\n        if (iterable) {\n            yield* iterable;\n        }\n    }\n    *entries() {\n        const iterable = this.getIterable();\n        if (iterable) {\n            let index = 0;\n            for (const value of iterable) {\n                yield [index++, value];\n            }\n        }\n    }\n    toArray() {\n        const iterable = this.getIterable();\n        return iterable ? Array.from(iterable) : [];\n    }\n    toSet() {\n        const iterable = this.getIterable();\n        return new Set(iterable);\n    }\n    size() {\n        const iterable = this.getIterable();\n        if (!iterable)\n            return 0;\n        let count = 0;\n        for (const _ of iterable) {\n            count++;\n        }\n        return count;\n    }\n    isEmpty() {\n        const iterable = this.getIterable();\n        if (!iterable)\n            return true;\n        for (const _ of iterable) {\n            return false;\n        }\n        return true;\n    }\n    first() {\n        const iterable = this.getIterable();\n        if (!iterable)\n            return undefined;\n        for (const value of iterable) {\n            return value;\n        }\n        return undefined;\n    }\n    last() {\n        const iterable = this.getIterable();\n        if (!iterable)\n            return undefined;\n        let lastValue;\n        for (const value of iterable) {\n            lastValue = value;\n        }\n        return lastValue;\n    }\n    find(predicate) {\n        const iterable = this.getIterable();\n        if (!iterable)\n            return undefined;\n        for (const value of iterable) {\n            if (predicate(value)) {\n                return value;\n            }\n        }\n        return undefined;\n    }\n    some(predicate) {\n        const iterable = this.getIterable();\n        if (!iterable)\n            return false;\n        for (const value of iterable) {\n            if (predicate(value)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    every(predicate) {\n        const iterable = this.getIterable();\n        if (!iterable)\n            return true;\n        for (const value of iterable) {\n            if (!predicate(value)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n", "export function isMac() {\n    return /mac/i.test(navigator.platform);\n}\nexport function isControlOrMeta(event) {\n    return isMac() ? event.metaKey : event.ctrlKey;\n}\n", "import { dataAttr } from \"../utils/attribute\";\nimport { Collection } from \"../utils/collection\";\nimport { extract } from \"../utils/extract\";\nimport { createDataIds } from \"../utils/identifiers\";\nimport { isString } from \"../utils/is\";\nimport { first, last } from \"../utils/iterator\";\nimport { isControlOrMeta } from \"../utils/platform\";\nimport { SelectionState } from \"../utils/selection-state.svelte\";\nimport { createTypeahead, letterRegex } from \"../utils/typeahead.svelte\";\nimport { useDebounce } from \"runed\";\nconst identifiers = createDataIds(\"tree\", [\"root\", \"item\", \"group\"]);\n/**\n * Main tree component class that handles selection, expansion, and keyboard navigation\n * @template I - Array type extending TreeItem\n * @template Multiple - Boolean indicating if multiple selection is enabled\n */\nexport class Tree {\n    #props;\n    /** The items contained in the tree */\n    collection;\n    /** If `true`, the user can select multiple items holding `Control`/`Meta` or `Shift` */\n    multiple = $derived(extract(this.#props.multiple, false));\n    /** If `true`, groups (items with children) expand on click */\n    expandOnClick = $derived(extract(this.#props.expandOnClick, true));\n    typeaheadTimeout = $derived(extract(this.#props.typeaheadTimeout, 500));\n    typeahead = $derived(createTypeahead({\n        timeout: this.#props.typeaheadTimeout,\n        getItems: () => {\n            const activeEl = document.activeElement;\n            if (!isString(activeEl?.getAttribute(identifiers.item)))\n                return [];\n            const visibleChildren = getAllChildren(this, true);\n            return visibleChildren.reduce((acc, curr) => {\n                if (!curr.el?.innerText)\n                    return acc;\n                return [\n                    ...acc,\n                    {\n                        child: curr,\n                        value: curr.el.innerText,\n                        current: curr.el.id === activeEl.id,\n                    },\n                ];\n            }, []);\n        },\n    }));\n    #selected;\n    #expanded;\n    #id = crypto.randomUUID();\n    /**\n     * Creates a new Tree instance\n     * @param props - Configuration props for the tree\n     */\n    constructor(props) {\n        this.#props = props;\n        this.collection = new Collection(props.items);\n        this.#selected = new SelectionState({\n            value: props.selected,\n            onChange: props.onSelectedChange,\n            multiple: props.multiple,\n        });\n        this.#expanded = new SelectionState({\n            value: props.expanded,\n            onChange: props.onExpandedChange,\n            multiple: true,\n        });\n    }\n    get items() {\n        return [...this.collection];\n    }\n    /**\n     * Currently selected item(s)\n     * For multiple selection, returns a Set of IDs\n     * For single selection, returns a single ID or undefined\n     */\n    get selected() {\n        return this.#selected.current;\n    }\n    set selected(v) {\n        this.#selected.current = v;\n    }\n    /**\n     * Set of currently expanded item IDs\n     */\n    get expanded() {\n        return this.#expanded.current;\n    }\n    set expanded(v) {\n        this.#expanded.current = v;\n    }\n    /**\n     * Checks if an item is currently selected\n     * @param id - ID of the item to check\n     */\n    isSelected(id) {\n        return this.#selected.has(id);\n    }\n    /**\n     * Checks if an item is currently expanded\n     * @param id - ID of the item to check\n     */\n    isExpanded(id) {\n        return this.#expanded.has(id);\n    }\n    /**\n     * Expands a specific item\n     * @param id - ID of the item to expand\n     */\n    expand(id) {\n        this.#expanded.add(id);\n    }\n    /**\n     * Collapses a specific item\n     * @param id - ID of the item to collapse\n     */\n    collapse(id) {\n        this.#expanded.delete(id);\n    }\n    /**\n     * Toggles the expanded state of an item\n     * @param id - ID of the item to toggle\n     */\n    toggleExpand(id) {\n        this.#expanded.toggle(id);\n    }\n    /**\n     * Selects a specific item\n     * @param id - ID of the item to select\n     */\n    select(id) {\n        this.#selected.add(id);\n    }\n    /**\n     * Deselects a specific item\n     * @param id - ID of the item to deselect\n     */\n    deselect(id) {\n        this.#selected.delete(id);\n    }\n    /**\n     * Clears all current selections\n     */\n    clearSelection() {\n        this.#selected.clear();\n    }\n    /**\n     * Toggles the selected state of an item\n     * @param id - ID of the item to toggle\n     */\n    toggleSelect(id) {\n        this.#selected.toggle(id);\n    }\n    /**\n     * Selects all visible items.\n     * If all items are already selected, clears the selection.\n     */\n    selectAll() {\n        const ids = getAllChildren(this, true).map((c) => c.id);\n        const alreadySelected = ids.every((id) => this.#selected.has(id));\n        if (alreadySelected) {\n            this.clearSelection();\n        }\n        else {\n            this.#selected.addAll(ids);\n        }\n    }\n    /**\n     * Gets the DOM ID for a specific tree item\n     * @param id - ID of the item\n     */\n    getItemId(id) {\n        return `melt-tree-${this.#id}-item--${id}`;\n    }\n    /**\n     * Gets the DOM element for a specific tree item\n     * @param id - ID of the item\n     */\n    getItemEl(id) {\n        return document.getElementById(this.getItemId(id));\n    }\n    /**\n     * Selects all items between the last selected item and the specified item\n     * @param id - ID of the item to select until\n     */\n    selectUntil(id) {\n        // TODO: Use a direction constant to ensure correct order?\n        if (!this.#selected.size())\n            return this.select(id);\n        const allChildren = getAllChildren(this);\n        const to = allChildren.find((c) => c.id === id);\n        if (!to)\n            return;\n        const from = allChildren.find((c) => c.id === first(this.#selected.toSet()));\n        if (!from)\n            return this.select(id);\n        const fromIdx = allChildren.indexOf(from);\n        const toIdx = allChildren.indexOf(to);\n        const [start, end] = fromIdx < toIdx ? [from, to] : [to, from];\n        let current = start;\n        this.clearSelection();\n        // Ensure from remains the same\n        this.select(from.id);\n        this.select(start.id);\n        while (current.id !== end.id && current.next) {\n            current = current.next;\n            this.select(current.id);\n        }\n    }\n    /**\n     * Gets ARIA attributes for the root tree element\n     */\n    get root() {\n        return {\n            role: \"tree\",\n            [identifiers.root]: \"\",\n        };\n    }\n    /**\n     * ARIA attributes for group elements\n     */\n    get group() {\n        return {\n            role: \"group\",\n            [identifiers.group]: \"\",\n        };\n    }\n    /**\n     * Array of Child instances representing the top-level items\n     */\n    get children() {\n        return [...this.collection].map((i) => new Child({ tree: this, item: i, parent: this, selectedState: this.#selected }));\n    }\n}\n/**\n * Helper function to get all child items in a tree or subtree\n * @param treeOrChild - Tree or Child instance to get children from\n * @param onlyVisible - If true, only returns visible (expanded) children\n */\nfunction getAllChildren(treeOrChild, onlyVisible = false) {\n    const children = !onlyVisible || treeOrChild instanceof Tree || treeOrChild.expanded ? treeOrChild.children : [];\n    return (children?.reduce((acc, c) => {\n        return [...acc, c, ...getAllChildren(c, onlyVisible)];\n    }, []) || []);\n}\n/**\n * Class representing a single item in the tree\n * @template I - Array type extending TreeItem\n */\nclass Child {\n    #props;\n    tree = $derived(this.#props.tree);\n    selectedState = $derived(this.#props.selectedState);\n    item = $derived(this.#props.item);\n    elId = $derived(this.tree.getItemId(this.item.id));\n    id = $derived(this.item.id);\n    parent = $derived(this.#props.parent);\n    /**\n     * Creates a new Child instance\n     * @param props - Configuration props for the child\n     */\n    constructor(props) {\n        this.#props = props;\n    }\n    /** The DOM element representing this item */\n    get el() {\n        return document.getElementById(this.elId);\n    }\n    /** Whether this item is currently selected */\n    selected = $derived(this.tree.isSelected(this.id));\n    /** Whether this item is currently expanded */\n    expanded = $derived(this.tree.isExpanded(this.id));\n    /** Whether this item can be expanded (has children) */\n    canExpand = $derived(Boolean(this.item.children && this.item.children?.length > 0));\n    /** Collapses this item */\n    collapse = () => this.tree.collapse(this.id);\n    /** Expands this item */\n    expand = () => this.tree.expand(this.id);\n    /** Toggles the expanded state of this item */\n    toggleExpand = () => this.tree.toggleExpand(this.id);\n    /** Selects this item */\n    select = () => this.tree.select(this.id);\n    /** Deselects this item */\n    deselect = () => this.tree.deselect(this.id);\n    /** Toggles the selected state of this item */\n    toggleSelect = () => this.tree.toggleSelect(this.id);\n    /** Focuses this item's DOM element */\n    focus = () => this.el?.focus();\n    idx = $derived(this.parent?.children?.findIndex((c) => c.id === this.id) ?? -1);\n    /** Gets all sibling items */\n    get siblings() {\n        return this.parent?.children ?? [];\n    }\n    /** Gets the previous sibling item */\n    get previousSibling() {\n        return this.siblings[this.idx - 1];\n    }\n    /** Gets the next sibling item */\n    get nextSibling() {\n        return this.siblings[this.idx + 1];\n    }\n    /** Gets the previous item in the tree (including parent/child relationships) */\n    get previous() {\n        let current = this.previousSibling;\n        if (!current)\n            return this.parent instanceof Child ? this.parent : undefined;\n        while (current?.expanded) {\n            current = last(current?.children ?? []);\n        }\n        return current;\n    }\n    /** Gets the next item in the tree (including parent/child relationships) */\n    get next() {\n        if (this.expanded) {\n            return this.children?.[0];\n        }\n        if (this.nextSibling) {\n            return this.nextSibling;\n        }\n        if (this.parent instanceof Child) {\n            let p = this.parent;\n            while (p && !p.nextSibling) {\n                if (p.parent instanceof Tree)\n                    break;\n                p = p.parent;\n            }\n            return p?.nextSibling;\n        }\n    }\n    /** Gets the tabindex for this item's DOM element */\n    get tabindex() {\n        if (this.selectedState.size()) {\n            return this.tree.isSelected(this.id) ? 0 : -1;\n        }\n        return this.parent instanceof Tree && this.idx === 0 ? 0 : -1;\n    }\n    /** Gets DOM and ARIA attributes for this item */\n    get attrs() {\n        return {\n            id: this.elId,\n            [identifiers.item]: \"\",\n            \"data-selected\": dataAttr(this.selected),\n            tabindex: this.tabindex,\n            role: \"treeitem\",\n            onclick: (e) => {\n                e.stopPropagation();\n                if (!isControlOrMeta(e) && !e.shiftKey)\n                    this.tree.clearSelection();\n                if (this.tree.expandOnClick &&\n                    this.canExpand &&\n                    (!this.tree.multiple || (!isControlOrMeta(e) && !e.shiftKey))) {\n                    this.toggleExpand();\n                }\n                if (isControlOrMeta(e))\n                    this.toggleSelect();\n                else\n                    this.tree.select(this.id);\n                if (e.shiftKey)\n                    this.tree.selectUntil(this.id);\n                this.focus();\n            },\n            onkeydown: (e) => {\n                let shouldPrevent = true;\n                switch (e.key) {\n                    case \"ArrowLeft\": {\n                        if (this.expanded) {\n                            this.collapse();\n                            break;\n                        }\n                        if (!(this.parent instanceof Child))\n                            return;\n                        this.parent?.focus();\n                        break;\n                    }\n                    case \"ArrowRight\": {\n                        if (!this.canExpand)\n                            break;\n                        if (this.expanded) {\n                            this.children?.[0]?.focus();\n                            break;\n                        }\n                        this.expand();\n                        break;\n                    }\n                    case \"ArrowUp\": {\n                        this.previous?.focus();\n                        if (e.shiftKey)\n                            this.previous?.toggleSelect();\n                        break;\n                    }\n                    case \"ArrowDown\": {\n                        this.next?.focus();\n                        if (e.shiftKey)\n                            this.next?.toggleSelect();\n                        break;\n                    }\n                    case \" \": {\n                        if (!this.tree.multiple)\n                            break;\n                        if (e.shiftKey) {\n                            this.tree.selectUntil(this.id);\n                            break;\n                        }\n                        this.toggleSelect();\n                        break;\n                    }\n                    case \"Enter\": {\n                        this.tree.clearSelection();\n                        this.select();\n                        break;\n                    }\n                    case \"Home\": {\n                        first(getAllChildren(this.tree))?.focus();\n                        break;\n                    }\n                    case \"End\": {\n                        last(getAllChildren(this.tree, true))?.focus();\n                        break;\n                    }\n                    case \"*\": {\n                        this.siblings.forEach((s) => s.expand());\n                        break;\n                    }\n                    default: {\n                        if (letterRegex.test(e.key)) {\n                            if (e.ctrlKey) {\n                                if (e.key === \"a\") {\n                                    this.tree.selectAll();\n                                }\n                                break;\n                            }\n                            const next = this.tree.typeahead(e.key);\n                            next?.child.el?.focus();\n                            break;\n                        }\n                        shouldPrevent = false;\n                    }\n                }\n                if (shouldPrevent) {\n                    e.preventDefault();\n                    e.stopPropagation();\n                }\n            },\n        };\n    }\n    /** The item's sub-items, if any */\n    get children() {\n        return this.item.children?.map((i) => new Child({ ...this.#props, item: i, parent: this }));\n    }\n}\n"],
  "mappings": "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",
  "names": ["document", "activeElement", "window", "document", "isFunction", "extract", "isFunction", "get", "isFunction", "extract", "set", "get", "extract", "set", "value", "size", "keys", "identifiers", "dataAttrs", "dataSelectors", "createIds", "_props", "_props", "dataAttrs", "createIds", "_props", "_ids", "event", "platform", "state", "max", "offset", "state", "platform", "placements", "sides", "side", "placement", "overflow", "state", "platform", "x", "y", "min", "max", "state", "platform", "isNode", "isElement", "isElement", "offset", "shift", "flip", "size", "arrow", "computePosition", "arrow", "shift", "flip", "offset", "size", "computePosition", "x", "y", "dataAttrs", "dataSelectors", "_props", "_open", "dataAttrs", "dataSelectors", "createIds", "_value", "_props", "first", "last", "offset", "dataAttrs", "createIds", "_props", "_ids", "set", "identifiers", "_props", "_value", "_a", "_props", "_value", "_props", "_value", "sharedAttrs_get", "_ids", "el", "dataAttrs", "dataSelectors", "createIds", "_value", "_props", "_highlighted", "first", "last", "clamp", "min", "max", "createIds", "dataAttrs", "_props", "_value", "clamp", "identifiers", "_props", "_value", "_id", "_props", "identifiers", "_props", "_value", "createIds", "dataAttrs", "dataSelectors", "_props", "_open", "_ids", "sharedProps_get", "parent", "identifiers", "_props", "_selected", "_id"]
}
